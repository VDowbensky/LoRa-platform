
void deregister_tm_clones(void)
{
  if ((false) && (false))
  {
    (*(code *)0x0)();
    return;
  }
  return;
}



void register_tm_clones(void)
{
  if ((false) && (false))
  {
    (*(code *)0x0)();
    return;
  }
  return;
}



undefined * __do_global_dtors_aux(undefined *param_1)
{
  code *pcVar1;
  
  if ((char)completed_8100 == '\0')
  {
    pcVar1 = (code *)deregister_tm_clones();
    if (false)
    {
      pcVar1 = _init;
    }
    completed_8100._0_1_ = '\x01';
    param_1 = pcVar1;
  }
  return (code *)param_1;
}



void frame_dummy(void)
{
  register_tm_clones();
  return;
}



// WARNING: Unknown calling convention

void __assert_func(char *file,int line,char *func,char *failedexpr)
{
  char *pcVar1;
  
  if (func == (char *)0x0)
  {
    func = "";
    pcVar1 = func;
  }
  else
  {
    pcVar1 = ", function: ";
  }
  fprintf((FILE *)_impure_ptr->_stderr,"assertion \"%s\" failed: file \"%s\", line %d%s%s\n",
          failedexpr,file,line,pcVar1,func);
                    // WARNING: Subroutine does not return
  abort();
}



void __assert(char *__assertion,char *__file,int __line)
{
                    // WARNING: Subroutine does not return
  __assert_func(__assertion,(int)__file,(char *)0x0,(char *)__line);
}



int _fprintf_r(_reent_conflict *ptr,FILE *fp,char *fmt,...)
{
  int iVar1;
  undefined4 in_r3;
  va_list ap;
  char *fmt_local;
  undefined4 uStack_4;
  
  uStack_4 = in_r3;
  iVar1 = _vfprintf_r(ptr,fp,fmt,(va_list)&uStack_4);
  return iVar1;
}



int fprintf(FILE *__stream,char *__format,...)
{
  int iVar1;
  undefined4 in_r2;
  undefined4 in_r3;
  va_list ap;
  char *fmt_local;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  uStack_8 = in_r2;
  uStack_4 = in_r3;
  iVar1 = _vfprintf_r(_impure_ptr,(FILE *)__stream,__format,(va_list)&uStack_8);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __libc_init_array(void)
{
  EVP_PKEY_CTX *in_r0;
  int iVar1;
  undefined4 *puVar2;
  
  if (false)
  {
    iVar1 = 0;
    puVar2 = &__frame_dummy_init_array_entry;
    do
    {
      iVar1 += 1;
      in_r0 = (EVP_PKEY_CTX *)(*(code *)*puVar2)();
      puVar2 = puVar2 + 1;
    } while (iVar1 != 0);
  }
  _init(in_r0);
  if (true)
  {
    iVar1 = 0;
    puVar2 = &__frame_dummy_init_array_entry;
    do
    {
      iVar1 += 1;
      (*(code *)*puVar2)();
      puVar2 = puVar2 + 1;
    } while (iVar1 != 1);
  }
  return;
}



void * malloc(size_t __size)
{
  void *pvVar1;
  
  pvVar1 = _malloc_r(_impure_ptr,__size);
  return pvVar1;
}



void free(void *__ptr)
{
  _free_r(_impure_ptr,__ptr);
  return;
}



int memcmp(void *__s1,void *__s2,size_t __n)
{
  byte *pbVar1;
  byte *pbVar2;
  uint uVar3;
  uint uVar4;
  byte *pbVar5;
  
  if (3 < __n)
  {
    pbVar1 = (byte *)__s1;
    pbVar2 = (byte *)__s2;
    if ((((uint)__s1 | (uint)__s2) & 3) != 0) goto LAB_0800036c;
    do
    {
      __s2 = pbVar2 + 4;
      __s1 = pbVar1 + 4;
      if (*(int *)pbVar1 != *(int *)pbVar2) goto LAB_0800036c;
      __n -= 4;
      pbVar2 = (byte *)__s2;
      pbVar1 = (byte *)__s1;
    } while (3 < __n);
  }
  pbVar1 = (byte *)__s1;
  pbVar2 = (byte *)__s2;
  if (__n == 0)
  {
    return 0;
  }
LAB_0800036c:
  uVar4 = (uint)*pbVar1;
  uVar3 = (uint)*pbVar2;
  if (uVar3 == uVar4)
  {
    pbVar5 = pbVar1 + (__n - 1);
    do
    {
      if (pbVar1 == pbVar5)
      {
        return 0;
      }
      pbVar1 = pbVar1 + 1;
      uVar4 = (uint)*pbVar1;
      pbVar2 = pbVar2 + 1;
      uVar3 = (uint)*pbVar2;
    } while (uVar4 == uVar3);
  }
  return uVar4 - uVar3;
}



void * memcpy(void *__dest,void *__src,size_t __n)
{
  undefined1 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined1 *puVar4;
  undefined4 *puVar5;
  undefined1 *puVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  
  puVar3 = (undefined4 *)__dest;
  if ((((uint)__src | (uint)__dest) & 3) != 0)
  {
    if (__n < 8)
    {
      uVar8 = __n - 4;
      puVar1 = (undefined1 *)__dest;
      if (3 < __n)
      {
        do
        {
          puVar6 = (undefined1 *)__src;
          puVar4 = puVar1;
          bVar9 = uVar8 != 0;
          uVar8 -= 1;
          *puVar4 = *puVar6;
          puVar1 = puVar4 + 1;
          __src = puVar6 + 1;
        } while (bVar9);
        puVar4[1] = puVar6[1];
        puVar4[2] = puVar6[2];
        puVar4[3] = puVar6[3];
        return __dest;
      }
      goto LAB_08000468;
    }
    if ((((uint)__src & 3) != 0) && (((uint)__dest & 3) != 0))
    {
      uVar8 = 4 - ((uint)__dest & 3);
      __n -= uVar8;
      puVar2 = (undefined4 *)__dest;
      puVar5 = (undefined4 *)__src;
                    // WARNING: Load size is inaccurate
      if (((uint)__dest & 1) != 0)
      {
        puVar5 = (undefined4 *)((int)__src + 1);
        puVar2 = (undefined4 *)((int)__dest + 1);
        *(undefined1 *)__dest = *__src;
      }
      puVar3 = puVar2;
      __src = puVar5;
      if ((uVar8 & 2) != 0)
      {
        __src = (void *)((int)puVar5 + 2);
        puVar3 = (undefined4 *)((int)puVar2 + 2);
        *(undefined2 *)puVar2 = *(undefined2 *)puVar5;
      }
    }
  }
  while (0x3f < __n)
  {
                    // WARNING: Load size is inaccurate
    *puVar3 = *__src;
    puVar3[1] = *(undefined4 *)((int)__src + 4);
    puVar3[2] = *(undefined4 *)((int)__src + 8);
    puVar3[3] = *(undefined4 *)((int)__src + 0xc);
    puVar3[4] = *(undefined4 *)((int)__src + 0x10);
    puVar3[5] = *(undefined4 *)((int)__src + 0x14);
    puVar3[6] = *(undefined4 *)((int)__src + 0x18);
    puVar3[7] = *(undefined4 *)((int)__src + 0x1c);
    puVar3[8] = *(undefined4 *)((int)__src + 0x20);
    puVar3[9] = *(undefined4 *)((int)__src + 0x24);
    puVar3[10] = *(undefined4 *)((int)__src + 0x28);
    puVar3[0xb] = *(undefined4 *)((int)__src + 0x2c);
    puVar3[0xc] = *(undefined4 *)((int)__src + 0x30);
    puVar3[0xd] = *(undefined4 *)((int)__src + 0x34);
    puVar3[0xe] = *(undefined4 *)((int)__src + 0x38);
    puVar3[0xf] = *(undefined4 *)((int)__src + 0x3c);
    puVar3 = puVar3 + 0x10;
    __src = (undefined4 *)((int)__src + 0x40);
    __n = __n - 0x40;
  }
  uVar7 = __n - 0x10;
  if (0xffffffcf < __n - 0x40)
  {
    do
    {
                    // WARNING: Load size is inaccurate
      *puVar3 = *__src;
      puVar3[1] = *(undefined4 *)((int)__src + 4);
      puVar2 = (undefined4 *)((int)__src + 0xc);
      puVar5 = puVar3 + 3;
      puVar3[2] = *(undefined4 *)((int)__src + 8);
      __src = (void *)((int)__src + 0x10);
      puVar3 = puVar3 + 4;
      *puVar5 = *puVar2;
      bVar9 = 0xf < uVar7;
      uVar7 -= 0x10;
    } while (bVar9);
  }
  uVar8 = uVar7 + 0xc;
  puVar5 = puVar3;
  puVar2 = (undefined4 *)__src;
  if (0xfffffff3 < uVar7)
  {
    do
    {
      __src = puVar2 + 1;
      *puVar5 = *puVar2;
      bVar9 = 3 < uVar8;
      uVar8 -= 4;
      puVar3 = puVar5 + 1;
      puVar5 = puVar5 + 1;
      puVar2 = (undefined4 *)__src;
    } while (bVar9);
  }
LAB_08000468:
  if (uVar8 + 4 != 0)
  {
    puVar2 = puVar3;
    puVar5 = (undefined4 *)__src;
                    // WARNING: Load size is inaccurate
    if ((uVar8 & 1) != 0)
    {
      puVar5 = (undefined4 *)((int)__src + 1);
      puVar2 = (undefined4 *)((int)puVar3 + 1);
      *(undefined1 *)puVar3 = *__src;
    }
    if ((uVar8 + 4 & 2) != 0)
    {
      *(undefined2 *)puVar2 = *(undefined2 *)puVar5;
    }
  }
  return __dest;
}



void * memmove(void *__dest,void *__src,size_t __n)
{
  undefined4 *puVar1;
  undefined1 *puVar2;
  void *pvVar3;
  undefined1 *puVar4;
  int iVar5;
  int iVar6;
  undefined4 *puVar7;
  uint uVar8;
  
  if ((__src < __dest) && (puVar2 = (undefined1 *)((int)__src + __n), __dest < puVar2))
  {
    puVar4 = (undefined1 *)((int)__dest + __n);
    if (__n != 0)
    {
      do
      {
        puVar2 = puVar2 + -1;
        puVar4 = puVar4 + -1;
        *puVar4 = *puVar2;
      } while ((undefined1 *)__src != puVar2);
    }
  }
  else
  {
    uVar8 = __n;
    pvVar3 = __dest;
    if (0xf < __n)
    {
      if ((((uint)__dest | (uint)__src) & 3) != 0)
      {
        iVar5 = __n - 1;
        goto LAB_080004fe;
      }
      uVar8 = __n - 0x10 >> 4;
      iVar5 = (int)__src + 0x10;
      iVar6 = (int)__dest + 0x10;
      do
      {
        *(undefined4 *)(iVar6 + -0x10) = *(undefined4 *)(iVar5 + -0x10);
        *(undefined4 *)(iVar6 + -0xc) = *(undefined4 *)(iVar5 + -0xc);
        *(undefined4 *)(iVar6 + -8) = *(undefined4 *)(iVar5 + -8);
        *(undefined4 *)(iVar6 + -4) = *(undefined4 *)(iVar5 + -4);
        iVar5 += 0x10;
        iVar6 += 0x10;
      } while (iVar5 != (int)__src + uVar8 * 0x10 + 0x20);
      iVar5 = (uVar8 + 1) * 0x10;
      __src = (void *)((int)__src + iVar5);
      pvVar3 = (void *)(iVar5 + (int)__dest);
      uVar8 = __n & 0xf;
      if ((__n & 0xc) != 0)
      {
        uVar8 = (__n & 0xf) - 4 >> 2;
        puVar7 = (undefined4 *)((int)pvVar3 + -4);
        puVar1 = (undefined4 *)__src;
        do
        {
          puVar7 = puVar7 + 1;
          *puVar7 = *puVar1;
          puVar1 = puVar1 + 1;
        } while (puVar7 != (undefined4 *)((int)pvVar3 + uVar8 * 4));
        iVar5 = uVar8 + 1;
        __src = (void *)((int)__src + iVar5 * 4);
        uVar8 = __n & 3;
        pvVar3 = (void *)((int)pvVar3 + iVar5 * 4);
      }
    }
    iVar5 = uVar8 - 1;
    if (uVar8 != 0)
    {
LAB_080004fe:
      puVar2 = (undefined1 *)((int)pvVar3 + -1);
      puVar7 = (undefined4 *)__src;
      do
      {
        puVar1 = (undefined4 *)((int)puVar7 + 1);
        puVar2 = puVar2 + 1;
        *puVar2 = *(undefined1 *)puVar7;
        puVar7 = puVar1;
      } while (puVar1 != (undefined4 *)(iVar5 + 1 + (int)__src));
      return __dest;
    }
  }
  return __dest;
}



void * memset(void *__s,int __c,size_t __n)
{
  uint uVar1;
  uint *puVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  
  puVar2 = (uint *)__s;
  if (((uint)__s & 3) != 0)
  {
    uVar5 = __n - 1;
    puVar3 = (uint *)__s;
    if (__n == 0)
    {
      return __s;
    }
    while( true )
    {
      puVar2 = (uint *)((int)puVar3 + 1);
      *(char *)puVar3 = (char)__c;
      __n = uVar5;
      if (((uint)puVar2 & 3) == 0) break;
      bVar7 = uVar5 == 0;
      uVar5 -= 1;
      puVar3 = puVar2;
      if (bVar7)
      {
        return __s;
      }
    }
  }
  if (3 < __n)
  {
    uVar5 = __c & 0xffU | (__c & 0xffU) << 8;
    uVar5 |= uVar5 << 0x10;
    if (0xf < __n)
    {
      uVar6 = __n - 0x10 >> 4;
      puVar3 = puVar2 + 4;
      do
      {
        puVar3[-4] = uVar5;
        puVar3[-3] = uVar5;
        puVar3[-2] = uVar5;
        puVar3[-1] = uVar5;
        puVar3 = puVar3 + 4;
      } while (puVar3 != puVar2 + uVar6 * 4 + 8);
      uVar1 = __n & 0xc;
      puVar2 = puVar2 + (uVar6 + 1) * 4;
      __n &= 0xf;
      if (uVar1 == 0) goto joined_r0x08000618;
    }
    puVar3 = (uint *)((__n - 4 & 0xfffffffc) + 4 + (int)puVar2);
    do
    {
      puVar4 = puVar2 + 1;
      *puVar2 = uVar5;
      puVar2 = puVar4;
    } while (puVar3 != puVar4);
    __n &= 3;
    puVar2 = puVar3;
  }
joined_r0x08000618:
  if (__n != 0)
  {
    puVar3 = puVar2;
    do
    {
      puVar4 = (uint *)((int)puVar3 + 1);
      *(char *)puVar3 = (char)__c;
      puVar3 = puVar4;
    } while ((uint *)(__n + (int)puVar2) != puVar4);
  }
  return __s;
}



// WARNING: Unknown calling convention

void _free_r(_reent_conflict *reent_ptr,void *free_p)
{
  chunk *pcVar1;
  int iVar2;
  int iVar3;
  chunk *pcVar4;
  chunk *pcVar5;
  chunk *pcVar6;
  
  if (free_p == (void *)0x0)
  {
    return;
  }
  pcVar6 = (chunk *)((int)free_p + -4);
  if (*(int *)((int)free_p + -4) < 0)
  {
    pcVar6 = (chunk *)((int)&pcVar6->size + *(int *)((int)free_p + -4));
  }
  __malloc_lock(reent_ptr);
  if (__malloc_free_list != (chunk *)0x0)
  {
    pcVar5 = __malloc_free_list;
    if (__malloc_free_list <= pcVar6)
    {
      do
      {
        pcVar4 = pcVar5;
        pcVar5 = pcVar4->next;
        if (pcVar5 == (chunk *)0x0) break;
      } while (pcVar5 <= pcVar6);
      pcVar1 = (chunk *)((int)&pcVar4->size + pcVar4->size);
      if (pcVar1 == pcVar6)
      {
        iVar2 = pcVar4->size + pcVar6->size;
        pcVar4->size = iVar2;
        if (pcVar5 == (chunk *)((int)&pcVar4->size + iVar2))
        {
          iVar3 = pcVar5->size;
          pcVar4->next = pcVar5->next;
          pcVar4->size = iVar2 + iVar3;
        }
      }
      else
      {
        if (pcVar6 <= pcVar1 && pcVar1 != pcVar6)
        {
          reent_ptr->_errno = 0xc;
          __malloc_unlock();
          return;
        }
        if (pcVar5 == (chunk *)((int)&pcVar6->size + pcVar6->size))
        {
          iVar2 = pcVar5->size;
          pcVar6->next = pcVar5->next;
          pcVar6->size = pcVar6->size + iVar2;
          pcVar4->next = pcVar6;
        }
        else
        {
          pcVar6->next = pcVar5;
          pcVar4->next = pcVar6;
        }
      }
      __malloc_unlock();
      return;
    }
    if (__malloc_free_list == (chunk *)((int)&pcVar6->size + pcVar6->size))
    {
      iVar2 = __malloc_free_list->size;
      pcVar6->next = __malloc_free_list->next;
      pcVar6->size = pcVar6->size + iVar2;
      goto LAB_0800066c;
    }
  }
  pcVar6->next = __malloc_free_list;
LAB_0800066c:
  __malloc_free_list = pcVar6;
  __malloc_unlock();
  return;
}



// WARNING: Unknown calling convention

void * _malloc_r(_reent_conflict *reent_ptr,malloc_size_t s)
{
  chunk *pcVar1;
  void *pvVar2;
  chunk *pcVar3;
  int iVar4;
  uint uVar5;
  chunk *pcVar6;
  uint incr;
  
  incr = (s + 3 & 0xfffffffc) + 8;
  if (incr < 0xc)
  {
    incr = 0xc;
  }
  if (((int)incr < 0) || (incr < s))
  {
    reent_ptr->_errno = 0xc;
    return (void *)0x0;
  }
  __malloc_lock(reent_ptr);
  if (__malloc_free_list == (chunk *)0x0)
  {
LAB_08000726:
    if (__malloc_sbrk_start == (char *)0x0)
    {
      __malloc_sbrk_start = (char *)_sbrk_r(reent_ptr,0);
    }
    pcVar1 = (chunk *)_sbrk_r(reent_ptr,incr);
    if ((pcVar1 == (chunk *)0xffffffff) ||
       ((pcVar6 = (chunk *)((uint)((int)&pcVar1->size + 3) & 0xfffffffc), pcVar1 != pcVar6 &&
        (pvVar2 = _sbrk_r(reent_ptr,(int)pcVar6 - (int)pcVar1), pvVar2 == (void *)0xffffffff))))
    {
      reent_ptr->_errno = 0xc;
      __malloc_unlock();
      return (void *)0x0;
    }
    pcVar6->size = incr;
    pcVar1 = __malloc_free_list;
  }
  else
  {
    uVar5 = __malloc_free_list->size - incr;
    pcVar6 = __malloc_free_list;
    if ((int)uVar5 < 0)
    {
      do
      {
        pcVar3 = pcVar6;
        pcVar6 = pcVar3->next;
        if (pcVar6 == (chunk *)0x0) goto LAB_08000726;
        uVar5 = pcVar6->size - incr;
      } while ((int)uVar5 < 0);
      if (uVar5 < 0xc)
      {
        pcVar1 = pcVar6->next;
        if (pcVar3 != pcVar6)
        {
          pcVar3->next = pcVar6->next;
          pcVar1 = __malloc_free_list;
        }
        goto LAB_08000750;
      }
    }
    else if (uVar5 < 0xc)
    {
      pcVar1 = __malloc_free_list->next;
      goto LAB_08000750;
    }
    pcVar6->size = uVar5;
    pcVar6 = (chunk *)((int)&pcVar6->size + uVar5);
    pcVar6->size = incr;
    pcVar1 = __malloc_free_list;
  }
LAB_08000750:
  __malloc_free_list = pcVar1;
  __malloc_unlock();
  pvVar2 = (void *)((uint)((int)&pcVar6[1].size + 3) & 0xfffffff8);
  iVar4 = (int)pvVar2 - (int)&pcVar6->next;
  if (iVar4 != 0)
  {
    *(int *)((int)pcVar6 + iVar4) = (int)&pcVar6->next - (int)pvVar2;
  }
  return pvVar2;
}



// WARNING: Unknown calling convention

int __sfputc_r(_reent_conflict *ptr,int c,FILE *fp)
{
  int iVar1;
  uchar *puVar2;
  
  iVar1 = fp->_w + -1;
  fp->_w = iVar1;
  if (-1 < iVar1)
  {
    puVar2 = fp->_p;
    fp->_p = puVar2 + 1;
    *puVar2 = (uchar)c;
    return c;
  }
  if ((fp->_lbfsize <= iVar1) && (c != 10))
  {
    puVar2 = fp->_p;
    fp->_p = puVar2 + 1;
    *puVar2 = (uchar)c;
    return c;
  }
  iVar1 = __swbuf_r(ptr,c,fp);
  return iVar1;
}



// WARNING: Unknown calling convention

int __sfputs_r(_reent_conflict *ptr,FILE *fp,char *buf,size_t len)
{
  int iVar1;
  byte *pbVar2;
  
  if (len == 0)
  {
    return 0;
  }
  pbVar2 = (byte *)(buf + -1);
  do
  {
    pbVar2 = pbVar2 + 1;
    iVar1 = __sfputc_r(ptr,(uint)*pbVar2,fp);
    if (iVar1 == -1)
    {
      return -1;
    }
  } while (pbVar2 != (byte *)(buf + (len - 1)));
  return 0;
}



// WARNING: Unknown calling convention

int __sprint_r(_reent_conflict *ptr,FILE *fp,__suio *uio)
{
  int iVar1;
  
  if (uio->uio_resid == 0)
  {
    uio->uio_iovcnt = 0;
    return 0;
  }
  iVar1 = __sfvwrite_r(ptr,fp,uio);
  uio->uio_iovcnt = 0;
  uio->uio_resid = 0;
  return iVar1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int _vfprintf_r(_reent_conflict *data,FILE *fp,char *fmt0,va_list ap)
{
  byte bVar1;
  ushort uVar2;
  int iVar3;
  void *pvVar4;
  _reent_conflict *p_Var5;
  uint __c;
  uint uVar6;
  byte *pbVar7;
  byte *pbVar8;
  byte *pbVar9;
  _reent_conflict *unaff_r9;
  size_t len;
  va_list ap_copy;
  _prt_data_t prt_data;
  
  if ((data != (_reent_conflict *)0x0) && (data->__sdidinit == 0))
  {
    __sinit(data);
  }
  if (fp == (FILE *)&__sf_fake_stdin)
  {
    fp = data->_stdin;
    uVar2 = fp->_flags;
  }
  else
  {
    if (fp == (FILE *)&__sf_fake_stdout)
    {
      fp = data->_stdout;
    }
    else if (fp == (FILE *)&__sf_fake_stderr)
    {
      fp = data->_stderr;
    }
    uVar2 = fp->_flags;
  }
  if (((-1 < (int)((uint)uVar2 << 0x1c)) || ((fp->_bf)._base == (uchar *)0x0)) &&
     (iVar3 = __swsetup_r(data,fp), iVar3 != 0))
  {
    return -1;
  }
  prt_data.zero = '0';
  bVar1 = *fmt0;
  prt_data.ret = 0;
  prt_data.blank = ' ';
  ap_copy.__ap = ap.__ap;
  while (bVar1 != 0)
  {
    pbVar7 = (byte *)fmt0;
    if (bVar1 != 0x25)
    {
      do
      {
        pbVar8 = pbVar7;
        pbVar7 = pbVar8 + 1;
        if (pbVar8[1] == 0)
        {
          len = (int)pbVar7 - (int)fmt0;
          if (len != 0) goto LAB_080008c4;
          goto LAB_080009b2;
        }
      } while (pbVar8[1] != 0x25);
      len = (int)pbVar7 - (int)fmt0;
      if (len != 0)
      {
LAB_080008c4:
        iVar3 = __sfputs_r(data,fp,fmt0,len);
        if ((iVar3 == -1) || (prt_data.ret += len, pbVar8[1] == 0)) break;
      }
    }
    prt_data.flags = 0;
    prt_data.dprec = 0;
    prt_data.width = 0;
    prt_data.l_buf[0] = '\0';
    prt_data.lead = 0;
    prt_data.prec = -1;
    pbVar7 = pbVar7 + 1;
    while( true )
    {
      pbVar8 = pbVar7 + 1;
      pvVar4 = memchr("#-0+ ",(uint)*pbVar7,5);
      if (pvVar4 == (void *)0x0) break;
      prt_data.flags = 1 << ((int)pvVar4 + 0xf7fc639cU & 0xff) | prt_data.flags;
      pbVar7 = pbVar8;
    }
    if (prt_data.flags << 0x1b < 0)
    {
      prt_data.l_buf[0] = ' ';
    }
    __c = (uint)*pbVar7;
    if (prt_data.flags << 0x1c < 0)
    {
      prt_data.l_buf[0] = '+';
    }
    if (__c == 0x2a)
    {
                    // WARNING: Load size is inaccurate
      prt_data.width = *ap_copy.__ap;
      ap_copy.__ap += 4;
      if (prt_data.width < 0)
      {
        prt_data.width = -prt_data.width;
        prt_data.flags |= 2;
      }
      __c = (uint)pbVar7[1];
      pbVar9 = pbVar7 + 2;
      pbVar7 = pbVar8;
LAB_0800094a:
      pbVar8 = pbVar7;
      fmt0 = (char *)pbVar9;
      if (__c != 0x2e) goto LAB_0800094e;
LAB_08000a36:
      __c = (uint)pbVar8[1];
      if (__c != 0x2a)
      {
        uVar6 = __c - 0x30;
        iVar3 = 0;
        prt_data.prec = 0;
        if (uVar6 < 10)
        {
          do
          {
            pbVar7 = pbVar9;
            __c = (uint)pbVar7[1];
            iVar3 = uVar6 + iVar3 * 10;
            uVar6 = __c - 0x30;
            pbVar8 = pbVar7 + 1;
            pbVar9 = pbVar8;
          } while (uVar6 < 10);
          fmt0 = (char *)(pbVar7 + 2);
          prt_data.prec = iVar3;
        }
        else
        {
          fmt0 = (char *)(pbVar9 + 1);
          pbVar8 = pbVar9;
        }
        goto LAB_0800094e;
      }
      __c = (uint)pbVar8[2];
                    // WARNING: Load size is inaccurate
      prt_data.prec = *ap_copy.__ap;
      ap_copy.__ap += 4;
      fmt0 = (char *)(pbVar8 + 3);
      pbVar8 = pbVar8 + 2;
      if (prt_data.prec < 0)
      {
        prt_data.prec = -1;
        goto LAB_0800094e;
      }
      pvVar4 = memchr(&DAT_08039c6c,__c,3);
    }
    else
    {
      uVar6 = __c - 0x30;
      pbVar9 = pbVar8;
      if (9 < uVar6) goto LAB_0800094a;
      while( true )
      {
        __c = (uint)*pbVar8;
        prt_data.width = uVar6 + prt_data.width * 10;
        uVar6 = __c - 0x30;
        if (9 < uVar6) break;
        pbVar7 = pbVar8;
        pbVar8 = pbVar8 + 1;
      }
      pbVar9 = pbVar7 + 2;
      fmt0 = (char *)pbVar9;
      if (__c == 0x2e) goto LAB_08000a36;
LAB_0800094e:
      pvVar4 = memchr(&DAT_08039c6c,__c,3);
    }
    if (pvVar4 != (void *)0x0)
    {
      prt_data.flags |= 0x40 << ((int)pvVar4 + 0xf7fc6394U & 0xff);
      pbVar8 = (byte *)fmt0;
      fmt0 = (char *)((byte *)fmt0 + 1);
    }
    prt_data.code = *pbVar8;
    pvVar4 = memchr("efgEFG",(uint)(byte)prt_data.code,6);
    if (pvVar4 == (void *)0x0)
    {
      p_Var5 = (_reent_conflict *)_printf_i(data,&prt_data,fp,__sfputs_r,&ap_copy);
LAB_0800099c:
      unaff_r9 = p_Var5;
      if (p_Var5 == (_reent_conflict *)0xffffffff) break;
    }
    else
    {
      p_Var5 = data;
      if (false) goto LAB_0800099c;
      ap_copy.__ap = (void *)(((int)ap_copy.__ap + 7U & 0xfffffff8) + 8);
    }
    prt_data.ret = (int)&unaff_r9->_errno + prt_data.ret;
    bVar1 = *fmt0;
  }
LAB_080009b2:
  if (-1 < (int)((uint)(ushort)fp->_flags << 0x19))
  {
    return prt_data.ret;
  }
  return -1;
}



int vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)
{
  int iVar1;
  
  iVar1 = _vfprintf_r(_impure_ptr,(FILE *)__s,__format,(va_list)__arg);
  return iVar1;
}



// WARNING: Unknown calling convention

int _printf_common(_reent_conflict *data,_prt_data_t *pdata,int *realsz,FILE *fp,
                  _func_int__reent_ptr_FILE_ptr_char_ptr_size_t *pfunc)
{
  int iVar1;
  int iVar2;
  uint uVar3;
  size_t sVar4;
  uint uVar5;
  
  iVar2 = pdata->size;
  if (pdata->size < pdata->dprec)
  {
    iVar2 = pdata->dprec;
  }
  *realsz = iVar2;
  if (pdata->l_buf[0] != '\0')
  {
    *realsz = iVar2 + 1;
  }
  uVar3 = pdata->flags;
  if ((int)(uVar3 << 0x1a) < 0)
  {
    iVar2 = *realsz;
    *realsz = iVar2 + 2;
    uVar3 = pdata->flags;
    if ((uVar3 & 6) == 0)
    {
      iVar2 = pdata->width - (iVar2 + 2);
joined_r0x08000c3c:
      if (0 < iVar2)
      {
        iVar2 = 0;
        do
        {
          iVar1 = (*pfunc)(data,fp,&pdata->blank,1);
          iVar2 += 1;
          if (iVar1 == -1)
          {
            return -1;
          }
        } while (iVar2 < pdata->width - *realsz);
        uVar3 = pdata->flags;
      }
    }
    sVar4 = (size_t)(byte)pdata->l_buf[0];
    if (sVar4 != 0)
    {
      sVar4 = 1;
    }
    if ((int)(uVar3 << 0x1a) < 0)
    {
      pdata->l_buf[sVar4] = '0';
      pdata->l_buf[sVar4 + 1] = pdata->l_buf[2];
      sVar4 += 2;
    }
  }
  else
  {
    if ((uVar3 & 6) == 0)
    {
      iVar2 = pdata->width - *realsz;
      goto joined_r0x08000c3c;
    }
    sVar4 = (size_t)(byte)pdata->l_buf[0];
    if (sVar4 != 0)
    {
      sVar4 = 1;
    }
  }
  iVar2 = (*pfunc)(data,fp,pdata->l_buf,sVar4);
  if (iVar2 == -1)
  {
    return -1;
  }
  iVar1 = pdata->dprec;
  iVar2 = pdata->size;
  if ((pdata->flags & 6U) == 4)
  {
    uVar3 = pdata->width - *realsz;
    uVar5 = uVar3 & ~((int)uVar3 >> 0x1f);
    if (iVar1 <= iVar2)
    {
      if ((int)uVar3 < 1)
      {
        return 0;
      }
      goto LAB_08000be4;
    }
  }
  else
  {
    if (iVar1 <= iVar2)
    {
      return 0;
    }
    uVar5 = 0;
  }
  uVar5 += iVar1 - iVar2;
LAB_08000be4:
  iVar2 = 0;
  do
  {
    iVar1 = (*pfunc)(data,fp,&pdata->zero,1);
    iVar2 += 1;
    if (iVar1 == -1)
    {
      return -1;
    }
  } while (iVar2 < (int)uVar5);
  return 0;
}



// WARNING: Unknown calling convention

int _printf_i(_reent_conflict *data,_prt_data_t *pdata,FILE *fp,
             _func_int__reent_ptr_FILE_ptr_char_ptr_size_t *pfunc,va_list *ap)
{
  byte bVar1;
  int iVar2;
  void *pvVar3;
  uint uVar4;
  size_t __n;
  undefined4 uVar5;
  uint uVar6;
  int *piVar7;
  undefined4 *puVar8;
  uint *puVar9;
  int iVar10;
  char *pcVar11;
  char *__s;
  uint *puVar12;
  char *pcVar13;
  bool bVar14;
  int realsz;
  
  bVar1 = pdata->code;
  __s = pdata->l_buf;
  if (bVar1 == 0x6e)
  {
    puVar8 = (undefined4 *)ap->__ap;
    iVar10 = pdata->flags;
    iVar2 = pdata->ret;
    ap->__ap = puVar8 + 1;
    piVar7 = (int *)*puVar8;
    if ((iVar10 << 0x18 < 0) || (-1 < iVar10 << 0x19))
    {
      *piVar7 = iVar2;
    }
    else
    {
      *(short *)piVar7 = (short)iVar2;
    }
LAB_08000d52:
    pdata->size = 0;
    goto LAB_08000d58;
  }
  pcVar11 = __s;
  if (bVar1 < 0x6f)
  {
    if (bVar1 == 99)
    {
                    // WARNING: Load size is inaccurate
      uVar5 = *ap->__ap;
      ap->__ap = (undefined4 *)((int)ap->__ap + 4);
      __s = pdata->buf + 0x27;
      pdata->buf[0x27] = (char)uVar5;
      pdata->size = 1;
      goto LAB_08000e6e;
    }
    if (bVar1 < 100)
    {
      if (bVar1 == 0) goto LAB_08000d52;
      if (bVar1 == 0x58)
      {
        pdata->l_buf[2] = 'X';
        uVar4 = pdata->flags;
        pcVar13 = "0123456789ABCDEF";
        goto LAB_08000c80;
      }
LAB_08000e96:
      pdata->buf[0x27] = bVar1;
      pdata->size = 1;
      __s = pdata->buf + 0x27;
      goto LAB_08000e6e;
    }
    if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_08000e96;
    uVar4 = pdata->flags;
    puVar9 = (uint *)ap->__ap;
    if (((int)(uVar4 << 0x18) < 0) || (-1 < (int)(uVar4 << 0x19)))
    {
      uVar6 = *puVar9;
      ap->__ap = puVar9 + 1;
    }
    else
    {
      uVar6 = (uint)(short)*puVar9;
      ap->__ap = puVar9 + 1;
    }
    if (-1 < (int)uVar6)
    {
      pcVar13 = "0123456789ABCDEF";
      uVar4 = 10;
      goto LAB_08000ca6;
    }
    pdata->dprec = pdata->prec;
    pdata->l_buf[0] = '-';
    if (-1 < pdata->prec)
    {
      pdata->flags = uVar4 & 0xfffffffb;
    }
    pcVar13 = "0123456789ABCDEF";
    uVar4 = 10;
    uVar6 = -uVar6;
LAB_08000e0a:
    do
    {
      bVar14 = uVar4 <= uVar6;
      pcVar11 = pcVar11 + -1;
      *pcVar11 = pcVar13[uVar6 - uVar4 * (uVar6 / uVar4)];
      uVar6 = uVar6 / uVar4;
    } while (bVar14);
  }
  else
  {
    if (bVar1 == 0x73)
    {
      puVar8 = (undefined4 *)ap->__ap;
      __n = pdata->prec;
      ap->__ap = puVar8 + 1;
      __s = (char *)*puVar8;
      pvVar3 = memchr(__s,0,__n);
      if (pvVar3 == (void *)0x0)
      {
        iVar2 = pdata->prec;
      }
      else
      {
        iVar2 = (int)pvVar3 - (int)__s;
        pdata->prec = iVar2;
      }
      pdata->size = iVar2;
LAB_08000e6e:
      pdata->l_buf[0] = '\0';
      goto LAB_08000d58;
    }
    if (bVar1 < 0x74)
    {
      if (bVar1 == 0x6f) goto LAB_08000e76;
      if (bVar1 != 0x70) goto LAB_08000e96;
      pcVar13 = "0123456789abcdef";
      uVar4 = pdata->flags | 0x20;
      pdata->flags = uVar4;
      pdata->l_buf[2] = 'x';
LAB_08000c80:
                    // WARNING: Load size is inaccurate
      uVar6 = *ap->__ap;
      ap->__ap = (uint *)((int)ap->__ap + 4);
      if ((-1 < (int)(uVar4 << 0x18)) && ((int)(uVar4 << 0x19) < 0))
      {
        uVar6 &= 0xffff;
      }
      if ((int)(uVar4 << 0x1f) < 0)
      {
        pdata->flags = uVar4 | 0x20;
      }
      if (uVar6 == 0)
      {
        pdata->flags = pdata->flags & 0xffffffdf;
        uVar4 = 0x10;
      }
      else
      {
        uVar4 = 0x10;
      }
    }
    else
    {
      if (bVar1 != 0x75)
      {
        if (bVar1 != 0x78) goto LAB_08000e96;
        uVar4 = pdata->flags;
        pcVar13 = "0123456789abcdef";
        pdata->l_buf[2] = 'x';
        goto LAB_08000c80;
      }
LAB_08000e76:
      puVar9 = (uint *)ap->__ap;
      puVar12 = puVar9 + 1;
      if ((pdata->flags & 0x80U) == 0)
      {
        if ((pdata->flags & 0x40U) == 0)
        {
          uVar6 = *puVar9;
          ap->__ap = puVar12;
        }
        else
        {
          ap->__ap = puVar12;
          uVar6 = (uint)(ushort)*puVar9;
        }
      }
      else
      {
        uVar6 = *puVar9;
        ap->__ap = puVar12;
      }
      if (bVar1 == 0x6f)
      {
        uVar4 = 8;
      }
      else
      {
        uVar4 = 10;
      }
      pcVar13 = "0123456789ABCDEF";
    }
    pdata->l_buf[0] = '\0';
LAB_08000ca6:
    iVar2 = pdata->prec;
    pdata->dprec = iVar2;
    if (iVar2 < 0)
    {
      if (uVar6 != 0) goto LAB_08000e0a;
LAB_08000e44:
      pdata->buf[0x27] = *pcVar13;
      pcVar11 = pdata->buf + 0x27;
    }
    else
    {
      pdata->flags = pdata->flags & 0xfffffffb;
      if (uVar6 != 0) goto LAB_08000e0a;
      if (iVar2 != 0) goto LAB_08000e44;
    }
  }
  if (((uVar4 == 8) && (pdata->flags << 0x1f < 0)) && (pdata->prec <= pdata->size))
  {
    pcVar11[-1] = '0';
    pcVar11 = pcVar11 + -1;
  }
  pdata->size = (int)__s - (int)pcVar11;
  __s = pcVar11;
LAB_08000d58:
  iVar2 = _printf_common(data,pdata,&realsz,fp,pfunc);
  if ((iVar2 != -1) && (iVar2 = (*pfunc)(data,fp,__s,pdata->size), iVar2 != -1))
  {
    iVar2 = pdata->width;
    if ((pdata->flags << 0x1e < 0) && (0 < iVar2 - realsz))
    {
      iVar10 = 0;
      do
      {
        iVar2 = (*pfunc)(data,fp,&pdata->blank,1);
        iVar10 += 1;
        if (iVar2 == -1)
        {
          return -1;
        }
        iVar2 = pdata->width;
      } while (iVar10 < iVar2 - realsz);
    }
    if (realsz < iVar2)
    {
      realsz = iVar2;
    }
    return realsz;
  }
  return -1;
}



int _printf_r(_reent_conflict *ptr,char *fmt,...)
{
  int iVar1;
  undefined4 in_r2;
  undefined4 in_r3;
  va_list ap;
  char *fmt_local;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  uStack_8 = in_r2;
  uStack_4 = in_r3;
  if ((ptr != (_reent_conflict *)0x0) && (ptr->__sdidinit == 0))
  {
    __sinit(ptr);
  }
  iVar1 = _vfprintf_r(ptr,ptr->_stdout,fmt,(va_list)&uStack_8);
  return iVar1;
}



int printf(char *__format,...)
{
  _reent_conflict *data;
  int iVar1;
  undefined4 in_r1;
  undefined4 in_r2;
  undefined4 in_r3;
  va_list ap;
  char *fmt_local;
  undefined4 uStack_c;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  data = _impure_ptr;
  uStack_c = in_r1;
  uStack_8 = in_r2;
  uStack_4 = in_r3;
  if ((_impure_ptr != (_reent_conflict *)0x0) && (_impure_ptr->__sdidinit == 0))
  {
    __sinit(_impure_ptr);
  }
  iVar1 = _vfprintf_r(data,data->_stdout,__format,(va_list)&uStack_c);
  return iVar1;
}



// WARNING: Unknown calling convention

int _puts_r(_reent_conflict *ptr,char *s)
{
  ushort uVar1;
  byte bVar2;
  int iVar3;
  byte *pbVar4;
  uchar *puVar5;
  FILE *fp;
  uint c;
  byte *pbVar6;
  
  if (ptr->__sdidinit == 0)
  {
    __sinit(ptr);
    fp = ptr->_stdout;
    if (ptr->__sdidinit != 0) goto LAB_08000f52;
    __sinit(ptr);
    if (fp != (FILE *)&__sf_fake_stdin) goto LAB_08000f58;
  }
  else
  {
    fp = ptr->_stdout;
LAB_08000f52:
    if (fp != (FILE *)&__sf_fake_stdin)
    {
LAB_08000f58:
      if (fp == (FILE *)&__sf_fake_stdout)
      {
        fp = ptr->_stdout;
      }
      else if (fp == (FILE *)&__sf_fake_stderr)
      {
        fp = ptr->_stderr;
      }
      uVar1 = fp->_flags;
      goto joined_r0x08000fc2;
    }
  }
  fp = ptr->_stdin;
  uVar1 = fp->_flags;
joined_r0x08000fc2:
  if (((-1 < (int)((uint)uVar1 << 0x1c)) || ((fp->_bf)._base == (uchar *)0x0)) &&
     (iVar3 = __swsetup_r(ptr,fp), iVar3 != 0))
  {
    return -1;
  }
  pbVar6 = (byte *)(s + -1);
  while( true )
  {
    pbVar6 = pbVar6 + 1;
    bVar2 = *pbVar6;
    c = (uint)bVar2;
    iVar3 = fp->_w + -1;
    fp->_w = iVar3;
    if (c == 0) break;
    if ((iVar3 < 0) && ((iVar3 < fp->_lbfsize || (c == 10))))
    {
      iVar3 = __swbuf_r(ptr,c,fp);
      if (iVar3 == -1)
      {
        return -1;
      }
    }
    else
    {
      pbVar4 = fp->_p;
      fp->_p = pbVar4 + 1;
      *pbVar4 = bVar2;
    }
  }
  if (-1 < iVar3)
  {
    puVar5 = fp->_p;
    fp->_p = puVar5 + 1;
    *puVar5 = '\n';
    return 10;
  }
  iVar3 = __swbuf_r(ptr,10,fp);
  if (iVar3 != -1)
  {
    return 10;
  }
  return -1;
}



int puts(char *__s)
{
  int iVar1;
  
  iVar1 = _puts_r(_impure_ptr,__s);
  return iVar1;
}



void srand(uint __seed)
{
  _reent_conflict *p_Var1;
  _rand48_conflict *p_Var2;
  
  p_Var1 = _impure_ptr;
  p_Var2 = _impure_ptr->_r48;
  if (p_Var2 != (_rand48_conflict *)0x0)
  {
    *(uint *)&p_Var2->_rand_next = __seed;
    *(undefined4 *)((int)&p_Var2->_rand_next + 4) = 0;
    return;
  }
  p_Var2 = (_rand48_conflict *)malloc(0x18);
  p_Var1->_r48 = p_Var2;
  if (p_Var2 != (_rand48_conflict *)0x0)
  {
    p_Var2->_seed[0] = 0x330e;
    p_Var2->_seed[1] = 0xabcd;
    *(undefined4 *)&p_Var2->_rand_next = 1;
    *(undefined4 *)((int)&p_Var2->_rand_next + 4) = 0;
    p_Var2->_add = 0xb;
    *(undefined4 *)(p_Var2->_seed + 2) = 0xe66d1234;
    p_Var2->_mult[1] = 0xdeec;
    p_Var2->_mult[2] = 5;
    *(uint *)&p_Var2->_rand_next = __seed;
    *(undefined4 *)((int)&p_Var2->_rand_next + 4) = 0;
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_func("../../../../../../../../newlib/libc/stdlib/rand.c",0x42,(char *)0x0,
                "REENT malloc succeeded");
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand(void)
{
  longlong lVar1;
  _reent_conflict *p_Var2;
  _rand48_conflict *p_Var3;
  uint uVar4;
  uint uVar5;
  
  p_Var2 = _impure_ptr;
  p_Var3 = _impure_ptr->_r48;
  if (p_Var3 != (_rand48_conflict *)0x0)
  {
    uVar4 = (uint)p_Var3->_rand_next;
    lVar1 = (ulonglong)uVar4 * 0x4c957f2d;
    uVar5 = (uint)lVar1;
    uVar4 = (int)((ulonglong)lVar1 >> 0x20) +
            *(int *)((int)&p_Var3->_rand_next + 4) * 0x4c957f2d + uVar4 * 0x5851f42d +
            (uint)(0xfffffffe < uVar5);
    *(uint *)&p_Var3->_rand_next = uVar5 + 1;
    *(uint *)((int)&p_Var3->_rand_next + 4) = uVar4;
    return uVar4 & 0x7fffffff;
  }
  p_Var3 = (_rand48_conflict *)malloc(0x18);
  p_Var2->_r48 = p_Var3;
  if (p_Var3 != (_rand48_conflict *)0x0)
  {
    *(undefined4 *)&p_Var3->_rand_next = 1;
    *(undefined4 *)((int)&p_Var3->_rand_next + 4) = 0;
    p_Var3->_seed[0] = 0x330e;
    p_Var3->_seed[1] = 0xabcd;
    *(undefined4 *)(p_Var3->_seed + 2) = 0xe66d1234;
    p_Var3->_mult[1] = 0xdeec;
    p_Var3->_mult[2] = 5;
    p_Var3->_add = 0xb;
    *(undefined4 *)&p_Var3->_rand_next = 0x4c957f2e;
    *(undefined4 *)((int)&p_Var3->_rand_next + 4) = 0x5851f42d;
    return 0x5851f42d;
  }
                    // WARNING: Subroutine does not return
  __assert_func("../../../../../../../../newlib/libc/stdlib/rand.c",0x4e,(char *)0x0,
                "REENT malloc succeeded");
}



// WARNING: Unknown calling convention

void * _sbrk_r(_reent_conflict *ptr,ptrdiff_t incr)
{
  void *pvVar1;
  
  errno = 0;
  pvVar1 = _sbrk(incr);
  if ((pvVar1 == (void *)0xffffffff) && (errno != 0))
  {
    ptr->_errno = errno;
    return (void *)0xffffffff;
  }
  return pvVar1;
}



// WARNING: Variable defined which should be unmapped: ap

int _snprintf_r(_reent_conflict *ptr,char *str,size_t size,char *fmt,...)
{
  int iVar1;
  va_list ap;
  FILE f;
  char *fmt_local;
  
  if ((int)size < 0)
  {
    ptr->_errno = 0x8b;
    iVar1 = -1;
  }
  else
  {
    f._flags = 0x208;
    f._p = (uchar *)str;
    f._bf._base = (uchar *)str;
    if (size != 0)
    {
      f._w = size - 1;
      f._file = -1;
      f._bf._size = f._w;
      iVar1 = _svfprintf_r(ptr,&f,fmt,(va_list)&stack0x00000000);
      if (iVar1 + 1 < 0 != SCARRY4(iVar1,1))
      {
        ptr->_errno = 0x8b;
      }
      *f._p = '\0';
      return iVar1;
    }
    f._file = -1;
    f._w = size;
    f._bf._size = size;
    iVar1 = _svfprintf_r(ptr,&f,fmt,(va_list)&stack0x00000000);
    if (iVar1 + 1 < 0 != SCARRY4(iVar1,1))
    {
      ptr->_errno = 0x8b;
    }
  }
  return iVar1;
}



int snprintf(char *__s,size_t __maxlen,char *__format,...)
{
  _reent_conflict *p_Var1;
  int iVar2;
  undefined4 in_r3;
  va_list ap;
  FILE f;
  char *fmt_local;
  undefined4 uStack_4;
  
  p_Var1 = _impure_ptr;
  if ((int)__maxlen < 0)
  {
    _impure_ptr->_errno = 0x8b;
    iVar2 = -1;
  }
  else
  {
    f._flags = 0x208;
    f._p = (uchar *)__s;
    f._bf._base = (uchar *)__s;
    uStack_4 = in_r3;
    if (__maxlen != 0)
    {
      f._w = __maxlen - 1;
      f._file = -1;
      f._bf._size = f._w;
      iVar2 = _svfprintf_r(_impure_ptr,&f,__format,(va_list)&uStack_4);
      if (iVar2 + 1 < 0 != SCARRY4(iVar2,1))
      {
        p_Var1->_errno = 0x8b;
      }
      *f._p = '\0';
      return iVar2;
    }
    f._file = -1;
    f._w = __maxlen;
    f._bf._size = __maxlen;
    iVar2 = _svfprintf_r(_impure_ptr,&f,__format,(va_list)&uStack_4);
    if (iVar2 + 1 < 0 != SCARRY4(iVar2,1))
    {
      p_Var1->_errno = 0x8b;
    }
  }
  return iVar2;
}



int _sprintf_r(_reent_conflict *ptr,char *str,char *fmt,...)
{
  int iVar1;
  undefined4 in_r3;
  va_list ap;
  FILE f;
  char *fmt_local;
  undefined4 uStack_4;
  
  f._bf._size = 0x7fffffff;
  f._w = 0x7fffffff;
  f._flags = 0x208;
  f._file = -1;
  f._p = (uchar *)str;
  f._bf._base = (uchar *)str;
  uStack_4 = in_r3;
  iVar1 = _svfprintf_r(ptr,&f,fmt,(va_list)&uStack_4);
  *f._p = '\0';
  return iVar1;
}



int sprintf(char *__s,char *__format,...)
{
  int iVar1;
  undefined4 in_r2;
  undefined4 in_r3;
  va_list ap;
  FILE f;
  char *fmt_local;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  f._bf._size = 0x7fffffff;
  f._w = 0x7fffffff;
  f._flags = 0x208;
  f._file = -1;
  f._p = (uchar *)__s;
  f._bf._base = (uchar *)__s;
  uStack_8 = in_r2;
  uStack_4 = in_r3;
  iVar1 = _svfprintf_r(_impure_ptr,&f,__format,(va_list)&uStack_8);
  *f._p = '\0';
  return iVar1;
}



int strcmp(char *__s1,char *__s2)
{
  uint *puVar1;
  uint *puVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  char cVar9;
  short sVar10;
  int3 iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  bool bVar15;
  bool bVar16;
  bool bVar17;
  bool bVar18;
  
  uVar5 = (uint)(byte)*__s1;
  bVar15 = uVar5 == 1;
  if (uVar5 != 0)
  {
    bVar15 = uVar5 == (byte)*__s2;
  }
  if (!bVar15)
  {
    return uVar5 - (byte)*__s2;
  }
  if ((((uint)__s1 | (uint)__s2) & 7) == 0) goto LAB_08001350;
  if ((((uint)__s1 ^ (uint)__s2) & 7) == 0)
  {
    puVar1 = (uint *)((uint)__s1 & 0xfffffff8);
    puVar2 = (uint *)((uint)__s2 & 0xfffffff8);
    puVar4 = puVar1 + 4;
    uVar6 = puVar1[1];
    puVar3 = puVar2 + 4;
    uVar14 = puVar2[1];
    uVar7 = -1 << (((uint)__s1 & 3) << 3);
    uVar5 = *puVar1 | ~uVar7;
    uVar13 = *puVar2 | ~uVar7;
    if (((uint)__s1 & 4) != 0)
    {
      uVar6 |= ~uVar7;
      uVar14 |= ~uVar7;
      uVar5 = 0xffffffff;
      uVar13 = 0xffffffff;
    }
    do
    {
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      bVar18 = (char)(uVar5 >> 0x18) != '\0';
      uVar7 = uVar5 ^ uVar13;
      uVar7 = CONCAT13(bVar18 * (char)(uVar7 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar7 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar7 >> 8) - !bVar16,
                                         bVar15 * (char)uVar7 - !bVar15)));
      if (uVar7 != 0)
      {
LAB_080013c2:
        uVar6 = LZCOUNT(uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 | (uVar7 >> 0x10 & 0xff) << 8 |
                        uVar7 >> 0x18) & 0xfffffff8;
        return (uVar5 >> uVar6 & 0xff) - (uVar13 >> uVar6 & 0xff);
      }
      bVar15 = (char)uVar6 != '\0';
      bVar16 = (char)(uVar6 >> 8) != '\0';
      bVar17 = (char)(uVar6 >> 0x10) != '\0';
      bVar18 = (char)(uVar6 >> 0x18) != '\0';
      uVar5 = uVar6 ^ uVar14;
      uVar12 = CONCAT13(bVar18 * (char)(uVar5 >> 0x18) - !bVar18,
                        CONCAT12(bVar17 * (char)(uVar5 >> 0x10) - !bVar17,
                                 CONCAT11(bVar16 * (char)(uVar5 >> 8) - !bVar16,
                                          bVar15 * (char)uVar5 - !bVar15)));
      if (uVar12 != 0)
      {
LAB_0800139a:
        uVar5 = LZCOUNT(uVar12 << 0x18 | (uVar12 >> 8 & 0xff) << 0x10 | (uVar12 >> 0x10 & 0xff) << 8
                        | uVar12 >> 0x18) & 0xfffffff8;
        return (uVar6 >> uVar5 & 0xff) - (uVar14 >> uVar5 & 0xff);
      }
      uVar5 = puVar4[-2];
      uVar6 = puVar4[-1];
      uVar13 = puVar3[-2];
      uVar14 = puVar3[-1];
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      bVar18 = (char)(uVar5 >> 0x18) != '\0';
      uVar7 = uVar5 ^ uVar13;
      uVar7 = CONCAT13(bVar18 * (char)(uVar7 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar7 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar7 >> 8) - !bVar16,
                                         bVar15 * (char)uVar7 - !bVar15)));
      bVar15 = (char)uVar6 != '\0';
      bVar16 = (char)(uVar6 >> 8) != '\0';
      bVar17 = (char)(uVar6 >> 0x10) != '\0';
      bVar18 = (char)(uVar6 >> 0x18) != '\0';
      uVar12 = uVar6 ^ uVar14;
      uVar12 = CONCAT13(bVar18 * (char)(uVar12 >> 0x18) - !bVar18,
                        CONCAT12(bVar17 * (char)(uVar12 >> 0x10) - !bVar17,
                                 CONCAT11(bVar16 * (char)(uVar12 >> 8) - !bVar16,
                                          bVar15 * (char)uVar12 - !bVar15))) | uVar7;
      __s1 = (char *)puVar4;
      __s2 = (char *)puVar3;
      if (uVar12 != 0)
      {
        if (uVar7 == 0) goto LAB_0800139a;
        goto LAB_080013c2;
      }
LAB_08001350:
      puVar4 = (uint *)((int)__s1 + 0x10);
      uVar5 = *(uint *)__s1;
      uVar6 = *(uint *)((int)__s1 + 4);
      puVar3 = (uint *)((int)__s2 + 0x10);
      uVar13 = *(uint *)__s2;
      uVar14 = *(uint *)((int)__s2 + 4);
    } while( true );
  }
  if ((((uint)__s1 ^ (uint)__s2) & 3) == 0)
  {
    if (((uint)__s1 & 3) != 0)
    {
      puVar1 = (uint *)((uint)__s1 & 0xfffffffc);
      puVar4 = (uint *)((uint)__s2 & 0xfffffffc);
      uVar13 = -1 << (((uint)__s1 & 3) << 3);
      uVar5 = *puVar1 | ~uVar13;
      uVar13 = *puVar4 | ~uVar13;
      goto LAB_080013fe;
    }
    do
    {
      uVar5 = *(uint *)__s1;
      uVar13 = *(uint *)__s2;
      puVar1 = (uint *)__s1;
      puVar4 = (uint *)__s2;
LAB_080013fe:
      __s2 = (char *)(puVar4 + 2);
      __s1 = (char *)(puVar1 + 2);
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      bVar18 = (char)(uVar5 >> 0x18) != '\0';
      uVar6 = uVar5 ^ uVar13;
      uVar6 = CONCAT13(bVar18 * (char)(uVar6 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar6 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar6 >> 8) - !bVar16,
                                         bVar15 * (char)uVar6 - !bVar15)));
      if (uVar6 != 0) break;
      uVar5 = puVar1[1];
      uVar13 = puVar4[1];
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      bVar18 = (char)(uVar5 >> 0x18) != '\0';
      uVar6 = uVar5 ^ uVar13;
      uVar6 = CONCAT13(bVar18 * (char)(uVar6 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar6 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar6 >> 8) - !bVar16,
                                         bVar15 * (char)uVar6 - !bVar15)));
    } while (uVar6 == 0);
    uVar6 = LZCOUNT(uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 | (uVar6 >> 0x10 & 0xff) << 8 |
                    uVar6 >> 0x18) & 0xfffffff8;
    return (uVar5 >> uVar6 & 0xff) - (uVar13 >> uVar6 & 0xff);
  }
  uVar5 = (uint)__s1 & 3;
  if (uVar5 == 0) goto LAB_080014a6;
  puVar1 = (uint *)((uint)__s1 & 0xfffffffc);
  uVar6 = (uint)__s1 & 2;
  uVar13 = (uint)__s1 & 1;
  __s1 = (char *)(puVar1 + 1);
  uVar7 = *puVar1;
  if (uVar13 == 0)
  {
LAB_0800148e:
    iVar8 = (uVar7 >> 0x18) - (uint)(byte)__s2[3 - uVar5];
    if ((iVar8 != 0) || ((byte)__s2[3 - uVar5] == 0))
    {
      return iVar8;
    }
  }
  else if (uVar6 == 0)
  {
    iVar8 = (uVar7 >> 0x10 & 0xff) - (uint)(byte)__s2[2 - uVar5];
    if (iVar8 != 0)
    {
      return iVar8;
    }
    if ((byte)__s2[2 - uVar5] == 0)
    {
      return 0;
    }
    goto LAB_0800148e;
  }
  __s2 = __s2 + (4 - uVar5);
LAB_080014a6:
  puVar1 = (uint *)((int)__s1 + 4);
  uVar5 = *(uint *)__s1;
  bVar15 = ((uint)__s2 & 2) != 0;
  puVar4 = (uint *)((uint)__s2 & 0xfffffffc) + 1;
  uVar13 = *(uint *)((uint)__s2 & 0xfffffffc);
  if (bVar15 && ((uint)__s2 & 1) != 0)
  {
    while( true )
    {
      bVar15 = (char)uVar5 != '\0';
      uVar6 = uVar5 & 0xff ^ uVar13 >> 0x18;
      cVar9 = bVar15 * (char)uVar6 - !bVar15;
      if (uVar6 != 0) break;
      if (CONCAT13(-((char)(uVar5 >> 0x18) == '\0'),
                   CONCAT12(-((char)(uVar5 >> 0x10) == '\0'),
                            CONCAT11(-((char)(uVar5 >> 8) == '\0'),cVar9))) != 0)
      {
        if (cVar9 != '\0')
        {
          return 0;
        }
        uVar13 = *puVar4;
LAB_0800157e:
        uVar5 >>= 8;
        uVar13 &= 0xffffff;
        goto LAB_08001592;
      }
      uVar13 = *puVar4;
      if ((uVar5 & 0xff ^ uVar5) != uVar13 * 0x100) goto LAB_0800157e;
      uVar5 = *puVar1;
      puVar1 = puVar1 + 1;
      puVar4 = puVar4 + 1;
    }
    uVar13 >>= 0x18;
  }
  else if (bVar15)
  {
    while( true )
    {
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      uVar6 = uVar5 & 0xffff ^ uVar13 >> 0x10;
      sVar10 = CONCAT11(bVar16 * (char)(uVar6 >> 8) - !bVar16,bVar15 * (char)uVar6 - !bVar15);
      if (uVar6 != 0) break;
      if (CONCAT13(-((char)(uVar5 >> 0x18) == '\0'),
                   CONCAT12(-((char)(uVar5 >> 0x10) == '\0'),sVar10)) != 0)
      {
        if (sVar10 != 0)
        {
          return 0;
        }
        uVar13 = (uint)(ushort)*puVar4;
        uVar5 >>= 0x10;
        goto LAB_08001592;
      }
      uVar13 = *puVar4;
      if ((uVar5 & 0xffff ^ uVar5) != uVar13 * 0x10000)
      {
        uVar5 >>= 0x10;
        uVar13 &= 0xffff;
        goto LAB_08001592;
      }
      uVar5 = *puVar1;
      puVar1 = puVar1 + 1;
      puVar4 = puVar4 + 1;
    }
    uVar13 >>= 0x10;
  }
  else
  {
    while( true )
    {
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      uVar6 = uVar5 & 0xffffff ^ uVar13 >> 8;
      iVar11 = CONCAT12(bVar17 * (char)(uVar6 >> 0x10) - !bVar17,
                        CONCAT11(bVar16 * (char)(uVar6 >> 8) - !bVar16,
                                 bVar15 * (char)uVar6 - !bVar15));
      if (uVar6 != 0) break;
      if (CONCAT13(-((char)(uVar5 >> 0x18) == '\0'),iVar11) != 0)
      {
        if (iVar11 != 0)
        {
          return 0;
        }
        return -(uint)(byte)*puVar4;
      }
      uVar13 = *puVar4;
      if ((uVar5 & 0xffffff ^ uVar5) != uVar13 * 0x1000000)
      {
        uVar5 >>= 0x18;
        uVar13 &= 0xff;
        goto LAB_08001592;
      }
      uVar5 = *puVar1;
      puVar1 = puVar1 + 1;
      puVar4 = puVar4 + 1;
    }
    uVar13 >>= 8;
  }
LAB_08001592:
  uVar6 = uVar5 << 0x18 | (uVar5 >> 8 & 0xff) << 0x10 | (uVar5 >> 0x10 & 0xff) << 8 | uVar5 >> 0x18;
  uVar13 = uVar13 << 0x18 | (uVar13 >> 8 & 0xff) << 0x10 | (uVar13 >> 0x10) << 8;
  cVar9 = (char)(uVar5 >> 0x18);
  bVar15 = (char)(uVar5 >> 0x10) != '\0';
  bVar16 = (char)(uVar5 >> 8) != '\0';
  bVar17 = (char)uVar5 != '\0';
  uVar5 = uVar6 ^ uVar13;
  iVar8 = LZCOUNT(CONCAT13(bVar17 * (char)(uVar5 >> 0x18) - !bVar17,
                           CONCAT12(bVar16 * (char)(uVar5 >> 0x10) - !bVar16,
                                    CONCAT11(bVar15 * (char)(uVar5 >> 8) - !bVar15,
                                             (cVar9 != '\0') * cVar9 - (cVar9 == '\0')))));
  return ((uVar6 << iVar8) >> 0x18) - ((uVar13 << iVar8) >> 0x18);
}



int FUN_080012f4(uint *param_1,uint *param_2)
{
  uint *puVar1;
  uint *puVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  char cVar8;
  short sVar9;
  int3 iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  bool bVar15;
  bool bVar16;
  bool bVar17;
  bool bVar18;
  
  if ((((uint)param_1 | (uint)param_2) & 7) == 0) goto LAB_08001350;
  if ((((uint)param_1 ^ (uint)param_2) & 7) == 0)
  {
    puVar1 = (uint *)((uint)param_1 & 0xfffffff8);
    puVar2 = (uint *)((uint)param_2 & 0xfffffff8);
    puVar4 = puVar1 + 4;
    uVar5 = puVar1[1];
    puVar3 = puVar2 + 4;
    uVar14 = puVar2[1];
    uVar6 = -1 << (((uint)param_1 & 3) << 3);
    uVar11 = *puVar1 | ~uVar6;
    uVar13 = *puVar2 | ~uVar6;
    if (((uint)param_1 & 4) != 0)
    {
      uVar5 |= ~uVar6;
      uVar14 |= ~uVar6;
      uVar11 = 0xffffffff;
      uVar13 = 0xffffffff;
    }
    do
    {
      bVar15 = (char)uVar11 != '\0';
      bVar16 = (char)(uVar11 >> 8) != '\0';
      bVar17 = (char)(uVar11 >> 0x10) != '\0';
      bVar18 = (char)(uVar11 >> 0x18) != '\0';
      uVar6 = uVar11 ^ uVar13;
      uVar6 = CONCAT13(bVar18 * (char)(uVar6 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar6 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar6 >> 8) - !bVar16,
                                         bVar15 * (char)uVar6 - !bVar15)));
      if (uVar6 != 0)
      {
LAB_080013c2:
        uVar5 = LZCOUNT(uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 | (uVar6 >> 0x10 & 0xff) << 8 |
                        uVar6 >> 0x18) & 0xfffffff8;
        return (uVar11 >> uVar5 & 0xff) - (uVar13 >> uVar5 & 0xff);
      }
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      bVar18 = (char)(uVar5 >> 0x18) != '\0';
      uVar11 = uVar5 ^ uVar14;
      uVar12 = CONCAT13(bVar18 * (char)(uVar11 >> 0x18) - !bVar18,
                        CONCAT12(bVar17 * (char)(uVar11 >> 0x10) - !bVar17,
                                 CONCAT11(bVar16 * (char)(uVar11 >> 8) - !bVar16,
                                          bVar15 * (char)uVar11 - !bVar15)));
      if (uVar12 != 0)
      {
LAB_0800139a:
        uVar11 = LZCOUNT(uVar12 << 0x18 | (uVar12 >> 8 & 0xff) << 0x10 |
                         (uVar12 >> 0x10 & 0xff) << 8 | uVar12 >> 0x18) & 0xfffffff8;
        return (uVar5 >> uVar11 & 0xff) - (uVar14 >> uVar11 & 0xff);
      }
      uVar11 = puVar4[-2];
      uVar5 = puVar4[-1];
      uVar13 = puVar3[-2];
      uVar14 = puVar3[-1];
      bVar15 = (char)uVar11 != '\0';
      bVar16 = (char)(uVar11 >> 8) != '\0';
      bVar17 = (char)(uVar11 >> 0x10) != '\0';
      bVar18 = (char)(uVar11 >> 0x18) != '\0';
      uVar6 = uVar11 ^ uVar13;
      uVar6 = CONCAT13(bVar18 * (char)(uVar6 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar6 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar6 >> 8) - !bVar16,
                                         bVar15 * (char)uVar6 - !bVar15)));
      bVar15 = (char)uVar5 != '\0';
      bVar16 = (char)(uVar5 >> 8) != '\0';
      bVar17 = (char)(uVar5 >> 0x10) != '\0';
      bVar18 = (char)(uVar5 >> 0x18) != '\0';
      uVar12 = uVar5 ^ uVar14;
      uVar12 = CONCAT13(bVar18 * (char)(uVar12 >> 0x18) - !bVar18,
                        CONCAT12(bVar17 * (char)(uVar12 >> 0x10) - !bVar17,
                                 CONCAT11(bVar16 * (char)(uVar12 >> 8) - !bVar16,
                                          bVar15 * (char)uVar12 - !bVar15))) | uVar6;
      param_1 = puVar4;
      param_2 = puVar3;
      if (uVar12 != 0)
      {
        if (uVar6 == 0) goto LAB_0800139a;
        goto LAB_080013c2;
      }
LAB_08001350:
      puVar4 = param_1 + 4;
      uVar11 = *param_1;
      uVar5 = param_1[1];
      puVar3 = param_2 + 4;
      uVar13 = *param_2;
      uVar14 = param_2[1];
    } while( true );
  }
  if ((((uint)param_1 ^ (uint)param_2) & 3) == 0)
  {
    if (((uint)param_1 & 3) != 0)
    {
      puVar1 = (uint *)((uint)param_1 & 0xfffffffc);
      puVar4 = (uint *)((uint)param_2 & 0xfffffffc);
      uVar13 = -1 << (((uint)param_1 & 3) << 3);
      uVar11 = *puVar1 | ~uVar13;
      uVar13 = *puVar4 | ~uVar13;
      goto LAB_080013fe;
    }
    do
    {
      uVar11 = *param_1;
      uVar13 = *param_2;
      puVar1 = param_1;
      puVar4 = param_2;
LAB_080013fe:
      param_2 = puVar4 + 2;
      param_1 = puVar1 + 2;
      bVar15 = (char)uVar11 != '\0';
      bVar16 = (char)(uVar11 >> 8) != '\0';
      bVar17 = (char)(uVar11 >> 0x10) != '\0';
      bVar18 = (char)(uVar11 >> 0x18) != '\0';
      uVar5 = uVar11 ^ uVar13;
      uVar5 = CONCAT13(bVar18 * (char)(uVar5 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar5 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar5 >> 8) - !bVar16,
                                         bVar15 * (char)uVar5 - !bVar15)));
      if (uVar5 != 0) break;
      uVar11 = puVar1[1];
      uVar13 = puVar4[1];
      bVar15 = (char)uVar11 != '\0';
      bVar16 = (char)(uVar11 >> 8) != '\0';
      bVar17 = (char)(uVar11 >> 0x10) != '\0';
      bVar18 = (char)(uVar11 >> 0x18) != '\0';
      uVar5 = uVar11 ^ uVar13;
      uVar5 = CONCAT13(bVar18 * (char)(uVar5 >> 0x18) - !bVar18,
                       CONCAT12(bVar17 * (char)(uVar5 >> 0x10) - !bVar17,
                                CONCAT11(bVar16 * (char)(uVar5 >> 8) - !bVar16,
                                         bVar15 * (char)uVar5 - !bVar15)));
    } while (uVar5 == 0);
    uVar5 = LZCOUNT(uVar5 << 0x18 | (uVar5 >> 8 & 0xff) << 0x10 | (uVar5 >> 0x10 & 0xff) << 8 |
                    uVar5 >> 0x18) & 0xfffffff8;
    return (uVar11 >> uVar5 & 0xff) - (uVar13 >> uVar5 & 0xff);
  }
  uVar11 = (uint)param_1 & 3;
  if (uVar11 == 0) goto LAB_080014a6;
  puVar1 = (uint *)((uint)param_1 & 0xfffffffc);
  uVar5 = (uint)param_1 & 2;
  uVar13 = (uint)param_1 & 1;
  param_1 = puVar1 + 1;
  uVar6 = *puVar1;
  if (uVar13 == 0)
  {
LAB_0800148e:
    uVar13 = (uint)*(byte *)((int)param_2 + (3 - uVar11));
    iVar7 = (uVar6 >> 0x18) - uVar13;
    if ((iVar7 != 0) || (uVar13 == 0))
    {
      return iVar7;
    }
  }
  else if (uVar5 == 0)
  {
    uVar13 = (uint)*(byte *)((int)param_2 + (2 - uVar11));
    iVar7 = (uVar6 >> 0x10 & 0xff) - uVar13;
    if (iVar7 != 0)
    {
      return iVar7;
    }
    if (uVar13 == 0)
    {
      return 0;
    }
    goto LAB_0800148e;
  }
  param_2 = (uint *)((int)param_2 + (4 - uVar11));
LAB_080014a6:
  puVar1 = param_1 + 1;
  uVar11 = *param_1;
  bVar15 = ((uint)param_2 & 2) != 0;
  puVar4 = (uint *)((uint)param_2 & 0xfffffffc) + 1;
  uVar13 = *(uint *)((uint)param_2 & 0xfffffffc);
  if (bVar15 && ((uint)param_2 & 1) != 0)
  {
    while( true )
    {
      bVar15 = (char)uVar11 != '\0';
      uVar5 = uVar11 & 0xff ^ uVar13 >> 0x18;
      cVar8 = bVar15 * (char)uVar5 - !bVar15;
      if (uVar5 != 0) break;
      if (CONCAT13(-((char)(uVar11 >> 0x18) == '\0'),
                   CONCAT12(-((char)(uVar11 >> 0x10) == '\0'),
                            CONCAT11(-((char)(uVar11 >> 8) == '\0'),cVar8))) != 0)
      {
        if (cVar8 != '\0')
        {
          return 0;
        }
        uVar13 = *puVar4;
LAB_0800157e:
        uVar11 >>= 8;
        uVar13 &= 0xffffff;
        goto LAB_08001592;
      }
      uVar13 = *puVar4;
      if ((uVar11 & 0xff ^ uVar11) != uVar13 * 0x100) goto LAB_0800157e;
      uVar11 = *puVar1;
      puVar1 = puVar1 + 1;
      puVar4 = puVar4 + 1;
    }
    uVar13 >>= 0x18;
  }
  else if (bVar15)
  {
    while( true )
    {
      bVar15 = (char)uVar11 != '\0';
      bVar16 = (char)(uVar11 >> 8) != '\0';
      uVar5 = uVar11 & 0xffff ^ uVar13 >> 0x10;
      sVar9 = CONCAT11(bVar16 * (char)(uVar5 >> 8) - !bVar16,bVar15 * (char)uVar5 - !bVar15);
      if (uVar5 != 0) break;
      if (CONCAT13(-((char)(uVar11 >> 0x18) == '\0'),
                   CONCAT12(-((char)(uVar11 >> 0x10) == '\0'),sVar9)) != 0)
      {
        if (sVar9 != 0)
        {
          return 0;
        }
        uVar13 = (uint)(ushort)*puVar4;
        uVar11 >>= 0x10;
        goto LAB_08001592;
      }
      uVar13 = *puVar4;
      if ((uVar11 & 0xffff ^ uVar11) != uVar13 * 0x10000)
      {
        uVar11 >>= 0x10;
        uVar13 &= 0xffff;
        goto LAB_08001592;
      }
      uVar11 = *puVar1;
      puVar1 = puVar1 + 1;
      puVar4 = puVar4 + 1;
    }
    uVar13 >>= 0x10;
  }
  else
  {
    while( true )
    {
      bVar15 = (char)uVar11 != '\0';
      bVar16 = (char)(uVar11 >> 8) != '\0';
      bVar17 = (char)(uVar11 >> 0x10) != '\0';
      uVar5 = uVar11 & 0xffffff ^ uVar13 >> 8;
      iVar10 = CONCAT12(bVar17 * (char)(uVar5 >> 0x10) - !bVar17,
                        CONCAT11(bVar16 * (char)(uVar5 >> 8) - !bVar16,
                                 bVar15 * (char)uVar5 - !bVar15));
      if (uVar5 != 0) break;
      if (CONCAT13(-((char)(uVar11 >> 0x18) == '\0'),iVar10) != 0)
      {
        if (iVar10 != 0)
        {
          return 0;
        }
        return -(uint)(byte)*puVar4;
      }
      uVar13 = *puVar4;
      if ((uVar11 & 0xffffff ^ uVar11) != uVar13 * 0x1000000)
      {
        uVar11 >>= 0x18;
        uVar13 &= 0xff;
        goto LAB_08001592;
      }
      uVar11 = *puVar1;
      puVar1 = puVar1 + 1;
      puVar4 = puVar4 + 1;
    }
    uVar13 >>= 8;
  }
LAB_08001592:
  uVar5 = uVar11 << 0x18 | (uVar11 >> 8 & 0xff) << 0x10 | (uVar11 >> 0x10 & 0xff) << 8 |
          uVar11 >> 0x18;
  uVar13 = uVar13 << 0x18 | (uVar13 >> 8 & 0xff) << 0x10 | (uVar13 >> 0x10) << 8;
  cVar8 = (char)(uVar11 >> 0x18);
  bVar15 = (char)(uVar11 >> 0x10) != '\0';
  bVar16 = (char)(uVar11 >> 8) != '\0';
  bVar17 = (char)uVar11 != '\0';
  uVar11 = uVar5 ^ uVar13;
  iVar7 = LZCOUNT(CONCAT13(bVar17 * (char)(uVar11 >> 0x18) - !bVar17,
                           CONCAT12(bVar16 * (char)(uVar11 >> 0x10) - !bVar16,
                                    CONCAT11(bVar15 * (char)(uVar11 >> 8) - !bVar15,
                                             (cVar8 != '\0') * cVar8 - (cVar8 == '\0')))));
  return ((uVar5 << iVar7) >> 0x18) - ((uVar13 << iVar7) >> 0x18);
}



size_t strlen(char *__s)
{
  char cVar1;
  char cVar2;
  char cVar3;
  char cVar4;
  int iVar5;
  int iVar6;
  uint *puVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  bool bVar14;
  
  HintPreloadData(__s);
  puVar7 = (uint *)((uint)__s & 0xfffffff8);
  HintPreloadData(puVar7 + 8);
  if (((uint)__s & 7) != 0)
  {
    uVar9 = puVar7[1];
    iVar6 = -((uint)__s & 7);
    HintPreloadData(puVar7 + 0x10);
    uVar10 = -1 << (((uint)__s & 3) << 3);
    uVar8 = *puVar7 | ~uVar10;
    if (((uint)__s & 4) == 0) goto LAB_080015f0;
    uVar9 |= ~uVar10;
    uVar8 = 0xffffffff;
    goto LAB_080015f0;
  }
  iVar5 = -8;
  do
  {
    uVar9 = puVar7[1];
    HintPreloadData(puVar7 + 0x10);
    iVar6 = iVar5 + 8;
    uVar8 = *puVar7;
LAB_080015f0:
    cVar1 = -((char)uVar8 == '\0');
    cVar2 = -((char)(uVar8 >> 8) == '\0');
    cVar3 = -((char)(uVar8 >> 0x10) == '\0');
    cVar4 = -((char)(uVar8 >> 0x18) == '\0');
    uVar8 = CONCAT13(cVar4,CONCAT12(cVar3,CONCAT11(cVar2,cVar1)));
    bVar11 = (char)uVar9 != '\0';
    bVar12 = (char)(uVar9 >> 8) != '\0';
    bVar13 = (char)(uVar9 >> 0x10) != '\0';
    bVar14 = (char)(uVar9 >> 0x18) != '\0';
    uVar9 = CONCAT13(bVar14 * cVar4 - !bVar14,
                     CONCAT12(bVar13 * cVar3 - !bVar13,
                              CONCAT11(bVar12 * cVar2 - !bVar12,bVar11 * cVar1 - !bVar11)));
    iVar5 = iVar6;
    if (uVar9 != 0) break;
    uVar8 = puVar7[2];
    uVar9 = puVar7[3];
    iVar5 = iVar6 + 8;
    cVar1 = -((char)uVar8 == '\0');
    cVar2 = -((char)(uVar8 >> 8) == '\0');
    cVar3 = -((char)(uVar8 >> 0x10) == '\0');
    cVar4 = -((char)(uVar8 >> 0x18) == '\0');
    uVar8 = CONCAT13(cVar4,CONCAT12(cVar3,CONCAT11(cVar2,cVar1)));
    bVar11 = (char)uVar9 != '\0';
    bVar12 = (char)(uVar9 >> 8) != '\0';
    bVar13 = (char)(uVar9 >> 0x10) != '\0';
    bVar14 = (char)(uVar9 >> 0x18) != '\0';
    uVar9 = CONCAT13(bVar14 * cVar4 - !bVar14,
                     CONCAT12(bVar13 * cVar3 - !bVar13,
                              CONCAT11(bVar12 * cVar2 - !bVar12,bVar11 * cVar1 - !bVar11)));
    if (uVar9 != 0) break;
    uVar8 = puVar7[4];
    uVar9 = puVar7[5];
    iVar5 = iVar6 + 0x10;
    cVar1 = -((char)uVar8 == '\0');
    cVar2 = -((char)(uVar8 >> 8) == '\0');
    cVar3 = -((char)(uVar8 >> 0x10) == '\0');
    cVar4 = -((char)(uVar8 >> 0x18) == '\0');
    uVar8 = CONCAT13(cVar4,CONCAT12(cVar3,CONCAT11(cVar2,cVar1)));
    bVar11 = (char)uVar9 != '\0';
    bVar12 = (char)(uVar9 >> 8) != '\0';
    bVar13 = (char)(uVar9 >> 0x10) != '\0';
    bVar14 = (char)(uVar9 >> 0x18) != '\0';
    uVar9 = CONCAT13(bVar14 * cVar4 - !bVar14,
                     CONCAT12(bVar13 * cVar3 - !bVar13,
                              CONCAT11(bVar12 * cVar2 - !bVar12,bVar11 * cVar1 - !bVar11)));
    if (uVar9 != 0) break;
    uVar8 = puVar7[6];
    uVar9 = puVar7[7];
    puVar7 = puVar7 + 8;
    iVar5 = iVar6 + 0x18;
    cVar1 = -((char)uVar8 == '\0');
    cVar2 = -((char)(uVar8 >> 8) == '\0');
    cVar3 = -((char)(uVar8 >> 0x10) == '\0');
    cVar4 = -((char)(uVar8 >> 0x18) == '\0');
    uVar8 = CONCAT13(cVar4,CONCAT12(cVar3,CONCAT11(cVar2,cVar1)));
    bVar11 = (char)uVar9 != '\0';
    bVar12 = (char)(uVar9 >> 8) != '\0';
    bVar13 = (char)(uVar9 >> 0x10) != '\0';
    bVar14 = (char)(uVar9 >> 0x18) != '\0';
    uVar9 = CONCAT13(bVar14 * cVar4 - !bVar14,
                     CONCAT12(bVar13 * cVar3 - !bVar13,
                              CONCAT11(bVar12 * cVar2 - !bVar12,bVar11 * cVar1 - !bVar11)));
  } while (uVar9 == 0);
  if (uVar8 == 0)
  {
    iVar5 += 4;
    uVar8 = uVar9;
  }
  return iVar5 + ((uint)LZCOUNT(uVar8 << 0x18 | (uVar8 >> 8 & 0xff) << 0x10 |
                                (uVar8 >> 0x10 & 0xff) << 8 | uVar8 >> 0x18) >> 3);
}



// WARNING: Unknown calling convention

int _vsnprintf_r(_reent_conflict *ptr,char *str,size_t size,char *fmt,va_list ap)
{
  int iVar1;
  FILE f;
  
  if ((int)size < 0)
  {
    ptr->_errno = 0x8b;
    iVar1 = -1;
  }
  else
  {
    f._flags = 0x208;
    f._p = (uchar *)str;
    f._bf._base = (uchar *)str;
    if (size != 0)
    {
      f._w = size - 1;
      f._file = -1;
      f._bf._size = f._w;
      iVar1 = _svfprintf_r(ptr,&f,fmt,ap);
      if (iVar1 + 1 < 0 != SCARRY4(iVar1,1))
      {
        ptr->_errno = 0x8b;
      }
      *f._p = '\0';
      return iVar1;
    }
    f._file = -1;
    f._w = size;
    f._bf._size = size;
    iVar1 = _svfprintf_r(ptr,&f,fmt,ap);
    if (iVar1 + 1 < 0 != SCARRY4(iVar1,1))
    {
      ptr->_errno = 0x8b;
    }
  }
  return iVar1;
}



int vsnprintf(char *__s,size_t __maxlen,char *__format,__gnuc_va_list __arg)
{
  int iVar1;
  
  iVar1 = _vsnprintf_r(_impure_ptr,__s,__maxlen,__format,(va_list)__arg);
  return iVar1;
}



// WARNING: Unknown calling convention

int _vsprintf_r(_reent_conflict *ptr,char *str,char *fmt,va_list ap)
{
  int iVar1;
  FILE f;
  
  f._bf._size = 0x7fffffff;
  f._w = 0x7fffffff;
  f._flags = 0x208;
  f._file = -1;
  f._p = (uchar *)str;
  f._bf._base = (uchar *)str;
  iVar1 = _svfprintf_r(ptr,&f,fmt,ap);
  *f._p = '\0';
  return iVar1;
}



int vsprintf(char *__s,char *__format,__gnuc_va_list __arg)
{
  int iVar1;
  
  iVar1 = _vsprintf_r(_impure_ptr,__s,__format,(va_list)__arg);
  return iVar1;
}



// WARNING: Unknown calling convention

int __swbuf_r(_reent_conflict *ptr,int c,FILE *fp)
{
  uchar *puVar1;
  uchar *puVar2;
  int iVar3;
  uint uVar4;
  
  if ((ptr != (_reent_conflict *)0x0) && (ptr->__sdidinit == 0))
  {
    __sinit(ptr);
  }
  if (fp == (FILE *)&__sf_fake_stdin)
  {
    fp = ptr->_stdin;
  }
  else if (fp == (FILE *)&__sf_fake_stdout)
  {
    fp = ptr->_stdout;
  }
  else if (fp == (FILE *)&__sf_fake_stderr)
  {
    fp = ptr->_stderr;
  }
  fp->_w = fp->_lbfsize;
  if ((-1 < (int)((uint)(ushort)fp->_flags << 0x1c)) ||
     (puVar2 = (fp->_bf)._base, puVar2 == (uchar *)0x0))
  {
    iVar3 = __swsetup_r(ptr,fp);
    if (iVar3 != 0)
    {
      return -1;
    }
    puVar2 = (fp->_bf)._base;
  }
  puVar1 = fp->_p;
  uVar4 = c & 0xff;
  if ((int)puVar1 - (int)puVar2 < (fp->_bf)._size)
  {
    iVar3 = ((int)puVar1 - (int)puVar2) + 1;
  }
  else
  {
    iVar3 = _fflush_r(ptr,fp);
    if (iVar3 != 0)
    {
      return -1;
    }
    puVar1 = fp->_p;
    iVar3 = 1;
  }
  fp->_w = fp->_w + -1;
  fp->_p = puVar1 + 1;
  *puVar1 = (uchar)c;
  if ((fp->_bf)._size != iVar3)
  {
    if (-1 < (int)((uint)(ushort)fp->_flags << 0x1f))
    {
      return uVar4;
    }
    if (uVar4 != 10)
    {
      return uVar4;
    }
  }
  iVar3 = _fflush_r(ptr,fp);
  if (iVar3 != 0)
  {
    return -1;
  }
  return uVar4;
}



// WARNING: Unknown calling convention

int __swbuf(int c,FILE *fp)
{
  int iVar1;
  
  iVar1 = __swbuf_r(_impure_ptr,c,fp);
  return iVar1;
}



// WARNING: Unknown calling convention

int __swsetup_r(_reent_conflict *ptr,FILE *fp)
{
  _reent_conflict *p_Var1;
  uchar *puVar2;
  ushort uVar3;
  uint uVar4;
  uint uVar5;
  
  p_Var1 = _impure_ptr;
  if ((_impure_ptr == (_reent_conflict *)0x0) || (_impure_ptr->__sdidinit != 0))
  {
    if (fp != (FILE *)&__sf_fake_stdin) goto LAB_0800183a;
LAB_08001878:
    fp = p_Var1->_stdin;
    uVar3 = fp->_flags;
    uVar5 = (uint)uVar3;
    if (-1 < (int)(uVar5 << 0x1c)) goto LAB_08001884;
LAB_08001852:
    puVar2 = (fp->_bf)._base;
    if (puVar2 == (uchar *)0x0) goto LAB_0800189a;
LAB_08001856:
    uVar4 = uVar5 & 1;
    if (uVar4 != 0)
    {
LAB_0800185c:
      fp->_lbfsize = -(fp->_bf)._size;
      fp->_w = 0;
      goto joined_r0x080018c0;
    }
  }
  else
  {
    __sinit(_impure_ptr);
    if (fp == (FILE *)&__sf_fake_stdin) goto LAB_08001878;
LAB_0800183a:
    if (fp == (FILE *)&__sf_fake_stdout)
    {
      fp = p_Var1->_stdout;
    }
    else if (fp == (FILE *)&__sf_fake_stderr)
    {
      fp = p_Var1->_stderr;
    }
    uVar3 = fp->_flags;
    uVar5 = (uint)uVar3;
    if ((int)(uVar5 << 0x1c) < 0) goto LAB_08001852;
LAB_08001884:
    if (-1 < (int)(uVar5 << 0x1b))
    {
      ptr->_errno = 9;
      fp->_flags = uVar3 | 0x40;
      return -1;
    }
    if ((int)(uVar5 << 0x1d) < 0)
    {
      puVar2 = (fp->_ub)._base;
      if (puVar2 != (uchar *)0x0)
      {
        if (puVar2 != fp->_ubuf)
        {
          _free_r(ptr,puVar2);
          uVar3 = fp->_flags;
        }
        (fp->_ub)._base = (uchar *)0x0;
      }
      puVar2 = (fp->_bf)._base;
      fp->_r = 0;
      uVar3 &= 0xffdb;
      fp->_p = puVar2;
    }
    else
    {
      puVar2 = (fp->_bf)._base;
    }
    fp->_flags = uVar3 | 8;
    uVar5 = (uint)(uVar3 | 8);
    if (puVar2 != (uchar *)0x0) goto LAB_08001856;
LAB_0800189a:
    if ((uVar5 & 0x280) == 0x200) goto LAB_08001856;
    __smakebuf_r(ptr,fp);
    uVar5 = (uint)(ushort)fp->_flags;
    puVar2 = (fp->_bf)._base;
    uVar4 = uVar5 & 1;
    if ((fp->_flags & 1U) != 0) goto LAB_0800185c;
  }
  if (-1 < (int)(uVar5 << 0x1e))
  {
    uVar4 = (fp->_bf)._size;
  }
  fp->_w = uVar4;
joined_r0x080018c0:
  if ((puVar2 == (uchar *)0x0) && ((int)fp->_flags << 0x18 < 0))
  {
    fp->_flags = fp->_flags | 0x40;
    return -1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void abort(void)
{
  raise(6);
                    // WARNING: Subroutine does not return
  _exit(1);
}



// WARNING: Unknown calling convention

int __sflush_r(_reent_conflict *ptr,FILE *fp)
{
  ushort uVar1;
  _fpos_t _Var2;
  void *pvVar3;
  uchar *puVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uchar *puVar8;
  _func__fpos_t__reent_ptr_void_ptr__fpos_t_int_conflict *p_Var9;
  
  uVar1 = fp->_flags;
  uVar5 = (uint)uVar1;
  if ((int)(uVar5 << 0x1c) < 0)
  {
    puVar4 = (fp->_bf)._base;
    if (puVar4 == (uchar *)0x0)
    {
      return 0;
    }
    puVar8 = fp->_p;
    fp->_p = puVar4;
    if ((uVar1 & 3) == 0)
    {
      iVar7 = (fp->_bf)._size;
    }
    else
    {
      iVar7 = 0;
    }
    iVar6 = (int)puVar8 - (int)puVar4;
    fp->_w = iVar7;
    do
    {
      if (iVar6 < 1)
      {
        return 0;
      }
      iVar7 = (*fp->_write)(ptr,fp->_cookie,(char *)puVar4,iVar6);
      iVar6 -= iVar7;
      puVar4 = puVar4 + iVar7;
    } while (0 < iVar7);
    fp->_flags = fp->_flags | 0x40;
    return -1;
  }
  if ((fp->_r < 1) && (fp->_ur < 1))
  {
    return 0;
  }
  p_Var9 = fp->_seek;
  if (p_Var9 == (_func__fpos_t__reent_ptr_void_ptr__fpos_t_int_conflict *)0x0)
  {
    return 0;
  }
  iVar7 = ptr->_errno;
  pvVar3 = fp->_cookie;
  ptr->_errno = 0;
  if ((uVar1 & 0x1000) == 0)
  {
    _Var2 = (*p_Var9)(ptr,pvVar3,uVar5 & 0x1000,1);
    if ((_Var2 == -1) && (iVar6 = ptr->_errno, iVar6 != 0))
    {
      if ((iVar6 != 0x1d) && (iVar6 != 0x16))
      {
        fp->_flags = fp->_flags | 0x40;
        return -1;
      }
      ptr->_errno = iVar7;
      return 0;
    }
    uVar5 = (uint)(ushort)fp->_flags;
    p_Var9 = fp->_seek;
    pvVar3 = fp->_cookie;
  }
  else
  {
    _Var2 = fp->_offset;
  }
  if (((int)(uVar5 << 0x1d) < 0) && (_Var2 -= fp->_r, (fp->_ub)._base != (uchar *)0x0))
  {
    _Var2 -= fp->_ur;
  }
  _Var2 = (*p_Var9)(ptr,pvVar3,_Var2,0);
  if (_Var2 == -1)
  {
    iVar6 = ptr->_errno;
    uVar5 = (uint)fp->_flags;
    if (iVar6 != 0)
    {
      if ((iVar6 != 0x1d) && (iVar6 != 0x16))
      {
        fp->_flags = fp->_flags | 0x40;
        return -1;
      }
      fp->_p = (fp->_bf)._base;
      fp->_r = 0;
      goto LAB_080019a8;
    }
    fp->_p = (fp->_bf)._base;
    fp->_r = 0;
  }
  else
  {
    uVar5 = (uint)(ushort)fp->_flags;
    fp->_p = (fp->_bf)._base;
    fp->_r = 0;
  }
  if ((int)(uVar5 << 0x13) < 0)
  {
    fp->_offset = _Var2;
  }
LAB_080019a8:
  puVar4 = (fp->_ub)._base;
  ptr->_errno = iVar7;
  if (puVar4 == (uchar *)0x0)
  {
    return 0;
  }
  if (puVar4 != fp->_ubuf)
  {
    _free_r(ptr,puVar4);
  }
  (fp->_ub)._base = (uchar *)0x0;
  return 0;
}



// WARNING: Unknown calling convention

int _fflush_r(_reent_conflict *ptr,FILE *fp)
{
  int iVar1;
  
  if ((fp->_bf)._base == (uchar *)0x0)
  {
    return 0;
  }
  if ((ptr != (_reent_conflict *)0x0) && (ptr->__sdidinit == 0))
  {
    __sinit(ptr);
  }
  if (fp == (FILE *)&__sf_fake_stdin)
  {
    fp = ptr->_stdin;
  }
  else if (fp == (FILE *)&__sf_fake_stdout)
  {
    fp = ptr->_stdout;
  }
  else if (fp == (FILE *)&__sf_fake_stderr)
  {
    fp = ptr->_stderr;
  }
  if (fp->_flags != 0)
  {
    iVar1 = __sflush_r(ptr,fp);
    return iVar1;
  }
  return 0;
}



int fflush(FILE *__stream)
{
  int iVar1;
  
  if (__stream != (FILE *)0x0)
  {
    iVar1 = _fflush_r(_impure_ptr,(FILE *)__stream);
    return iVar1;
  }
  iVar1 = _fwalk_reent(&impure_data,_fflush_r);
  return iVar1;
}



// WARNING: Unknown calling convention

int __fp_lock(FILE *ptr)
{
  return 0;
}



// WARNING: Unknown calling convention

void _cleanup_r(_reent_conflict *ptr)
{
  _fwalk_reent(ptr,(_func_int__reent_ptr_FILE_ptr *)0x8001a61);
  return;
}



undefined4 __fp_unlock(void)
{
  return 0;
}



// WARNING: Unknown calling convention

_glue * __sfmoreglue(_reent_conflict *d,int n)
{
  _glue *p_Var1;
  int iVar2;
  
  iVar2 = (n + -1) * 0x68;
  p_Var1 = (_glue *)_malloc_r(d,iVar2 + 0x74);
  if (p_Var1 != (_glue *)0x0)
  {
    p_Var1->_niobs = n;
    p_Var1->_next = (_glue *)0x0;
    p_Var1->_iobs = (__FILE_conflict *)(p_Var1 + 1);
    memset((__FILE_conflict *)(p_Var1 + 1),0,iVar2 + 0x68);
  }
  return p_Var1;
}



// WARNING: Unknown calling convention

FILE * __sfp(_reent_conflict *d)
{
  _glue *p_Var1;
  int iVar2;
  __FILE_conflict *p_Var3;
  _glue *p_Var4;
  
  if (impure_data.__sdidinit == 0)
  {
    __sinit(&impure_data);
  }
  p_Var1 = &impure_data.__sglue;
  do
  {
    do
    {
      p_Var4 = p_Var1;
      p_Var3 = p_Var4->_iobs;
      iVar2 = p_Var4->_niobs + -1;
      if (-1 < iVar2)
      {
        do
        {
          if (p_Var3->_flags == 0)
          {
            p_Var3->_flags2 = 0;
            p_Var3->_p = (uchar *)0x0;
            p_Var3->_r = 0;
            p_Var3->_w = 0;
            (p_Var3->_bf)._base = (uchar *)0x0;
            (p_Var3->_bf)._size = 0;
            p_Var3->_lbfsize = 0;
            p_Var3->_flags = 1;
            p_Var3->_file = -1;
            memset(&p_Var3->_mbstate,0,8);
            (p_Var3->_ub)._base = (uchar *)0x0;
            (p_Var3->_ub)._size = 0;
            (p_Var3->_lb)._base = (uchar *)0x0;
            (p_Var3->_lb)._size = 0;
            return p_Var3;
          }
          iVar2 += -1;
          p_Var3 = p_Var3 + 1;
        } while (iVar2 != -1);
      }
      p_Var1 = p_Var4->_next;
    } while (p_Var4->_next != (_glue *)0x0);
    p_Var1 = __sfmoreglue(d,4);
    p_Var4->_next = p_Var1;
  } while (p_Var1 != (_glue *)0x0);
  d->_errno = 0xc;
  return (FILE *)0x0;
}



// WARNING: Unknown calling convention

void __sinit(_reent_conflict *s)
{
  FILE *pFVar1;
  __FILE_conflict *p_Var2;
  __FILE_conflict *p_Var3;
  
  s->__cleanup = (_func_void__reent_ptr_conflict *)0x8001ae9;
  (s->__sglue)._next = (_glue *)0x0;
  (s->__sglue)._niobs = 0;
  (s->__sglue)._iobs = (__FILE_conflict *)0x0;
  if (s == &impure_data)
  {
    s->__sdidinit = (uint)(s == &impure_data);
  }
  pFVar1 = __sfp(s);
  s->_stdin = pFVar1;
  pFVar1 = __sfp(s);
  s->_stdout = pFVar1;
  pFVar1 = __sfp(s);
  p_Var2 = s->_stdin;
  s->_stderr = pFVar1;
  p_Var2->_flags = 4;
  p_Var2->_file = 0;
  p_Var2->_flags2 = 0;
  p_Var2->_p = (uchar *)0x0;
  p_Var2->_r = 0;
  p_Var2->_w = 0;
  (p_Var2->_bf)._base = (uchar *)0x0;
  (p_Var2->_bf)._size = 0;
  p_Var2->_lbfsize = 0;
  memset(&p_Var2->_mbstate,0,8);
  p_Var3 = s->_stdout;
  p_Var2->_close = (_func_int__reent_ptr_void_ptr_conflict *)0x80028b5;
  p_Var2->_cookie = p_Var2;
  p_Var2->_read = (_func_int__reent_ptr_void_ptr_char_ptr_int_conflict *)0x800282d;
  p_Var2->_write = (_func_int__reent_ptr_void_ptr_char_ptr_int_conflict *)0x8002855;
  p_Var2->_seek = (_func__fpos_t__reent_ptr_void_ptr__fpos_t_int_conflict *)0x8002895;
  p_Var3->_flags = 9;
  p_Var3->_file = 1;
  p_Var3->_flags2 = 0;
  p_Var3->_p = (uchar *)0x0;
  p_Var3->_r = 0;
  p_Var3->_w = 0;
  (p_Var3->_bf)._base = (uchar *)0x0;
  (p_Var3->_bf)._size = 0;
  p_Var3->_lbfsize = 0;
  memset(&p_Var3->_mbstate,0,8);
  p_Var2 = s->_stderr;
  p_Var3->_close = (_func_int__reent_ptr_void_ptr_conflict *)0x80028b5;
  p_Var3->_cookie = p_Var3;
  p_Var3->_read = (_func_int__reent_ptr_void_ptr_char_ptr_int_conflict *)0x800282d;
  p_Var3->_write = (_func_int__reent_ptr_void_ptr_char_ptr_int_conflict *)0x8002855;
  p_Var3->_seek = (_func__fpos_t__reent_ptr_void_ptr__fpos_t_int_conflict *)0x8002895;
  p_Var2->_flags = 0x12;
  p_Var2->_file = 2;
  p_Var2->_flags2 = 0;
  p_Var2->_p = (uchar *)0x0;
  p_Var2->_r = 0;
  p_Var2->_w = 0;
  (p_Var2->_bf)._base = (uchar *)0x0;
  (p_Var2->_bf)._size = 0;
  p_Var2->_lbfsize = 0;
  memset(&p_Var2->_mbstate,0,8);
  p_Var2->_cookie = p_Var2;
  p_Var2->_read = (_func_int__reent_ptr_void_ptr_char_ptr_int_conflict *)0x800282d;
  p_Var2->_write = (_func_int__reent_ptr_void_ptr_char_ptr_int_conflict *)0x8002855;
  p_Var2->_seek = (_func__fpos_t__reent_ptr_void_ptr__fpos_t_int_conflict *)0x8002895;
  p_Var2->_close = (_func_int__reent_ptr_void_ptr_conflict *)0x80028b5;
  s->__sdidinit = 1;
  return;
}



void _cleanup(EVP_PKEY_CTX *ctx)
{
  _fwalk_reent(&impure_data,(_func_int__reent_ptr_FILE_ptr *)0x8001a61);
  return;
}



// WARNING: Unknown calling convention

void __sinit(_reent_conflict *s)
{
  if (s->__sdidinit == 0)
  {
    __sinit(s);
    return;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __sfp_lock_acquire(void)
{
  return;
}



void __sfp_lock_release(void)
{
  return;
}



void __sinit_lock_acquire(void)
{
  return;
}



void __sinit_lock_release(void)
{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __fp_lock_all(void)
{
  _fwalk(_impure_ptr,(_func_int_FILE_ptr *)0x8001ae5);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __fp_unlock_all(void)
{
  _fwalk(_impure_ptr,(_func_int_FILE_ptr *)0x8001af5);
  return;
}



// WARNING: Unknown calling convention

int __sfvwrite_r(_reent_conflict *ptr,FILE *fp,__suio *uio)
{
  size_t *psVar1;
  int iVar2;
  uchar *puVar3;
  uint uVar4;
  uchar *puVar5;
  char *pcVar6;
  ushort uVar7;
  uint uVar8;
  size_t sVar9;
  uint uVar10;
  __siov *p_Var11;
  char *pcVar12;
  char *__n;
  __siov *p_Var13;
  char *pcVar14;
  uint uVar15;
  char *__n_00;
  _func_int__reent_ptr_void_ptr_char_ptr_int_conflict *p_Var16;
  size_t __n_01;
  void *pvVar17;
  
  if (uio->uio_resid == 0)
  {
    return 0;
  }
  uVar7 = fp->_flags;
  uVar8 = (uint)uVar7;
  if (((int)(uVar8 << 0x1c) < 0) && ((fp->_bf)._base != (uchar *)0x0))
  {
    p_Var13 = uio->uio_iov;
  }
  else
  {
    iVar2 = __swsetup_r(ptr,fp);
    if (iVar2 != 0)
    {
      return -1;
    }
    uVar7 = fp->_flags;
    p_Var13 = uio->uio_iov;
    uVar8 = (uint)uVar7;
  }
  if ((uVar7 & 2) != 0)
  {
    pcVar14 = (char *)0x0;
    p_Var16 = fp->_write;
    pvVar17 = fp->_cookie;
    uVar8 = 0;
    do
    {
      uVar10 = uVar8;
      if (0x7ffffbff < uVar8)
      {
        uVar10 = 0x7ffffc00;
      }
      while (uVar8 != 0)
      {
        iVar2 = (*p_Var16)(ptr,pvVar17,pcVar14,uVar10);
        if (iVar2 < 1) goto LAB_08001eec;
        sVar9 = uio->uio_resid - iVar2;
        pcVar14 = pcVar14 + iVar2;
        uVar8 -= iVar2;
        uio->uio_resid = sVar9;
        if (sVar9 == 0)
        {
          return 0;
        }
        pvVar17 = fp->_cookie;
        p_Var16 = fp->_write;
        uVar10 = uVar8;
        if (0x7ffffbff < uVar8)
        {
          uVar10 = 0x7ffffc00;
        }
      }
      pcVar14 = (char *)p_Var13->iov_base;
      uVar8 = p_Var13->iov_len;
      p_Var13 = p_Var13 + 1;
    } while( true );
  }
  pcVar6 = (char *)(uVar8 & 2);
  pcVar14 = pcVar6;
  __n_00 = pcVar6;
  pcVar12 = pcVar6;
  if ((uVar8 & 1) == 0)
  {
    uVar15 = fp->_w;
    puVar3 = fp->_p;
    uVar10 = 0;
    pcVar14 = (char *)0x0;
    while( true )
    {
      while (uVar10 == 0)
      {
        pcVar14 = (char *)p_Var13->iov_base;
        psVar1 = &p_Var13->iov_len;
        p_Var13 = p_Var13 + 1;
        uVar10 = *psVar1;
      }
      if ((int)(uVar8 << 0x16) < 0)
      {
        uVar4 = uVar10;
        if ((uVar15 <= uVar10) && (uVar4 = uVar15, (uVar8 & 0x480) != 0))
        {
          puVar5 = (fp->_bf)._base;
          __n_01 = (int)puVar3 - (int)puVar5;
          uVar15 = ((fp->_bf)._size * 3) / 2;
          uVar4 = uVar10 + 1 + __n_01;
          if (uVar15 < uVar4)
          {
            uVar15 = uVar4;
          }
          if ((int)(uVar8 << 0x15) < 0)
          {
            puVar5 = (uchar *)_malloc_r(ptr,uVar15);
            if (puVar5 == (uchar *)0x0)
            {
              ptr->_errno = 0xc;
              uVar7 = fp->_flags;
              goto LAB_08001ef0;
            }
            memcpy(puVar5,(fp->_bf)._base,__n_01);
            fp->_flags = fp->_flags & 0xfb7fU | 0x80;
          }
          else
          {
            puVar5 = (uchar *)_realloc_r(ptr,puVar5,uVar15);
            if (puVar5 == (uchar *)0x0)
            {
              _free_r(ptr,(fp->_bf)._base);
              uVar7 = fp->_flags & 0xff7f;
              ptr->_errno = 0xc;
              goto LAB_08001ef0;
            }
          }
          puVar3 = puVar5 + __n_01;
          (fp->_bf)._size = uVar15;
          (fp->_bf)._base = puVar5;
          fp->_p = puVar3;
          fp->_w = uVar15 - __n_01;
          uVar4 = uVar10;
        }
        memmove(puVar3,pcVar14,uVar4);
        fp->_w = fp->_w - uVar4;
        fp->_p = fp->_p + uVar4;
        uVar4 = 0;
        uVar15 = uVar10;
      }
      else
      {
        if (((fp->_bf)._base < puVar3) || (uVar8 = (fp->_bf)._size, uVar10 < uVar8))
        {
          if (uVar10 <= uVar15)
          {
            uVar15 = uVar10;
          }
          memmove(puVar3,pcVar14,uVar15);
          iVar2 = fp->_w - uVar15;
          fp->_w = iVar2;
          fp->_p = fp->_p + uVar15;
          if ((iVar2 == 0) && (iVar2 = _fflush_r(ptr,fp), iVar2 != 0)) goto LAB_08001eec;
        }
        else
        {
          uVar15 = uVar10;
          if (0x7ffffffe < uVar10)
          {
            uVar15 = 0x7fffffff;
          }
          uVar15 = (*fp->_write)(ptr,fp->_cookie,pcVar14,uVar8 * ((int)uVar15 / (int)uVar8));
          if ((int)uVar15 < 1) goto LAB_08001eec;
        }
        uVar4 = uVar10 - uVar15;
      }
      sVar9 = uio->uio_resid - uVar15;
      pcVar14 = pcVar14 + uVar15;
      uio->uio_resid = sVar9;
      if (sVar9 == 0) break;
      uVar15 = fp->_w;
      puVar3 = fp->_p;
      uVar8 = (uint)(ushort)fp->_flags;
      uVar10 = uVar4;
    }
  }
  else
  {
    do
    {
      if (__n_00 == (char *)0x0)
      {
        do
        {
          p_Var11 = p_Var13 + 1;
          pcVar14 = (char *)p_Var13->iov_base;
          __n_00 = (char *)p_Var13->iov_len;
          p_Var13 = p_Var11;
        } while (__n_00 == (char *)0x0);
        pvVar17 = memchr(pcVar14,10,(size_t)__n_00);
joined_r0x08001e7c:
        if (pvVar17 == (void *)0x0)
        {
          pcVar12 = __n_00 + 1;
        }
        else
        {
          pcVar12 = (char *)((int)pvVar17 + (1 - (int)pcVar14));
        }
      }
      else if (pcVar6 == (char *)0x0)
      {
        pvVar17 = memchr(pcVar14,10,(size_t)__n_00);
        goto joined_r0x08001e7c;
      }
      iVar2 = (fp->_bf)._size;
      puVar3 = fp->_p;
      pcVar6 = pcVar12;
      if (__n_00 <= pcVar12)
      {
        pcVar6 = __n_00;
      }
      if (((fp->_bf)._base < puVar3) && (__n = (char *)(fp->_w + iVar2), (int)__n < (int)pcVar6))
      {
        memmove(puVar3,pcVar14,(size_t)__n);
        fp->_p = fp->_p + (int)__n;
        iVar2 = _fflush_r(ptr,fp);
        if (iVar2 != 0)
        {
LAB_08001eec:
          uVar7 = fp->_flags;
LAB_08001ef0:
          fp->_flags = uVar7 | 0x40;
          return -1;
        }
      }
      else if ((int)pcVar6 < iVar2)
      {
        memmove(puVar3,pcVar14,(size_t)pcVar6);
        fp->_w = fp->_w - (int)pcVar6;
        fp->_p = fp->_p + (int)pcVar6;
        __n = pcVar6;
      }
      else
      {
        __n = (char *)(*fp->_write)(ptr,fp->_cookie,pcVar14,iVar2);
        if ((int)__n < 1) goto LAB_08001eec;
      }
      if (pcVar12 + -(int)__n == (char *)0x0)
      {
        pcVar6 = (char *)_fflush_r(ptr,fp);
        if (pcVar6 != (char *)0x0) goto LAB_08001eec;
      }
      else
      {
        pcVar6 = (char *)0x1;
      }
      sVar9 = uio->uio_resid - (int)__n;
      uio->uio_resid = sVar9;
      pcVar14 = pcVar14 + (int)__n;
      __n_00 = __n_00 + -(int)__n;
      pcVar12 = pcVar12 + -(int)__n;
    } while (sVar9 != 0);
  }
  return 0;
}



// WARNING: Unknown calling convention

int _fwalk(_reent_conflict *ptr,_func_int_FILE_ptr *function)
{
  uint uVar1;
  FILE *pFVar2;
  int iVar3;
  uint uVar4;
  _glue *p_Var5;
  bool bVar6;
  
  p_Var5 = &ptr->__sglue;
  if (p_Var5 != (_glue *)0x0)
  {
    uVar4 = 0;
    do
    {
      pFVar2 = p_Var5->_iobs;
      iVar3 = p_Var5->_niobs + -1;
      if (-1 < iVar3)
      {
        do
        {
          if ((1 < (ushort)pFVar2->_flags) && (pFVar2->_file != -1))
          {
            uVar1 = (*function)(pFVar2);
            uVar4 |= uVar1;
          }
          bVar6 = iVar3 != 0;
          pFVar2 = pFVar2 + 1;
          iVar3 = iVar3 + -1;
        } while (bVar6);
      }
      p_Var5 = p_Var5->_next;
    } while (p_Var5 != (_glue *)0x0);
    return uVar4;
  }
  return 0;
}



// WARNING: Unknown calling convention

int _fwalk_reent(_reent_conflict *ptr,_func_int__reent_ptr_FILE_ptr *reent_function)
{
  uint uVar1;
  FILE *pFVar2;
  int iVar3;
  _glue *p_Var4;
  uint uVar5;
  bool bVar6;
  
  p_Var4 = &ptr->__sglue;
  if (p_Var4 != (_glue *)0x0)
  {
    uVar5 = 0;
    do
    {
      pFVar2 = p_Var4->_iobs;
      iVar3 = p_Var4->_niobs + -1;
      if (-1 < iVar3)
      {
        do
        {
          if ((1 < (ushort)pFVar2->_flags) && (pFVar2->_file != -1))
          {
            uVar1 = (*reent_function)(ptr,pFVar2);
            uVar5 |= uVar1;
          }
          bVar6 = iVar3 != 0;
          pFVar2 = pFVar2 + 1;
          iVar3 = iVar3 + -1;
        } while (bVar6);
      }
      p_Var4 = p_Var4->_next;
    } while (p_Var4 != (_glue *)0x0);
    return uVar5;
  }
  return 0;
}



// WARNING: Unknown calling convention

int __swhatbuf_r(_reent_conflict *ptr,FILE *fp,size_t *bufsize,int *couldbetty)
{
  ushort uVar1;
  int iVar2;
  stat st;
  
  if ((-1 < fp->_file) && (iVar2 = _fstat_r(ptr,(int)fp->_file,&st), -1 < iVar2))
  {
    *couldbetty = (uint)((st.st_mode & 0xf000) == 0x2000);
    *bufsize = 0x400;
    return 0;
  }
  uVar1 = fp->_flags;
  *couldbetty = 0;
  if ((int)((uint)uVar1 << 0x18) < 0)
  {
    *bufsize = 0x40;
    return 0;
  }
  *bufsize = 0x400;
  return 0;
}



// WARNING: Unknown calling convention

void __smakebuf_r(_reent_conflict *ptr,FILE *fp)
{
  int iVar1;
  uchar *puVar2;
  int iVar3;
  ushort uVar4;
  size_t size;
  int couldbetty;
  
  if ((int)((uint)(ushort)fp->_flags << 0x1e) < 0)
  {
    fp->_p = fp->_nbuf;
    (fp->_bf)._base = fp->_nbuf;
    (fp->_bf)._size = 1;
    return;
  }
  iVar1 = __swhatbuf_r(ptr,fp,&size,&couldbetty);
  puVar2 = (uchar *)_malloc_r(ptr,size);
  uVar4 = fp->_flags;
  if (puVar2 == (uchar *)0x0)
  {
    if (-1 < (int)(short)uVar4 << 0x16)
    {
      fp->_flags = uVar4 & 0xfffc | 2;
      fp->_p = fp->_nbuf;
      (fp->_bf)._base = fp->_nbuf;
      (fp->_bf)._size = 1;
    }
  }
  else
  {
    ptr->__cleanup = (_func_void__reent_ptr_conflict *)0x8001ae9;
    fp->_p = puVar2;
    uVar4 |= 0x80;
    fp->_flags = uVar4;
    (fp->_bf)._base = puVar2;
    (fp->_bf)._size = size;
    if (couldbetty != 0)
    {
      iVar3 = _isatty_r(ptr,(int)fp->_file);
      if (iVar3 == 0)
      {
        uVar4 = fp->_flags;
      }
      else
      {
        uVar4 = fp->_flags & 0xfffcU | 1;
      }
    }
    fp->_flags = uVar4 | (ushort)iVar1;
  }
  return;
}



void * memchr(void *__s,int __c,size_t __n)
{
  char cVar1;
  char cVar2;
  char cVar3;
  char cVar4;
  byte *pbVar5;
  uint *puVar6;
  byte *pbVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  bool bVar13;
  bool bVar14;
  bool bVar15;
  bool bVar16;
  
  uVar8 = __c & 0xff;
  if ((int)__n < 0x10)
  {
joined_r0x080021f0:
    do
    {
      if (__n == 0)
      {
        return (void *)0x0;
      }
                    // WARNING: Load size is inaccurate
      puVar6 = (uint *)((int)__s + 1);
      uVar9 = *__s;
      __n -= 1;
      __s = puVar6;
    } while ((byte)uVar9 != uVar8);
  }
  else
  {
    uVar9 = (uint)__s & 7;
    while( true )
    {
      if (uVar9 == 0)
      {
        uVar9 = uVar8 | uVar8 << 8;
        uVar9 |= uVar9 << 0x10;
        uVar10 = __n & 0xfffffff8;
        do
        {
          puVar6 = (uint *)((int)__s + 8);
                    // WARNING: Load size is inaccurate
          uVar10 -= 8;
          uVar11 = *__s ^ uVar9;
          uVar12 = *(uint *)((int)__s + 4) ^ uVar9;
          cVar1 = -((char)uVar11 == '\0');
          cVar2 = -((char)(uVar11 >> 8) == '\0');
          cVar3 = -((char)(uVar11 >> 0x10) == '\0');
          cVar4 = -((char)(uVar11 >> 0x18) == '\0');
          uVar11 = CONCAT13(cVar4,CONCAT12(cVar3,CONCAT11(cVar2,cVar1)));
          bVar13 = (char)uVar12 != '\0';
          bVar14 = (char)(uVar12 >> 8) != '\0';
          bVar15 = (char)(uVar12 >> 0x10) != '\0';
          bVar16 = (char)(uVar12 >> 0x18) != '\0';
          uVar12 = CONCAT13(bVar16 * cVar4 - !bVar16,
                            CONCAT12(bVar15 * cVar3 - !bVar15,
                                     CONCAT11(bVar14 * cVar2 - !bVar14,bVar13 * cVar1 - !bVar13)));
          if (uVar12 != 0)
          {
            if (uVar11 == 0)
            {
              pbVar7 = (byte *)((int)__s + 5);
              uVar11 = uVar12;
            }
            else
            {
              pbVar7 = (byte *)((int)__s + 1);
            }
            if ((uVar11 & 1) == 0)
            {
              bVar13 = (uVar11 & 0x100) == 0;
              pbVar5 = pbVar7 + 1;
              if (bVar13)
              {
                pbVar5 = pbVar7 + 2;
              }
              pbVar7 = pbVar5;
              if (bVar13 && (uVar11 & 0x18000) == 0)
              {
                pbVar7 = pbVar7 + 1;
              }
            }
            return pbVar7 + -1;
          }
          __s = puVar6;
        } while (uVar10 != 0);
        __n &= 7;
        goto joined_r0x080021f0;
      }
                    // WARNING: Load size is inaccurate
      puVar6 = (uint *)((int)__s + 1);
      __n -= 1;
      if ((byte)*__s == uVar8) break;
      uVar9 = (uint)puVar6 & 7;
      __s = puVar6;
      if (__n == 0)
      {
        return (void *)0x0;
      }
    }
  }
  return (byte *)((int)puVar6 + -1);
}



// WARNING: Unknown calling convention

void __malloc_lock(_reent_conflict *ptr)
{
  return;
}



void __malloc_unlock(void)
{
  return;
}



// WARNING: Unknown calling convention

void * _realloc_r(_reent_conflict *reent_ptr,void *ptr,malloc_size_t size)
{
  malloc_size_t mVar1;
  void *pvVar2;
  
  if (ptr == (void *)0x0)
  {
    pvVar2 = _malloc_r(reent_ptr,size);
    return pvVar2;
  }
  if (size == 0)
  {
    _free_r(reent_ptr,ptr);
    return (void *)0x0;
  }
  mVar1 = _malloc_usable_size_r(reent_ptr,ptr);
  pvVar2 = ptr;
  if ((mVar1 < size) && (pvVar2 = _malloc_r(reent_ptr,size), pvVar2 != (void *)0x0))
  {
    memcpy(pvVar2,ptr,size);
    _free_r(reent_ptr,ptr);
    return pvVar2;
  }
  return pvVar2;
}



// WARNING: Unknown calling convention

int __ssputs_r(_reent_conflict *ptr,FILE *fp,char *buf,size_t len)
{
  uchar *puVar1;
  uchar *__dest;
  uint uVar2;
  size_t __n;
  uint size;
  size_t __n_00;
  
  __dest = fp->_p;
  __n = len;
  if (((uint)fp->_w <= len) && (__n = fp->_w, (fp->_flags & 0x480U) != 0))
  {
    puVar1 = (fp->_bf)._base;
    __n_00 = (int)__dest - (int)puVar1;
    size = ((fp->_bf)._size * 3) / 2;
    uVar2 = len + 1 + __n_00;
    if (size < uVar2)
    {
      size = uVar2;
    }
    if ((int)((uint)(ushort)fp->_flags << 0x15) < 0)
    {
      puVar1 = (uchar *)_malloc_r(ptr,size);
      if (puVar1 == (uchar *)0x0)
      {
LAB_08002330:
        ptr->_errno = 0xc;
        fp->_flags = fp->_flags | 0x40;
        return -1;
      }
      memcpy(puVar1,(fp->_bf)._base,__n_00);
      fp->_flags = fp->_flags & 0xfb7fU | 0x80;
    }
    else
    {
      puVar1 = (uchar *)_realloc_r(ptr,puVar1,size);
      if (puVar1 == (uchar *)0x0)
      {
        _free_r(ptr,(fp->_bf)._base);
        goto LAB_08002330;
      }
    }
    __dest = puVar1 + __n_00;
    (fp->_bf)._size = size;
    (fp->_bf)._base = puVar1;
    fp->_p = __dest;
    fp->_w = size - __n_00;
    __n = len;
  }
  memmove(__dest,buf,__n);
  fp->_w = fp->_w - __n;
  fp->_p = fp->_p + __n;
  return 0;
}



// WARNING: Unknown calling convention

int __ssprint_r(_reent_conflict *ptr,FILE *fp,__suio *uio)
{
  uchar *__dest;
  uint uVar1;
  uchar *puVar2;
  uint uVar3;
  size_t sVar4;
  uint uVar5;
  __siov *p_Var6;
  __siov *p_Var7;
  void *__src;
  size_t __n;
  
  if (uio->uio_resid != 0)
  {
    uVar3 = fp->_w;
    __dest = fp->_p;
    p_Var7 = uio->uio_iov;
    do
    {
      do
      {
        p_Var6 = p_Var7 + 1;
        __src = p_Var7->iov_base;
        uVar5 = p_Var7->iov_len;
        p_Var7 = p_Var6;
      } while (uVar5 == 0);
      uVar1 = uVar5;
      if ((uVar3 <= uVar5) && (uVar1 = uVar3, (fp->_flags & 0x480U) != 0))
      {
        puVar2 = (fp->_bf)._base;
        __n = (int)__dest - (int)puVar2;
        uVar3 = ((fp->_bf)._size * 3) / 2;
        uVar1 = __n + uVar5 + 1;
        if (uVar3 < uVar1)
        {
          uVar3 = uVar1;
        }
        if ((int)((uint)(ushort)fp->_flags << 0x15) < 0)
        {
          puVar2 = (uchar *)_malloc_r(ptr,uVar3);
          if (puVar2 == (uchar *)0x0)
          {
LAB_08002410:
            ptr->_errno = 0xc;
            fp->_flags = fp->_flags | 0x40;
            uio->uio_iovcnt = 0;
            uio->uio_resid = 0;
            return -1;
          }
          memcpy(puVar2,(fp->_bf)._base,__n);
          fp->_flags = fp->_flags & 0xfb7fU | 0x80;
        }
        else
        {
          puVar2 = (uchar *)_realloc_r(ptr,puVar2,uVar3);
          if (puVar2 == (uchar *)0x0)
          {
            _free_r(ptr,(fp->_bf)._base);
            goto LAB_08002410;
          }
        }
        __dest = puVar2 + __n;
        (fp->_bf)._size = uVar3;
        (fp->_bf)._base = puVar2;
        fp->_p = __dest;
        fp->_w = uVar3 - __n;
        uVar1 = uVar5;
      }
      memmove(__dest,__src,uVar1);
      uVar3 = fp->_w - uVar1;
      __dest = fp->_p + uVar1;
      sVar4 = uio->uio_resid - uVar5;
      fp->_w = uVar3;
      fp->_p = __dest;
      uio->uio_resid = sVar4;
    } while (sVar4 != 0);
  }
  uio->uio_iovcnt = 0;
  return 0;
}



// WARNING: Unknown calling convention

int _svfprintf_r(_reent_conflict *data,FILE *fp,char *fmt0,va_list ap)
{
  byte bVar1;
  int iVar2;
  void *pvVar3;
  _reent_conflict *p_Var4;
  uchar *puVar5;
  uint __c;
  uint uVar6;
  byte *pbVar7;
  byte *pbVar8;
  byte *pbVar9;
  _reent_conflict *unaff_r9;
  size_t len;
  va_list ap_copy;
  _prt_data_t prt_data;
  
  if (((int)((uint)(ushort)fp->_flags << 0x18) < 0) && ((fp->_bf)._base == (uchar *)0x0))
  {
    puVar5 = (uchar *)_malloc_r(data,0x40);
    fp->_p = puVar5;
    (fp->_bf)._base = puVar5;
    if (puVar5 == (uchar *)0x0)
    {
      data->_errno = 0xc;
      return -1;
    }
    (fp->_bf)._size = 0x40;
  }
  prt_data.zero = '0';
  bVar1 = *fmt0;
  prt_data.ret = 0;
  prt_data.blank = ' ';
  ap_copy.__ap = ap.__ap;
  while (bVar1 != 0)
  {
    pbVar7 = (byte *)fmt0;
    if (bVar1 != 0x25)
    {
      do
      {
        pbVar8 = pbVar7;
        pbVar7 = pbVar8 + 1;
        if (pbVar8[1] == 0)
        {
          len = (int)pbVar7 - (int)fmt0;
          if (len != 0) goto LAB_08002496;
          goto LAB_0800257e;
        }
      } while (pbVar8[1] != 0x25);
      len = (int)pbVar7 - (int)fmt0;
      if (len != 0)
      {
LAB_08002496:
        iVar2 = __ssputs_r(data,fp,fmt0,len);
        if ((iVar2 == -1) || (prt_data.ret += len, pbVar8[1] == 0)) break;
      }
    }
    prt_data.flags = 0;
    prt_data.dprec = 0;
    prt_data.width = 0;
    prt_data.l_buf[0] = '\0';
    prt_data.lead = 0;
    prt_data.prec = -1;
    pbVar7 = pbVar7 + 1;
    while( true )
    {
      pbVar8 = pbVar7 + 1;
      pvVar3 = memchr("#-0+ ",(uint)*pbVar7,5);
      if (pvVar3 == (void *)0x0) break;
      prt_data.flags = 1 << ((int)pvVar3 + 0xf7fc639cU & 0xff) | prt_data.flags;
      pbVar7 = pbVar8;
    }
    if (prt_data.flags << 0x1b < 0)
    {
      prt_data.l_buf[0] = ' ';
    }
    __c = (uint)*pbVar7;
    if (prt_data.flags << 0x1c < 0)
    {
      prt_data.l_buf[0] = '+';
    }
    if (__c == 0x2a)
    {
                    // WARNING: Load size is inaccurate
      prt_data.width = *ap_copy.__ap;
      ap_copy.__ap += 4;
      if (prt_data.width < 0)
      {
        prt_data.width = -prt_data.width;
        prt_data.flags |= 2;
      }
      __c = (uint)pbVar7[1];
      pbVar9 = pbVar7 + 2;
      pbVar7 = pbVar8;
LAB_0800251a:
      pbVar8 = pbVar7;
      fmt0 = (char *)pbVar9;
      if (__c != 0x2e) goto LAB_0800251e;
LAB_080025cc:
      __c = (uint)pbVar8[1];
      if (__c != 0x2a)
      {
        uVar6 = __c - 0x30;
        iVar2 = 0;
        prt_data.prec = 0;
        if (uVar6 < 10)
        {
          do
          {
            pbVar7 = pbVar9;
            __c = (uint)pbVar7[1];
            iVar2 = uVar6 + iVar2 * 10;
            uVar6 = __c - 0x30;
            pbVar8 = pbVar7 + 1;
            pbVar9 = pbVar8;
          } while (uVar6 < 10);
          fmt0 = (char *)(pbVar7 + 2);
          prt_data.prec = iVar2;
        }
        else
        {
          fmt0 = (char *)(pbVar9 + 1);
          pbVar8 = pbVar9;
        }
        goto LAB_0800251e;
      }
      __c = (uint)pbVar8[2];
                    // WARNING: Load size is inaccurate
      prt_data.prec = *ap_copy.__ap;
      ap_copy.__ap += 4;
      fmt0 = (char *)(pbVar8 + 3);
      pbVar8 = pbVar8 + 2;
      if (prt_data.prec < 0)
      {
        prt_data.prec = -1;
        goto LAB_0800251e;
      }
      pvVar3 = memchr(&DAT_08039c6c,__c,3);
    }
    else
    {
      uVar6 = __c - 0x30;
      pbVar9 = pbVar8;
      if (9 < uVar6) goto LAB_0800251a;
      while( true )
      {
        __c = (uint)*pbVar8;
        prt_data.width = uVar6 + prt_data.width * 10;
        uVar6 = __c - 0x30;
        if (9 < uVar6) break;
        pbVar7 = pbVar8;
        pbVar8 = pbVar8 + 1;
      }
      pbVar9 = pbVar7 + 2;
      fmt0 = (char *)pbVar9;
      if (__c == 0x2e) goto LAB_080025cc;
LAB_0800251e:
      pvVar3 = memchr(&DAT_08039c6c,__c,3);
    }
    if (pvVar3 != (void *)0x0)
    {
      prt_data.flags |= 0x40 << ((int)pvVar3 + 0xf7fc6394U & 0xff);
      pbVar8 = (byte *)fmt0;
      fmt0 = (char *)((byte *)fmt0 + 1);
    }
    prt_data.code = *pbVar8;
    pvVar3 = memchr("efgEFG",(uint)(byte)prt_data.code,6);
    if (pvVar3 == (void *)0x0)
    {
      p_Var4 = (_reent_conflict *)_printf_i(data,&prt_data,fp,__ssputs_r,&ap_copy);
LAB_08002568:
      unaff_r9 = p_Var4;
      if (p_Var4 == (_reent_conflict *)0xffffffff) break;
    }
    else
    {
      p_Var4 = data;
      if (false) goto LAB_08002568;
      ap_copy.__ap = (void *)(((int)ap_copy.__ap + 7U & 0xfffffff8) + 8);
    }
    prt_data.ret = (int)&unaff_r9->_errno + prt_data.ret;
    bVar1 = *fmt0;
  }
LAB_0800257e:
  if ((int)((uint)(ushort)fp->_flags << 0x19) < 0)
  {
    prt_data.ret = -1;
  }
  return prt_data.ret;
}



// WARNING: Unknown calling convention

int _init_signal_r(_reent_conflict *ptr)
{
  _func_void_int **pp_Var1;
  _func_void_int **pp_Var2;
  
  pp_Var1 = (_func_void_int **)_malloc_r(ptr,0x80);
  ptr->_sig_func = pp_Var1;
  if (pp_Var1 != (_func_void_int **)0x0)
  {
    pp_Var2 = pp_Var1 + -1;
    do
    {
      pp_Var2 = pp_Var2 + 1;
      *pp_Var2 = (_func_void_int *)0x0;
    } while (pp_Var2 != pp_Var1 + 0x1f);
    return 0;
  }
  return -1;
}



// WARNING: Unknown calling convention

int _init_signal_r(_reent_conflict *ptr)
{
  int iVar1;
  
  if (ptr->_sig_func != (_func_void_int **)0x0)
  {
    return 0;
  }
  iVar1 = _init_signal_r(ptr);
  return iVar1;
}



// WARNING: Unknown calling convention

_sig_func_ptr _signal_r(_reent_conflict *ptr,int sig,_sig_func_ptr func)
{
  _func_void_int *p_Var1;
  int iVar2;
  _func_void_int **pp_Var3;
  
  if (0x1f < (uint)sig)
  {
    ptr->_errno = 0x16;
    return (_sig_func_ptr)0xffffffff;
  }
  pp_Var3 = ptr->_sig_func;
  if (pp_Var3 == (_func_void_int **)0x0)
  {
    iVar2 = _init_signal_r(ptr);
    if (iVar2 != 0)
    {
      return (_sig_func_ptr)0xffffffff;
    }
    pp_Var3 = ptr->_sig_func;
  }
  p_Var1 = pp_Var3[sig];
  pp_Var3[sig] = func;
  return p_Var1;
}



// WARNING: Unknown calling convention

int _raise_r(_reent_conflict *ptr,int sig)
{
  int iVar1;
  _func_void_int **pp_Var2;
  _func_void_int *p_Var3;
  
  if (0x1f < (uint)sig)
  {
    ptr->_errno = 0x16;
    return -1;
  }
  pp_Var2 = ptr->_sig_func;
  if ((pp_Var2 == (_func_void_int **)0x0) ||
     (p_Var3 = pp_Var2[sig], p_Var3 == (_func_void_int *)0x0))
  {
    iVar1 = _getpid_r(ptr);
    iVar1 = _kill_r(ptr,iVar1,sig);
    return iVar1;
  }
  if (p_Var3 == (_func_void_int *)0x1)
  {
    return 0;
  }
  if (p_Var3 != (_func_void_int *)0xffffffff)
  {
    pp_Var2[sig] = (_func_void_int *)0x0;
    (*p_Var3)(sig);
    return 0;
  }
  ptr->_errno = 0x16;
  return 1;
}



// WARNING: Unknown calling convention

int __sigtramp_r(_reent_conflict *ptr,int sig)
{
  int iVar1;
  _func_void_int *p_Var2;
  _func_void_int **pp_Var3;
  
  if (0x1f < (uint)sig)
  {
    return -1;
  }
  pp_Var3 = ptr->_sig_func;
  if (pp_Var3 == (_func_void_int **)0x0)
  {
    iVar1 = _init_signal_r(ptr);
    if (iVar1 != 0)
    {
      return -1;
    }
    pp_Var3 = ptr->_sig_func;
  }
  p_Var2 = pp_Var3[sig];
  if (p_Var2 == (_func_void_int *)0x0)
  {
    return 1;
  }
  if (p_Var2 == (_func_void_int *)0xffffffff)
  {
    return 2;
  }
  if (p_Var2 != (_func_void_int *)0x1)
  {
    pp_Var3[sig] = (_func_void_int *)0x0;
    (*p_Var2)(sig);
    return 0;
  }
  return 3;
}



int raise(int __sig)
{
  int iVar1;
  
  iVar1 = _raise_r(_impure_ptr,__sig);
  return iVar1;
}



__sighandler_t signal(int __sig,__sighandler_t __handler)
{
  _sig_func_ptr p_Var1;
  
  p_Var1 = _signal_r(_impure_ptr,__sig,(_sig_func_ptr)__handler);
  return (__sighandler_t)p_Var1;
}



// WARNING: Unknown calling convention

int _init_signal(void)
{
  int iVar1;
  
  if (_impure_ptr->_sig_func != (_func_void_int **)0x0)
  {
    return 0;
  }
  iVar1 = _init_signal_r(_impure_ptr);
  return iVar1;
}



// WARNING: Unknown calling convention

int __sigtramp(int sig)
{
  int iVar1;
  
  iVar1 = __sigtramp_r(_impure_ptr,sig);
  return iVar1;
}



// WARNING: Unknown calling convention

int _kill_r(_reent_conflict *ptr,int pid,int sig)
{
  int iVar1;
  
  errno = 0;
  iVar1 = _kill(pid,sig);
  if ((iVar1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int _getpid_r(_reent_conflict *ptr)
{
  errno = 0x58;
  return -1;
}



// WARNING: Unknown calling convention

int __sread(_reent_conflict *ptr,void *cookie,char *buf,int n)
{
  _ssize_t _Var1;
  
  _Var1 = _read_r(ptr,(int)*(short *)((int)cookie + 0xe),buf,n);
  if (-1 < _Var1)
  {
    *(int *)((int)cookie + 0x54) = *(int *)((int)cookie + 0x54) + _Var1;
    return _Var1;
  }
  *(ushort *)((int)cookie + 0xc) = *(ushort *)((int)cookie + 0xc) & 0xefff;
  return _Var1;
}



// WARNING: Unknown calling convention

int __seofread(_reent_conflict *_ptr,void *cookie,char *buf,int len)
{
  return 0;
}



// WARNING: Unknown calling convention

int __swrite(_reent_conflict *ptr,void *cookie,char *buf,int n)
{
  _ssize_t _Var1;
  int fd;
  ushort uVar2;
  
  uVar2 = *(ushort *)((int)cookie + 0xc);
  fd = (int)*(short *)((int)cookie + 0xe);
  if ((int)(short)uVar2 << 0x17 < 0)
  {
    _lseek_r(ptr,fd,0,2);
    uVar2 = *(ushort *)((int)cookie + 0xc);
    fd = (int)*(short *)((int)cookie + 0xe);
  }
  *(ushort *)((int)cookie + 0xc) = uVar2 & 0xefff;
  _Var1 = _write_r(ptr,fd,buf,n);
  return _Var1;
}



// WARNING: Unknown calling convention

_fpos_t __sseek(_reent_conflict *ptr,void *cookie,_fpos_t offset,int whence)
{
  _off_t _Var1;
  ushort uVar2;
  
  _Var1 = _lseek_r(ptr,(int)*(short *)((int)cookie + 0xe),offset,whence);
  if (_Var1 == -1)
  {
    uVar2 = *(ushort *)((int)cookie + 0xc) & 0xefff;
  }
  else
  {
    uVar2 = *(ushort *)((int)cookie + 0xc) | 0x1000;
  }
  if (_Var1 != -1)
  {
    *(_off_t *)((int)cookie + 0x54) = _Var1;
  }
  *(ushort *)((int)cookie + 0xc) = uVar2;
  return _Var1;
}



// WARNING: Unknown calling convention

int __sclose(_reent_conflict *ptr,void *cookie)
{
  int iVar1;
  
  iVar1 = _close_r(ptr,(int)*(short *)((int)cookie + 0xe));
  return iVar1;
}



// WARNING: Unknown calling convention

_ssize_t _write_r(_reent_conflict *ptr,int fd,void *buf,size_t cnt)
{
  ssize_t sVar1;
  
  errno = 0;
  sVar1 = _write(fd,buf,cnt);
  if ((sVar1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return sVar1;
}



// WARNING: Unknown calling convention

int _close_r(_reent_conflict *ptr,int fd)
{
  int iVar1;
  
  errno = 0;
  iVar1 = _close(fd);
  if ((iVar1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int _fstat_r(_reent_conflict *ptr,int fd,stat *pstat)
{
  int iVar1;
  
  errno = 0;
  iVar1 = _fstat(fd,(stat *)pstat);
  if ((iVar1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int _isatty_r(_reent_conflict *ptr,int fd)
{
  int iVar1;
  
  errno = 0;
  iVar1 = _isatty(fd);
  if ((iVar1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

_off_t _lseek_r(_reent_conflict *ptr,int fd,_off_t pos,int whence)
{
  __off_t _Var1;
  
  errno = 0;
  _Var1 = _lseek(fd,pos,whence);
  if ((_Var1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return _Var1;
}



// WARNING: Unknown calling convention

malloc_size_t _malloc_usable_size_r(_reent_conflict *reent_ptr,void *ptr)
{
  malloc_size_t mVar1;
  
  mVar1 = *(int *)((int)ptr + -4) - 4;
  if (*(int *)((int)ptr + -4) < 0)
  {
    mVar1 += *(int *)((int)ptr + mVar1);
  }
  return mVar1;
}



// WARNING: Unknown calling convention

_ssize_t _read_r(_reent_conflict *ptr,int fd,void *buf,size_t cnt)
{
  ssize_t sVar1;
  
  errno = 0;
  sVar1 = _read(fd,buf,cnt);
  if ((sVar1 == -1) && (errno != 0))
  {
    ptr->_errno = errno;
    return -1;
  }
  return sVar1;
}



int _close(int __fd)
{
  errno = 0x58;
  return -1;
}



int _fstat(int __fd,stat *__buf)
{
  errno = 0x58;
  return -1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t _getpid(void)
{
  errno = 0x58;
  return -1;
}



int _isatty(int __fd)
{
  errno = 0x58;
  return 0;
}



int _kill(__pid_t __pid,int __sig)
{
  errno = 0x58;
  return -1;
}



__off_t _lseek(int __fd,__off_t __offset,int __whence)
{
  errno = 0x58;
  return -1;
}



ssize_t _read(int __fd,void *__buf,size_t __nbytes)
{
  errno = 0x58;
  return -1;
}



void * _sbrk(intptr_t __delta)
{
  char *pcVar1;
  
  pcVar1 = _sbrk::heap_end;
  if (_sbrk::heap_end == (char *)0x0)
  {
    pcVar1 = &__HeapBase;
  }
  _sbrk::heap_end = pcVar1 + __delta;
  return pcVar1;
}



ssize_t _write(int __fd,void *__buf,size_t __n)
{
  errno = 0x58;
  return -1;
}



void _exit(int __status)
{
  do
  {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



ulonglong __aeabi_drsub(uint param_1,uint param_2,uint param_3,uint param_4)
{
  ulonglong uVar1;
  
  uVar1 = __aeabi_dadd(param_1,param_2 ^ 0x80000000,param_3,param_4);
  return uVar1;
}



ulonglong __subdf3(uint param_1,uint param_2,uint param_3,uint param_4)
{
  int iVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  bool bVar14;
  bool bVar15;
  bool bVar16;
  
  uVar7 = param_4 ^ 0x80000000;
  uVar9 = param_2 << 1;
  uVar11 = param_4 << 1;
  bVar14 = ((param_2 ^ uVar7) & 0x7fffffff) == 0;
  bVar15 = bVar14 && param_1 == param_3;
  if (!bVar14 || param_1 != param_3)
  {
    bVar15 = uVar9 == 0 && param_1 == 0;
  }
  if (!bVar15)
  {
    bVar15 = uVar11 == 0 && param_3 == 0;
  }
  iVar8 = (int)uVar9 >> 0x15;
  if (!bVar15)
  {
    bVar15 = iVar8 == -1;
  }
  iVar1 = (int)uVar11 >> 0x15;
  if (!bVar15)
  {
    bVar15 = iVar1 == -1;
  }
  if (bVar15)
  {
    if (iVar8 == -1 || iVar1 == -1)
    {
      uVar11 = uVar7;
      uVar9 = param_3;
      if (iVar8 == -1)
      {
        uVar11 = param_2;
        uVar9 = param_1;
      }
      if (iVar8 != -1 || iVar1 != -1)
      {
        param_3 = uVar9;
        uVar7 = uVar11;
      }
      bVar15 = (uVar11 & 0xfffff) == 0;
      bVar14 = uVar9 == 0 && bVar15;
      if (uVar9 == 0 && bVar15)
      {
        bVar14 = param_3 == 0 && (uVar7 & 0xfffff) == 0;
      }
      if (bVar14)
      {
        bVar14 = uVar11 == uVar7;
      }
      if (!bVar14)
      {
        uVar11 |= 0x80000;
      }
      return CONCAT44(uVar11,uVar9);
    }
    if (((param_2 ^ uVar7) & 0x7fffffff) != 0 || param_1 != param_3)
    {
      if (uVar9 == 0 && param_1 == 0)
      {
        param_1 = param_3;
        param_2 = uVar7;
      }
      return CONCAT44(param_2,param_1);
    }
    if (param_2 != uVar7)
    {
      return 0;
    }
    if (uVar9 >> 0x15 == 0)
    {
      bVar15 = (param_1 & 0x80000000) != 0;
      uVar11 = param_2 * 2 + (uint)bVar15;
      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar15))
      {
        uVar11 |= 0x80000000;
      }
      return CONCAT44(uVar11,param_1 << 1);
    }
    if (uVar9 < 0xffc00000)
    {
      return CONCAT44(param_2 + 0x100000,param_1);
    }
    uVar11 = param_2 & 0x80000000;
LAB_08002cac:
    return (ulonglong)(uVar11 | 0x7ff00000) << 0x20;
  }
  uVar9 >>= 0x15;
  uVar11 >>= 0x15;
  uVar12 = uVar11 - uVar9;
  bVar15 = uVar12 != 0;
  if (uVar11 < uVar9)
  {
    uVar12 = -uVar12;
  }
  uVar10 = param_1;
  uVar13 = param_2;
  if (bVar15 && uVar9 <= uVar11)
  {
    uVar9 += uVar12;
    uVar10 = param_3;
    uVar13 = uVar7;
    param_3 = param_1;
    uVar7 = param_2;
  }
  if (0x36 < uVar12)
  {
    return CONCAT44(uVar13,uVar10);
  }
  uVar4 = uVar13 & 0xfffff | 0x100000;
  if ((uVar13 & 0x80000000) != 0)
  {
    bVar15 = uVar10 != 0;
    uVar10 = -uVar10;
    uVar4 = -uVar4 - (uint)bVar15;
  }
  uVar11 = uVar7 & 0xfffff | 0x100000;
  if ((uVar7 & 0x80000000) != 0)
  {
    bVar15 = param_3 != 0;
    param_3 = -param_3;
    uVar11 = -uVar11 - (uint)bVar15;
  }
  if (uVar9 == uVar12)
  {
    uVar11 ^= 0x100000;
    if (uVar9 == 0)
    {
      uVar4 ^= 0x100000;
      uVar9 = 1;
    }
    else
    {
      uVar12 -= 1;
    }
  }
  uVar7 = -uVar12 + 0x20;
  if ((int)uVar12 < 0x21)
  {
    uVar13 = param_3 << (uVar7 & 0xff);
    uVar5 = param_3 >> (uVar12 & 0xff);
    uVar3 = uVar10 + uVar5;
    uVar6 = uVar11 << (uVar7 & 0xff);
    uVar7 = uVar3 + uVar6;
    uVar4 = uVar4 + CARRY4(uVar10,uVar5) + ((int)uVar11 >> (uVar12 & 0xff)) +
            (uint)CARRY4(uVar3,uVar6);
  }
  else
  {
    uVar13 = uVar11 << (-uVar12 + 0x40 & 0xff);
    if (param_3 != 0)
    {
      uVar13 |= 2;
    }
    uVar11 = (int)uVar11 >> (uVar12 - 0x20 & 0xff);
    uVar7 = uVar10 + uVar11;
    uVar4 += ((int)uVar11 >> 0x1f) + (uint)CARRY4(uVar10,uVar11);
  }
  uVar11 = uVar4 & 0x80000000;
  uVar12 = uVar4;
  if ((int)uVar4 < 0)
  {
    bVar15 = uVar13 == 0;
    uVar13 = -uVar13;
    uVar12 = -uVar7;
    uVar7 = -(uint)!bVar15 - uVar7;
    uVar12 = -(uint)(bVar15 <= uVar12) - uVar4;
  }
  if (0xfffff < uVar12)
  {
    uVar10 = uVar9 - 1;
    if (0x1fffff < uVar12)
    {
      uVar10 = uVar12 & 1;
      uVar12 >>= 1;
      bVar2 = (byte)uVar7;
      uVar7 = (uint)(uVar10 != 0) << 0x1f | uVar7 >> 1;
      uVar13 = (uint)(bVar2 & 1) << 0x1f | uVar13 >> 1;
      uVar10 = uVar9;
      if (0xffbfffff < uVar9 * 0x200000) goto LAB_08002cac;
    }
LAB_08002b78:
    bVar15 = 0x7fffffff < uVar13;
    if (uVar13 == 0x80000000)
    {
      bVar15 = (uVar7 & 1) != 0;
    }
    return CONCAT44(uVar12 + uVar10 * 0x100000 + (uint)CARRY4(uVar7,(uint)bVar15) | uVar11,
                    uVar7 + bVar15);
  }
  bVar14 = (uVar13 & 0x80000000) != 0;
  uVar13 <<= 1;
  uVar10 = uVar7 * 2;
  bVar15 = CARRY4(uVar7,uVar7);
  uVar7 = uVar7 * 2 + (uint)bVar14;
  uVar12 = uVar12 * 2 + (uint)(bVar15 || CARRY4(uVar10,(uint)bVar14));
  uVar10 = uVar9 - 2;
  if (uVar9 - 1 != 0 && 0xfffff < uVar12) goto LAB_08002b78;
  uVar3 = uVar7;
  uVar9 = uVar12;
  if (uVar12 == 0)
  {
    uVar3 = 0;
    uVar9 = uVar7;
  }
  iVar8 = LZCOUNT(uVar9);
  if (uVar12 == 0)
  {
    iVar8 += 0x20;
  }
  uVar12 = iVar8 - 0xb;
  bVar16 = SBORROW4(uVar12,0x20);
  uVar7 = iVar8 - 0x2b;
  bVar15 = (int)uVar7 < 0;
  bVar14 = uVar7 == 0;
  if ((int)uVar12 < 0x20)
  {
    bVar16 = SCARRY4(uVar7,0xc);
    iVar8 += -0x1f;
    bVar15 = iVar8 < 0;
    bVar14 = iVar8 == 0;
    uVar7 = uVar12;
    if (!bVar14 && bVar15 == bVar16)
    {
      uVar3 = uVar9 << (uVar12 & 0xff);
      uVar9 >>= 0xcU - iVar8 & 0xff;
      goto LAB_08002bf0;
    }
  }
  if (bVar14 || bVar15 != bVar16)
  {
    uVar13 = 0x20 - uVar7;
  }
  uVar9 <<= uVar7 & 0xff;
  if (bVar14 || bVar15 != bVar16)
  {
    uVar9 |= uVar3 >> (uVar13 & 0xff);
    uVar3 <<= uVar7 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar12 <= (int)uVar10)
  {
    return CONCAT44(uVar9 + (uVar10 - uVar12) * 0x100000 | uVar11,uVar3);
  }
  uVar7 = ~(uVar10 - uVar12);
  if ((int)uVar7 < 0x1f)
  {
    iVar8 = uVar7 - 0x13;
    if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar7 - 0x1f,0xc))
    {
      return CONCAT44(uVar4,uVar3 >> (0x20 - (0xcU - iVar8) & 0xff) | uVar9 << (0xcU - iVar8 & 0xff)
                     ) & 0x80000000ffffffff;
    }
    uVar7 += 1;
    return CONCAT44(uVar11 | uVar9 >> (uVar7 & 0xff),
                    uVar3 >> (uVar7 & 0xff) | uVar9 << (0x20 - uVar7 & 0xff));
  }
  return CONCAT44(uVar4,uVar9 >> (uVar7 - 0x1f & 0xff)) & 0x80000000ffffffff;
}



ulonglong __aeabi_dadd(uint param_1,uint param_2,uint param_3,uint param_4)
{
  int iVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  bool bVar14;
  bool bVar15;
  bool bVar16;
  
  uVar8 = param_2 << 1;
  uVar10 = param_4 << 1;
  bVar14 = ((param_2 ^ param_4) & 0x7fffffff) == 0;
  bVar15 = bVar14 && param_1 == param_3;
  if (!bVar14 || param_1 != param_3)
  {
    bVar15 = uVar8 == 0 && param_1 == 0;
  }
  if (!bVar15)
  {
    bVar15 = uVar10 == 0 && param_3 == 0;
  }
  iVar7 = (int)uVar8 >> 0x15;
  if (!bVar15)
  {
    bVar15 = iVar7 == -1;
  }
  iVar1 = (int)uVar10 >> 0x15;
  if (!bVar15)
  {
    bVar15 = iVar1 == -1;
  }
  if (bVar15)
  {
    if (iVar7 == -1 || iVar1 == -1)
    {
      uVar10 = param_4;
      uVar8 = param_3;
      if (iVar7 == -1)
      {
        uVar10 = param_2;
        uVar8 = param_1;
      }
      if (iVar7 != -1 || iVar1 != -1)
      {
        param_3 = uVar8;
        param_4 = uVar10;
      }
      bVar15 = (uVar10 & 0xfffff) == 0;
      bVar14 = uVar8 == 0 && bVar15;
      if (uVar8 == 0 && bVar15)
      {
        bVar14 = param_3 == 0 && (param_4 & 0xfffff) == 0;
      }
      if (bVar14)
      {
        bVar14 = uVar10 == param_4;
      }
      if (!bVar14)
      {
        uVar10 |= 0x80000;
      }
      return CONCAT44(uVar10,uVar8);
    }
    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3)
    {
      if (uVar8 == 0 && param_1 == 0)
      {
        param_1 = param_3;
        param_2 = param_4;
      }
      return CONCAT44(param_2,param_1);
    }
    if (param_2 != param_4)
    {
      return 0;
    }
    if (uVar8 >> 0x15 == 0)
    {
      bVar15 = (param_1 & 0x80000000) != 0;
      uVar10 = param_2 * 2 + (uint)bVar15;
      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar15))
      {
        uVar10 |= 0x80000000;
      }
      return CONCAT44(uVar10,param_1 << 1);
    }
    if (uVar8 < 0xffc00000)
    {
      return CONCAT44(param_2 + 0x100000,param_1);
    }
    uVar10 = param_2 & 0x80000000;
LAB_08002cac:
    return (ulonglong)(uVar10 | 0x7ff00000) << 0x20;
  }
  uVar8 >>= 0x15;
  uVar10 >>= 0x15;
  uVar11 = uVar10 - uVar8;
  bVar15 = uVar11 != 0;
  if (uVar10 < uVar8)
  {
    uVar11 = -uVar11;
  }
  uVar9 = param_1;
  uVar13 = param_2;
  if (bVar15 && uVar8 <= uVar10)
  {
    uVar8 += uVar11;
    uVar9 = param_3;
    uVar13 = param_4;
    param_3 = param_1;
    param_4 = param_2;
  }
  if (0x36 < uVar11)
  {
    return CONCAT44(uVar13,uVar9);
  }
  uVar4 = uVar13 & 0xfffff | 0x100000;
  if ((uVar13 & 0x80000000) != 0)
  {
    bVar15 = uVar9 != 0;
    uVar9 = -uVar9;
    uVar4 = -uVar4 - (uint)bVar15;
  }
  uVar10 = param_4 & 0xfffff | 0x100000;
  if ((param_4 & 0x80000000) != 0)
  {
    bVar15 = param_3 != 0;
    param_3 = -param_3;
    uVar10 = -uVar10 - (uint)bVar15;
  }
  if (uVar8 == uVar11)
  {
    uVar10 ^= 0x100000;
    if (uVar8 == 0)
    {
      uVar4 ^= 0x100000;
      uVar8 = 1;
    }
    else
    {
      uVar11 -= 1;
    }
  }
  uVar13 = -uVar11 + 0x20;
  if ((int)uVar11 < 0x21)
  {
    uVar12 = param_3 << (uVar13 & 0xff);
    uVar5 = param_3 >> (uVar11 & 0xff);
    uVar3 = uVar9 + uVar5;
    uVar6 = uVar10 << (uVar13 & 0xff);
    uVar13 = uVar3 + uVar6;
    uVar4 = uVar4 + CARRY4(uVar9,uVar5) + ((int)uVar10 >> (uVar11 & 0xff)) +
            (uint)CARRY4(uVar3,uVar6);
  }
  else
  {
    uVar12 = uVar10 << (-uVar11 + 0x40 & 0xff);
    if (param_3 != 0)
    {
      uVar12 |= 2;
    }
    uVar10 = (int)uVar10 >> (uVar11 - 0x20 & 0xff);
    uVar13 = uVar9 + uVar10;
    uVar4 += ((int)uVar10 >> 0x1f) + (uint)CARRY4(uVar9,uVar10);
  }
  uVar10 = uVar4 & 0x80000000;
  uVar11 = uVar4;
  if ((int)uVar4 < 0)
  {
    bVar15 = uVar12 == 0;
    uVar12 = -uVar12;
    uVar11 = -uVar13;
    uVar13 = -(uint)!bVar15 - uVar13;
    uVar11 = -(uint)(bVar15 <= uVar11) - uVar4;
  }
  if (0xfffff < uVar11)
  {
    uVar9 = uVar8 - 1;
    if (0x1fffff < uVar11)
    {
      uVar9 = uVar11 & 1;
      uVar11 >>= 1;
      bVar2 = (byte)uVar13;
      uVar13 = (uint)(uVar9 != 0) << 0x1f | uVar13 >> 1;
      uVar12 = (uint)(bVar2 & 1) << 0x1f | uVar12 >> 1;
      uVar9 = uVar8;
      if (0xffbfffff < uVar8 * 0x200000) goto LAB_08002cac;
    }
LAB_08002b78:
    bVar15 = 0x7fffffff < uVar12;
    if (uVar12 == 0x80000000)
    {
      bVar15 = (uVar13 & 1) != 0;
    }
    return CONCAT44(uVar11 + uVar9 * 0x100000 + (uint)CARRY4(uVar13,(uint)bVar15) | uVar10,
                    uVar13 + bVar15);
  }
  bVar14 = (uVar12 & 0x80000000) != 0;
  uVar12 <<= 1;
  uVar9 = uVar13 * 2;
  bVar15 = CARRY4(uVar13,uVar13);
  uVar13 = uVar13 * 2 + (uint)bVar14;
  uVar11 = uVar11 * 2 + (uint)(bVar15 || CARRY4(uVar9,(uint)bVar14));
  uVar9 = uVar8 - 2;
  if (uVar8 - 1 != 0 && 0xfffff < uVar11) goto LAB_08002b78;
  uVar3 = uVar13;
  uVar8 = uVar11;
  if (uVar11 == 0)
  {
    uVar3 = 0;
    uVar8 = uVar13;
  }
  iVar7 = LZCOUNT(uVar8);
  if (uVar11 == 0)
  {
    iVar7 += 0x20;
  }
  uVar13 = iVar7 - 0xb;
  bVar16 = SBORROW4(uVar13,0x20);
  uVar11 = iVar7 - 0x2b;
  bVar15 = (int)uVar11 < 0;
  bVar14 = uVar11 == 0;
  if ((int)uVar13 < 0x20)
  {
    bVar16 = SCARRY4(uVar11,0xc);
    iVar7 += -0x1f;
    bVar15 = iVar7 < 0;
    bVar14 = iVar7 == 0;
    uVar11 = uVar13;
    if (!bVar14 && bVar15 == bVar16)
    {
      uVar3 = uVar8 << (uVar13 & 0xff);
      uVar8 >>= 0xcU - iVar7 & 0xff;
      goto LAB_08002bf0;
    }
  }
  if (bVar14 || bVar15 != bVar16)
  {
    uVar12 = 0x20 - uVar11;
  }
  uVar8 <<= uVar11 & 0xff;
  if (bVar14 || bVar15 != bVar16)
  {
    uVar8 |= uVar3 >> (uVar12 & 0xff);
    uVar3 <<= uVar11 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar13 <= (int)uVar9)
  {
    return CONCAT44(uVar8 + (uVar9 - uVar13) * 0x100000 | uVar10,uVar3);
  }
  uVar11 = ~(uVar9 - uVar13);
  if ((int)uVar11 < 0x1f)
  {
    iVar7 = uVar11 - 0x13;
    if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar11 - 0x1f,0xc))
    {
      return CONCAT44(uVar4,uVar3 >> (0x20 - (0xcU - iVar7) & 0xff) | uVar8 << (0xcU - iVar7 & 0xff)
                     ) & 0x80000000ffffffff;
    }
    uVar11 += 1;
    return CONCAT44(uVar10 | uVar8 >> (uVar11 & 0xff),
                    uVar3 >> (uVar11 & 0xff) | uVar8 << (0x20 - uVar11 & 0xff));
  }
  return CONCAT44(uVar4,uVar8 >> (uVar11 - 0x1f & 0xff)) & 0x80000000ffffffff;
}



ulonglong __floatunsidf(uint param_1)
{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint in_r12;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  
  if (param_1 == 0)
  {
    return 0;
  }
  uVar1 = 0;
  if (true)
  {
    uVar1 = param_1;
  }
  if (true)
  {
    param_1 = 0;
  }
  iVar3 = LZCOUNT(uVar1);
  if (true)
  {
    iVar3 += 0x20;
  }
  uVar4 = iVar3 - 0xb;
  bVar7 = SBORROW4(uVar4,0x20);
  uVar2 = iVar3 - 0x2b;
  bVar5 = (int)uVar2 < 0;
  bVar6 = uVar2 == 0;
  if ((int)uVar4 < 0x20)
  {
    bVar7 = SCARRY4(uVar2,0xc);
    iVar3 += -0x1f;
    bVar5 = iVar3 < 0;
    bVar6 = iVar3 == 0;
    uVar2 = uVar4;
    if (!bVar6 && bVar5 == bVar7)
    {
      param_1 = uVar1 << (uVar4 & 0xff);
      uVar1 >>= 0xcU - iVar3 & 0xff;
      goto LAB_08002bf0;
    }
  }
  if (bVar6 || bVar5 != bVar7)
  {
    in_r12 = 0x20 - uVar2;
  }
  uVar1 <<= uVar2 & 0xff;
  if (bVar6 || bVar5 != bVar7)
  {
    uVar1 |= param_1 >> (in_r12 & 0xff);
    param_1 <<= uVar2 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar4 < 0x433)
  {
    return CONCAT44(uVar1 + (0x432 - uVar4) * 0x100000,param_1);
  }
  uVar2 = ~(0x432 - uVar4);
  if (0x1e < (int)uVar2)
  {
    return (ulonglong)(uVar1 >> (uVar2 - 0x1f & 0xff));
  }
  iVar3 = uVar2 - 0x13;
  if (iVar3 == 0 || iVar3 < 0 != SCARRY4(uVar2 - 0x1f,0xc))
  {
    uVar2 += 1;
    return CONCAT44(uVar1 >> (uVar2 & 0xff),
                    param_1 >> (uVar2 & 0xff) | uVar1 << (0x20 - uVar2 & 0xff));
  }
  return (ulonglong)(param_1 >> (0x20 - (0xcU - iVar3) & 0xff) | uVar1 << (0xcU - iVar3 & 0xff));
}



ulonglong __aeabi_i2d(uint param_1)
{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint in_r12;
  bool bVar7;
  bool bVar8;
  bool bVar9;
  
  if (param_1 == 0)
  {
    return 0;
  }
  uVar6 = param_1 & 0x80000000;
  uVar1 = param_1;
  if ((int)uVar6 < 0)
  {
    uVar1 = -param_1;
  }
  uVar2 = 0;
  if (true)
  {
    uVar2 = uVar1;
  }
  if (true)
  {
    uVar1 = 0;
  }
  iVar4 = LZCOUNT(uVar2);
  if (true)
  {
    iVar4 += 0x20;
  }
  uVar5 = iVar4 - 0xb;
  bVar9 = SBORROW4(uVar5,0x20);
  uVar3 = iVar4 - 0x2b;
  bVar7 = (int)uVar3 < 0;
  bVar8 = uVar3 == 0;
  if ((int)uVar5 < 0x20)
  {
    bVar9 = SCARRY4(uVar3,0xc);
    iVar4 += -0x1f;
    bVar7 = iVar4 < 0;
    bVar8 = iVar4 == 0;
    uVar3 = uVar5;
    if (!bVar8 && bVar7 == bVar9)
    {
      uVar1 = uVar2 << (uVar5 & 0xff);
      uVar2 >>= 0xcU - iVar4 & 0xff;
      goto LAB_08002bf0;
    }
  }
  if (bVar8 || bVar7 != bVar9)
  {
    in_r12 = 0x20 - uVar3;
  }
  uVar2 <<= uVar3 & 0xff;
  if (bVar8 || bVar7 != bVar9)
  {
    uVar2 |= uVar1 >> (in_r12 & 0xff);
    uVar1 <<= uVar3 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar5 < 0x433)
  {
    return CONCAT44(uVar2 + (0x432 - uVar5) * 0x100000 | uVar6,uVar1);
  }
  uVar3 = ~(0x432 - uVar5);
  if (0x1e < (int)uVar3)
  {
    return CONCAT44(param_1,uVar2 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;
  }
  iVar4 = uVar3 - 0x13;
  if (iVar4 == 0 || iVar4 < 0 != SCARRY4(uVar3 - 0x1f,0xc))
  {
    uVar3 += 1;
    return CONCAT44(uVar6 | uVar2 >> (uVar3 & 0xff),
                    uVar1 >> (uVar3 & 0xff) | uVar2 << (0x20 - uVar3 & 0xff));
  }
  return CONCAT44(param_1,uVar1 >> (0x20 - (0xcU - iVar4) & 0xff) | uVar2 << (0xcU - iVar4 & 0xff))
         & 0x80000000ffffffff;
}



ulonglong __aeabi_f2d(uint param_1,undefined4 param_2,undefined4 param_3,uint param_4)
{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint in_r12;
  bool bVar8;
  bool bVar9;
  bool bVar10;
  
  uVar6 = param_1 << 1;
  bVar9 = uVar6 == 0;
  uVar1 = (uint)((param_1 & 0x80000000) != 0) << 0x1f;
  uVar5 = (uint)((int)uVar6 >> 3) >> 1;
  uVar4 = uVar1 | uVar5;
  uVar3 = param_1 << 0x1d;
  if (!bVar9)
  {
    param_4 = uVar6 & 0xff000000;
    bVar9 = param_4 == 0;
  }
  if (!bVar9)
  {
    bVar9 = param_4 == 0xff000000;
  }
  if (!bVar9)
  {
    return CONCAT44(uVar4,uVar3) ^ 0x3800000000000000;
  }
  if ((uVar6 & 0xffffff) == 0)
  {
    return CONCAT44(uVar4,uVar3);
  }
  if (param_4 == 0xff000000)
  {
    return CONCAT44(uVar4,uVar3) | 0x8000000000000;
  }
  uVar2 = uVar3;
  uVar6 = uVar5;
  if (uVar5 == 0)
  {
    uVar2 = 0;
    uVar6 = uVar3;
  }
  iVar7 = LZCOUNT(uVar6);
  if (uVar5 == 0)
  {
    iVar7 += 0x20;
  }
  uVar3 = iVar7 - 0xb;
  bVar10 = SBORROW4(uVar3,0x20);
  uVar5 = iVar7 - 0x2b;
  bVar9 = (int)uVar5 < 0;
  bVar8 = uVar5 == 0;
  if ((int)uVar3 < 0x20)
  {
    bVar10 = SCARRY4(uVar5,0xc);
    iVar7 += -0x1f;
    bVar9 = iVar7 < 0;
    bVar8 = iVar7 == 0;
    uVar5 = uVar3;
    if (!bVar8 && bVar9 == bVar10)
    {
      uVar2 = uVar6 << (uVar3 & 0xff);
      uVar6 >>= 0xcU - iVar7 & 0xff;
      goto LAB_08002bf0;
    }
  }
  if (bVar8 || bVar9 != bVar10)
  {
    in_r12 = 0x20 - uVar5;
  }
  uVar6 <<= uVar5 & 0xff;
  if (bVar8 || bVar9 != bVar10)
  {
    uVar6 |= uVar2 >> (in_r12 & 0xff);
    uVar2 <<= uVar5 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar3 < 0x381)
  {
    return CONCAT44(uVar6 + (0x380 - uVar3) * 0x100000 | uVar1,uVar2);
  }
  uVar5 = ~(0x380 - uVar3);
  if (0x1e < (int)uVar5)
  {
    return CONCAT44(uVar4,uVar6 >> (uVar5 - 0x1f & 0xff)) & 0x80000000ffffffff;
  }
  iVar7 = uVar5 - 0x13;
  if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar5 - 0x1f,0xc))
  {
    uVar5 += 1;
    return CONCAT44(uVar1 | uVar6 >> (uVar5 & 0xff),
                    uVar2 >> (uVar5 & 0xff) | uVar6 << (0x20 - uVar5 & 0xff));
  }
  return CONCAT44(uVar4,uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) | uVar6 << (0xcU - iVar7 & 0xff)) &
         0x80000000ffffffff;
}



ulonglong __floatundidf(uint param_1,uint param_2)
{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  bool bVar9;
  bool bVar10;
  bool bVar11;
  
  if (param_1 == 0 && param_2 == 0)
  {
    return CONCAT44(param_2,param_1);
  }
  iVar7 = 0x432;
  uVar8 = param_2 >> 0x16;
  if (uVar8 != 0)
  {
    iVar7 = 3;
    if (param_2 >> 0x19 != 0)
    {
      iVar7 = 6;
    }
    if (param_2 >> 0x1c != 0)
    {
      iVar7 += 3;
    }
    uVar4 = iVar7 - ((int)param_2 >> 0x1f);
    uVar8 = param_1 << (0x20 - uVar4 & 0xff);
    param_1 = param_1 >> (uVar4 & 0xff) | param_2 << (0x20 - uVar4 & 0xff);
    param_2 >>= uVar4 & 0xff;
    iVar7 = uVar4 + 0x432;
  }
  if (0xfffff < param_2)
  {
    if (0x1fffff < param_2)
    {
      uVar4 = param_2 & 1;
      param_2 >>= 1;
      bVar1 = (byte)param_1;
      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;
      uVar8 = (uint)(bVar1 & 1) << 0x1f | uVar8 >> 1;
      iVar7 += 1;
      if (0xffbfffff < (uint)(iVar7 * 0x200000))
      {
        return 0x7ff0000000000000;
      }
    }
LAB_08002b78:
    bVar10 = 0x7fffffff < uVar8;
    if (uVar8 == 0x80000000)
    {
      bVar10 = (param_1 & 1) != 0;
    }
    return CONCAT44(param_2 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar10),param_1 + bVar10
                   );
  }
  bVar9 = (uVar8 & 0x80000000) != 0;
  uVar8 <<= 1;
  uVar4 = param_1 * 2;
  bVar10 = CARRY4(param_1,param_1);
  param_1 = param_1 * 2 + (uint)bVar9;
  param_2 = param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4,(uint)bVar9));
  bVar10 = iVar7 != 0;
  iVar7 += -1;
  if (bVar10 && 0xfffff < param_2) goto LAB_08002b78;
  bVar10 = param_2 == 0;
  uVar4 = param_1;
  if (bVar10)
  {
    uVar4 = 0;
    param_2 = param_1;
  }
  iVar5 = LZCOUNT(param_2);
  if (bVar10)
  {
    iVar5 += 0x20;
  }
  uVar6 = iVar5 - 0xb;
  bVar11 = SBORROW4(uVar6,0x20);
  uVar3 = iVar5 - 0x2b;
  bVar10 = (int)uVar3 < 0;
  bVar9 = uVar3 == 0;
  if ((int)uVar6 < 0x20)
  {
    bVar11 = SCARRY4(uVar3,0xc);
    iVar5 += -0x1f;
    bVar10 = iVar5 < 0;
    bVar9 = iVar5 == 0;
    uVar3 = uVar6;
    if (!bVar9 && bVar10 == bVar11)
    {
      uVar4 = param_2 << (uVar6 & 0xff);
      uVar2 = param_2 >> (0xcU - iVar5 & 0xff);
      goto LAB_08002bf0;
    }
  }
  if (bVar9 || bVar10 != bVar11)
  {
    uVar8 = 0x20 - uVar3;
  }
  uVar2 = param_2 << (uVar3 & 0xff);
  if (bVar9 || bVar10 != bVar11)
  {
    uVar2 |= uVar4 >> (uVar8 & 0xff);
    uVar4 <<= uVar3 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar6 <= iVar7)
  {
    return CONCAT44(uVar2 + (iVar7 - uVar6) * 0x100000,uVar4);
  }
  uVar8 = ~(iVar7 - uVar6);
  if ((int)uVar8 < 0x1f)
  {
    iVar7 = uVar8 - 0x13;
    if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar8 - 0x1f,0xc))
    {
      return (ulonglong)(uVar4 >> (0x20 - (0xcU - iVar7) & 0xff) | uVar2 << (0xcU - iVar7 & 0xff));
    }
    uVar8 += 1;
    return CONCAT44(uVar2 >> (uVar8 & 0xff),uVar4 >> (uVar8 & 0xff) | uVar2 << (0x20 - uVar8 & 0xff)
                   );
  }
  return (ulonglong)(uVar2 >> (uVar8 - 0x1f & 0xff));
}



ulonglong __aeabi_l2d(uint param_1,uint param_2)
{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  bool bVar10;
  bool bVar11;
  bool bVar12;
  
  if (param_1 == 0 && param_2 == 0)
  {
    return CONCAT44(param_2,param_1);
  }
  uVar8 = param_2 & 0x80000000;
  uVar3 = param_2;
  if ((int)uVar8 < 0)
  {
    bVar11 = param_1 != 0;
    param_1 = -param_1;
    uVar3 = -param_2 - (uint)bVar11;
  }
  iVar7 = 0x432;
  uVar9 = uVar3 >> 0x16;
  if (uVar9 != 0)
  {
    iVar7 = 3;
    if (uVar3 >> 0x19 != 0)
    {
      iVar7 = 6;
    }
    if (uVar3 >> 0x1c != 0)
    {
      iVar7 += 3;
    }
    uVar4 = iVar7 - ((int)uVar3 >> 0x1f);
    uVar9 = param_1 << (0x20 - uVar4 & 0xff);
    param_1 = param_1 >> (uVar4 & 0xff) | uVar3 << (0x20 - uVar4 & 0xff);
    uVar3 >>= uVar4 & 0xff;
    iVar7 = uVar4 + 0x432;
  }
  if (0xfffff < uVar3)
  {
    if (0x1fffff < uVar3)
    {
      uVar4 = uVar3 & 1;
      uVar3 >>= 1;
      bVar1 = (byte)param_1;
      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;
      uVar9 = (uint)(bVar1 & 1) << 0x1f | uVar9 >> 1;
      iVar7 += 1;
      if (0xffbfffff < (uint)(iVar7 * 0x200000))
      {
        return (ulonglong)(uVar8 | 0x7ff00000) << 0x20;
      }
    }
LAB_08002b78:
    bVar11 = 0x7fffffff < uVar9;
    if (uVar9 == 0x80000000)
    {
      bVar11 = (param_1 & 1) != 0;
    }
    return CONCAT44(uVar3 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar11) | uVar8,
                    param_1 + bVar11);
  }
  bVar10 = (uVar9 & 0x80000000) != 0;
  uVar9 <<= 1;
  uVar4 = param_1 * 2;
  bVar11 = CARRY4(param_1,param_1);
  param_1 = param_1 * 2 + (uint)bVar10;
  uVar3 = uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4,(uint)bVar10));
  bVar11 = iVar7 != 0;
  iVar7 += -1;
  if (bVar11 && 0xfffff < uVar3) goto LAB_08002b78;
  uVar2 = param_1;
  uVar4 = uVar3;
  if (uVar3 == 0)
  {
    uVar2 = 0;
    uVar4 = param_1;
  }
  iVar5 = LZCOUNT(uVar4);
  if (uVar3 == 0)
  {
    iVar5 += 0x20;
  }
  uVar6 = iVar5 - 0xb;
  bVar12 = SBORROW4(uVar6,0x20);
  uVar3 = iVar5 - 0x2b;
  bVar11 = (int)uVar3 < 0;
  bVar10 = uVar3 == 0;
  if ((int)uVar6 < 0x20)
  {
    bVar12 = SCARRY4(uVar3,0xc);
    iVar5 += -0x1f;
    bVar11 = iVar5 < 0;
    bVar10 = iVar5 == 0;
    uVar3 = uVar6;
    if (!bVar10 && bVar11 == bVar12)
    {
      uVar2 = uVar4 << (uVar6 & 0xff);
      uVar4 >>= 0xcU - iVar5 & 0xff;
      goto LAB_08002bf0;
    }
  }
  if (bVar10 || bVar11 != bVar12)
  {
    uVar9 = 0x20 - uVar3;
  }
  uVar4 <<= uVar3 & 0xff;
  if (bVar10 || bVar11 != bVar12)
  {
    uVar4 |= uVar2 >> (uVar9 & 0xff);
    uVar2 <<= uVar3 & 0xff;
  }
LAB_08002bf0:
  if ((int)uVar6 <= iVar7)
  {
    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8,uVar2);
  }
  uVar3 = ~(iVar7 - uVar6);
  if ((int)uVar3 < 0x1f)
  {
    iVar7 = uVar3 - 0x13;
    if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar3 - 0x1f,0xc))
    {
      return CONCAT44(param_2,uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |
                              uVar4 << (0xcU - iVar7 & 0xff)) & 0x80000000ffffffff;
    }
    uVar3 += 1;
    return CONCAT44(uVar8 | uVar4 >> (uVar3 & 0xff),
                    uVar2 >> (uVar3 & 0xff) | uVar4 << (0x20 - uVar3 & 0xff));
  }
  return CONCAT44(param_2,uVar4 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;
}



ulonglong __muldf3(uint param_1,uint param_2,uint param_3,uint param_4)
{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  uint uVar4;
  uint extraout_r2;
  uint extraout_r3;
  uint uVar5;
  int iVar6;
  uint uVar7;
  uint unaff_r5;
  uint uVar8;
  uint uVar9;
  uint extraout_r12;
  uint uVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  ulonglong uVar14;
  
  uVar14 = CONCAT44(param_2,param_1);
  uVar9 = 0x7ff;
  uVar5 = param_2 >> 0x14 & 0x7ff;
  bVar11 = uVar5 == 0;
  if (!bVar11)
  {
    unaff_r5 = param_4 >> 0x14 & 0x7ff;
    bVar11 = unaff_r5 == 0;
  }
  if (!bVar11)
  {
    bVar11 = uVar5 == 0x7ff;
  }
  if (!bVar11)
  {
    bVar11 = unaff_r5 == 0x7ff;
  }
  if (bVar11)
  {
    uVar14 = FUN_08002fb4(param_1,param_2,param_3,param_4);
    param_3 = extraout_r2;
    param_4 = extraout_r3;
    uVar9 = extraout_r12;
  }
  uVar4 = (uint)(uVar14 >> 0x20);
  uVar3 = (uint)uVar14;
  iVar6 = uVar5 + unaff_r5;
  uVar8 = uVar4 ^ param_4;
  uVar4 &= ~(uVar9 << 0x15);
  uVar5 = param_4 & ~(uVar9 << 0x15);
  bVar11 = (uVar4 & 0xfffff) == 0;
  bVar12 = uVar3 == 0 && bVar11;
  if (uVar3 != 0 || !bVar11)
  {
    bVar12 = param_3 == 0 && (uVar5 & 0xfffff) == 0;
  }
  uVar4 |= 0x100000;
  uVar5 |= 0x100000;
  if (bVar12)
  {
    uVar3 |= param_3;
    uVar5 = (uVar8 & 0x80000000 | uVar4) ^ uVar5;
    uVar4 = uVar9 >> 1;
    bVar12 = SBORROW4(iVar6,uVar4);
    uVar7 = iVar6 - uVar4;
    bVar11 = uVar7 == 0;
    uVar8 = uVar7;
    if (!bVar11 && (int)uVar4 <= iVar6)
    {
      bVar12 = SBORROW4(uVar9,uVar7);
      uVar8 = uVar9 - uVar7;
      bVar11 = uVar9 == uVar7;
    }
    if (!bVar11 && (int)uVar8 < 0 == bVar12)
    {
      return CONCAT44(uVar5 | uVar7 * 0x100000,uVar3);
    }
    uVar5 |= 0x100000;
    uVar4 = 0;
    bVar12 = SBORROW4(uVar7,1);
    uVar7 -= 1;
    bVar11 = uVar7 == 0;
    uVar9 = uVar7;
  }
  else
  {
    uVar1 = (uVar14 & 0xffffffff) * (ulonglong)param_3;
    uVar14 = (uVar14 & 0xffffffff) * (ulonglong)uVar5 +
             (ulonglong)uVar4 * (ulonglong)param_3 + (uVar1 >> 0x20);
    uVar10 = (uint)uVar14;
    lVar2 = (ulonglong)uVar4 * (ulonglong)uVar5 + (uVar14 >> 0x20);
    uVar9 = (uint)lVar2;
    uVar5 = (uint)((ulonglong)lVar2 >> 0x20);
    if ((int)uVar1 != 0)
    {
      uVar10 |= 1;
    }
    uVar7 = (iVar6 + -0x3ff) - (uint)(uVar5 < 0x200);
    if (uVar5 < 0x200)
    {
      bVar11 = (uVar10 & 0x80000000) != 0;
      uVar10 <<= 1;
      lVar2 = CONCAT44(uVar5 * 2 + (uint)(CARRY4(uVar9,uVar9) || CARRY4(uVar9 * 2,(uint)bVar11)),
                       uVar9 * 2 + (uint)bVar11);
    }
    uVar5 = uVar8 & 0x80000000 | (int)((ulonglong)lVar2 >> 0x20) << 0xb | (uint)lVar2 >> 0x15;
    uVar3 = (uint)lVar2 << 0xb | uVar10 >> 0x15;
    uVar4 = uVar10 * 0x800;
    bVar13 = 0xfc < uVar7;
    bVar12 = SBORROW4(uVar7,0xfd);
    uVar8 = uVar7 - 0xfd;
    bVar11 = uVar8 == 0;
    uVar9 = uVar8;
    if (bVar13 && !bVar11)
    {
      bVar13 = 0x6ff < uVar8;
      bVar12 = SBORROW4(uVar8,0x700);
      uVar9 = uVar7 - 0x7fd;
      bVar11 = uVar8 == 0x700;
    }
    if (!bVar13 || bVar11)
    {
      bVar11 = 0x7fffffff < uVar4;
      if (uVar4 == 0x80000000)
      {
        bVar11 = (uVar10 >> 0x15 & 1) != 0;
      }
      return CONCAT44(uVar5 + uVar7 * 0x100000 + (uint)CARRY4(uVar3,(uint)bVar11),uVar3 + bVar11);
    }
  }
  if (!bVar11 && (int)uVar9 < 0 == bVar12)
  {
    return (ulonglong)(uVar5 & 0x80000000 | 0x7ff00000) << 0x20;
  }
  if (uVar7 != 0xffffffca && (int)(uVar7 + 0x36) < 0 == SCARRY4(uVar7,0x36))
  {
    uVar9 = -uVar7;
    uVar8 = uVar9 - 0x20;
    if (0x1f < (int)uVar9)
    {
      uVar7 = uVar3 >> (uVar8 & 0xff) | uVar5 << (0x20 - uVar8 & 0xff);
      uVar9 = (uVar5 >> (uVar8 & 0xff) & ~((uVar5 & 0x80000000) >> (uVar8 & 0xff))) -
              ((int)uVar7 >> 0x1f);
      if ((uVar4 == 0 && uVar3 << (0x20 - uVar8 & 0xff) == 0) && (uVar7 & 0x7fffffff) == 0)
      {
        uVar9 &= ~(uVar7 >> 0x1f);
      }
      return CONCAT44(uVar5,uVar9) & 0x80000000ffffffff;
    }
    iVar6 = uVar9 - 0x14;
    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar8,0xc))
    {
      uVar9 = 0xc - iVar6;
      uVar8 = uVar3 << (uVar9 & 0xff);
      uVar9 = uVar3 >> (0x20 - uVar9 & 0xff) | uVar5 << (uVar9 & 0xff);
      uVar3 = uVar9 + -((int)uVar8 >> 0x1f);
      if (uVar4 == 0 && (uVar8 & 0x7fffffff) == 0)
      {
        uVar3 &= ~(uVar8 >> 0x1f);
      }
      return CONCAT44((uVar5 & 0x80000000) + (uint)CARRY4(uVar9,-((int)uVar8 >> 0x1f)),uVar3);
    }
    uVar10 = uVar3 << (uVar7 + 0x20 & 0xff);
    uVar3 = uVar3 >> (uVar9 & 0xff) | uVar5 << (uVar7 + 0x20 & 0xff);
    uVar8 = uVar3 + -((int)uVar10 >> 0x1f);
    if (uVar4 == 0 && (uVar10 & 0x7fffffff) == 0)
    {
      uVar8 &= ~(uVar10 >> 0x1f);
    }
    return CONCAT44((uVar5 & 0x80000000) +
                    ((uVar5 & 0x7fffffff) >> (uVar9 & 0xff)) +
                    (uint)CARRY4(uVar3,-((int)uVar10 >> 0x1f)),uVar8);
  }
  return (ulonglong)(uVar5 & 0x80000000) << 0x20;
}



ulonglong FUN_08002fb4(uint param_1,uint param_2,uint param_3,uint param_4)
{
  bool bVar1;
  uint uVar2;
  uint unaff_r4;
  uint uVar3;
  uint uVar4;
  uint in_r12;
  bool bVar5;
  bool bVar6;
  
  uVar3 = in_r12 & param_4 >> 0x14;
  if (unaff_r4 != in_r12 && uVar3 != in_r12)
  {
    bVar1 = (param_2 & 0x7fffffff) == 0;
    bVar5 = param_1 == 0 && bVar1;
    if (param_1 != 0 || !bVar1)
    {
      bVar5 = param_3 == 0 && (param_4 & 0x7fffffff) == 0;
    }
    if (bVar5)
    {
      return (ulonglong)((param_2 ^ param_4) & 0x80000000) << 0x20;
    }
    if (unaff_r4 == 0)
    {
      uVar4 = param_2 & 0x80000000;
      do
      {
        uVar2 = param_1 & 0x80000000;
        param_1 <<= 1;
        param_2 = param_2 * 2 + (uint)(uVar2 != 0);
      } while ((param_2 & 0x100000) == 0);
      param_2 |= uVar4;
      if (uVar3 != 0)
      {
        return CONCAT44(param_2,param_1);
      }
    }
    do
    {
      uVar3 = param_3 & 0x80000000;
      param_3 <<= 1;
      param_4 = param_4 * 2 + (uint)(uVar3 != 0);
    } while ((param_4 & 0x100000) == 0);
    return CONCAT44(param_2,param_1);
  }
  bVar1 = param_1 == 0;
  bVar5 = (param_2 & 0x7fffffff) == 0;
  bVar6 = bVar1 && bVar5;
  if (bVar1 && bVar5)
  {
    param_2 = param_4;
    param_1 = param_3;
  }
  if (!bVar1 || !bVar5)
  {
    bVar6 = param_3 == 0 && (param_4 & 0x7fffffff) == 0;
  }
  uVar4 = param_2;
  if (((!bVar6) && ((unaff_r4 != in_r12 || (param_1 == 0 && (param_2 & 0xfffff) == 0)))) &&
     ((uVar3 != in_r12 ||
      (param_1 = param_3, uVar4 = param_4, param_3 == 0 && (param_4 & 0xfffff) == 0))))
  {
    return (ulonglong)((param_2 ^ param_4) & 0x80000000 | 0x7ff00000) << 0x20;
  }
  return CONCAT44(uVar4,param_1) | 0x7ff8000000000000;
}



ulonglong __divdf3(uint param_1,uint param_2,uint param_3,uint param_4)
{
  uint extraout_r2;
  uint uVar1;
  uint uVar2;
  uint extraout_r3;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint unaff_r5;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint extraout_r12;
  bool bVar13;
  bool bVar14;
  bool bVar15;
  ulonglong uVar16;
  
  uVar16 = CONCAT44(param_2,param_1);
  uVar12 = 0x7ff;
  uVar6 = param_2 >> 0x14 & 0x7ff;
  bVar13 = uVar6 == 0;
  if (!bVar13)
  {
    unaff_r5 = param_4 >> 0x14 & 0x7ff;
    bVar13 = unaff_r5 == 0;
  }
  if (!bVar13)
  {
    bVar13 = uVar6 == 0x7ff;
  }
  if (!bVar13)
  {
    bVar13 = unaff_r5 == 0x7ff;
  }
  if (bVar13)
  {
    uVar16 = FUN_0800319a(param_1,param_2,param_3,param_4);
    param_3 = extraout_r2;
    param_4 = extraout_r3;
    uVar12 = extraout_r12;
  }
  uVar8 = (uint)(uVar16 >> 0x20);
  uVar10 = (uint)uVar16;
  iVar7 = uVar6 - unaff_r5;
  if (param_3 == 0 && (param_4 & 0xfffff) == 0)
  {
    uVar6 = (uVar8 ^ param_4) & 0x80000000 | uVar8 & 0xfffff;
    bVar15 = SCARRY4(iVar7,uVar12 >> 1);
    uVar8 = iVar7 + (uVar12 >> 1);
    bVar13 = (int)uVar8 < 0;
    bVar14 = uVar8 == 0;
    if (!bVar14 && bVar13 == bVar15)
    {
      bVar15 = SBORROW4(uVar12,uVar8);
      bVar13 = (int)(uVar12 - uVar8) < 0;
      bVar14 = uVar12 == uVar8;
    }
    if (!bVar14 && bVar13 == bVar15)
    {
      return CONCAT44(uVar6 | uVar8 * 0x100000,uVar10);
    }
    uVar6 |= 0x100000;
    uVar12 = 0;
    bVar14 = SBORROW4(uVar8,1);
    uVar8 -= 1;
    bVar13 = uVar8 == 0;
    uVar3 = uVar8;
  }
  else
  {
    uVar3 = (param_4 << 0xc) >> 4 | 0x10000000 | param_3 >> 0x18;
    uVar12 = param_3 << 8;
    uVar9 = (uVar8 << 0xc) >> 4 | 0x10000000 | uVar10 >> 0x18;
    uVar10 *= 0x100;
    uVar6 = (uVar8 ^ param_4) & 0x80000000;
    bVar13 = uVar3 <= uVar9;
    if (uVar9 == uVar3)
    {
      bVar13 = uVar12 <= uVar10;
    }
    iVar7 += (uint)bVar13;
    uVar8 = iVar7 + 0x3fd;
    if (bVar13 == false)
    {
      uVar3 >>= 1;
      uVar12 = (uint)((param_3 >> 0x18 & 1) != 0) << 0x1f | uVar12 >> 1;
    }
    uVar11 = uVar10 - uVar12;
    uVar9 = (uVar9 - uVar3) - (uint)(uVar10 < uVar12);
    uVar4 = uVar3 >> 1;
    uVar1 = (uint)((uVar3 & 1) != 0) << 0x1f | uVar12 >> 1;
    uVar10 = 0x100000;
    uVar3 = 0x80000;
    while( true )
    {
      bVar13 = uVar1 <= uVar11;
      if (uVar4 < uVar9 || uVar9 - uVar4 < (uint)bVar13)
      {
        uVar11 -= uVar1;
        uVar10 |= uVar3;
        uVar9 = (uVar9 - uVar4) - (uint)!bVar13;
      }
      uVar5 = uVar4 >> 1;
      uVar1 = (uint)((uVar4 & 1) != 0) << 0x1f | uVar1 >> 1;
      bVar14 = uVar1 <= uVar11;
      bVar13 = uVar9 - uVar5 < (uint)bVar14;
      uVar12 = uVar9;
      if (uVar5 < uVar9 || bVar13)
      {
        uVar11 -= uVar1;
        uVar12 = (uVar9 - uVar5) - (uint)!bVar14;
      }
      if (uVar5 < uVar9 || bVar13)
      {
        uVar10 |= uVar3 >> 1;
      }
      uVar9 = uVar4 >> 2;
      uVar2 = (uint)((uVar5 & 1) != 0) << 0x1f | uVar1 >> 1;
      bVar14 = uVar2 <= uVar11;
      bVar13 = uVar12 - uVar9 < (uint)bVar14;
      uVar5 = uVar12;
      if (uVar9 < uVar12 || bVar13)
      {
        uVar11 -= uVar2;
        uVar5 = (uVar12 - uVar9) - (uint)!bVar14;
      }
      if (uVar9 < uVar12 || bVar13)
      {
        uVar10 |= uVar3 >> 2;
      }
      uVar4 >>= 3;
      uVar1 = (uint)((uVar9 & 1) != 0) << 0x1f | uVar2 >> 1;
      bVar14 = uVar1 <= uVar11;
      bVar13 = uVar5 - uVar4 < (uint)bVar14;
      uVar9 = uVar5;
      if (uVar4 < uVar5 || bVar13)
      {
        uVar11 -= uVar1;
        uVar9 = (uVar5 - uVar4) - (uint)!bVar14;
      }
      if (uVar4 < uVar5 || bVar13)
      {
        uVar10 |= uVar3 >> 3;
      }
      uVar12 = uVar9 | uVar11;
      if (uVar12 == 0) break;
      uVar9 = uVar9 << 4 | uVar11 >> 0x1c;
      uVar11 <<= 4;
      uVar4 = uVar4 << 3 | uVar1 >> 0x1d;
      uVar1 = (uVar2 >> 1) << 3;
      uVar3 >>= 4;
      if (uVar3 == 0)
      {
        if ((uVar6 & 0x100000) != 0) goto LAB_0800314a;
        uVar6 |= uVar10;
        uVar10 = 0;
        uVar3 = 0x80000000;
      }
    }
    if ((uVar6 & 0x100000) == 0)
    {
      uVar6 |= uVar10;
      uVar10 = 0;
    }
LAB_0800314a:
    bVar15 = 0xfc < uVar8;
    bVar14 = SBORROW4(uVar8,0xfd);
    uVar5 = iVar7 + 0x300;
    bVar13 = uVar5 == 0;
    uVar3 = uVar5;
    if (bVar15 && !bVar13)
    {
      bVar15 = 0x6ff < uVar5;
      bVar14 = SBORROW4(uVar5,0x700);
      uVar3 = iVar7 - 0x400;
      bVar13 = uVar5 == 0x700;
    }
    if (!bVar15 || bVar13)
    {
      bVar13 = uVar4 <= uVar9;
      if (uVar9 == uVar4)
      {
        bVar13 = uVar1 <= uVar11;
      }
      if (uVar9 == uVar4 && uVar11 == uVar1)
      {
        bVar13 = (uVar10 & 1) != 0;
      }
      return CONCAT44(uVar6 + uVar8 * 0x100000 + (uint)CARRY4(uVar10,(uint)bVar13),uVar10 + bVar13);
    }
  }
  if (!bVar13 && (int)uVar3 < 0 == bVar14)
  {
    return (ulonglong)(uVar6 & 0x80000000 | 0x7ff00000) << 0x20;
  }
  if (uVar8 == 0xffffffca || (int)(uVar8 + 0x36) < 0 != SCARRY4(uVar8,0x36))
  {
    return (ulonglong)(uVar6 & 0x80000000) << 0x20;
  }
  uVar3 = -uVar8;
  uVar9 = uVar3 - 0x20;
  if (0x1f < (int)uVar3)
  {
    uVar3 = uVar10 >> (uVar9 & 0xff) | uVar6 << (0x20 - uVar9 & 0xff);
    uVar8 = (uVar6 >> (uVar9 & 0xff) & ~((uVar6 & 0x80000000) >> (uVar9 & 0xff))) -
            ((int)uVar3 >> 0x1f);
    if ((uVar12 == 0 && uVar10 << (0x20 - uVar9 & 0xff) == 0) && (uVar3 & 0x7fffffff) == 0)
    {
      uVar8 &= ~(uVar3 >> 0x1f);
    }
    return CONCAT44(uVar6,uVar8) & 0x80000000ffffffff;
  }
  iVar7 = uVar3 - 0x14;
  if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar9,0xc))
  {
    uVar8 = 0xc - iVar7;
    uVar3 = uVar10 << (uVar8 & 0xff);
    uVar10 = uVar10 >> (0x20 - uVar8 & 0xff) | uVar6 << (uVar8 & 0xff);
    uVar8 = uVar10 + -((int)uVar3 >> 0x1f);
    if (uVar12 == 0 && (uVar3 & 0x7fffffff) == 0)
    {
      uVar8 &= ~(uVar3 >> 0x1f);
    }
    return CONCAT44((uVar6 & 0x80000000) + (uint)CARRY4(uVar10,-((int)uVar3 >> 0x1f)),uVar8);
  }
  uVar9 = uVar10 << (uVar8 + 0x20 & 0xff);
  uVar10 = uVar10 >> (uVar3 & 0xff) | uVar6 << (uVar8 + 0x20 & 0xff);
  uVar8 = uVar10 + -((int)uVar9 >> 0x1f);
  if (uVar12 == 0 && (uVar9 & 0x7fffffff) == 0)
  {
    uVar8 &= ~(uVar9 >> 0x1f);
  }
  return CONCAT44((uVar6 & 0x80000000) +
                  ((uVar6 & 0x7fffffff) >> (uVar3 & 0xff)) +
                  (uint)CARRY4(uVar10,-((int)uVar9 >> 0x1f)),uVar8);
}



ulonglong FUN_0800319a(uint param_1,uint param_2,uint param_3,uint param_4)
{
  bool bVar1;
  uint uVar2;
  uint unaff_r4;
  uint uVar3;
  uint uVar4;
  uint in_r12;
  bool bVar5;
  
  uVar3 = in_r12 & param_4 >> 0x14;
  uVar4 = param_2;
  if (unaff_r4 != in_r12 || uVar3 != in_r12)
  {
    if (unaff_r4 == in_r12)
    {
      if ((param_1 == 0 && (param_2 & 0xfffff) == 0) &&
         (param_1 = param_3, uVar4 = param_4, uVar3 != in_r12))
      {
LAB_0800300c:
        return (ulonglong)((param_2 ^ param_4) & 0x80000000 | 0x7ff00000) << 0x20;
      }
    }
    else if (uVar3 == in_r12)
    {
      param_1 = param_3;
      uVar4 = param_4;
      if (param_3 == 0 && (param_4 & 0xfffff) == 0)
      {
LAB_08002fd0:
        return (ulonglong)((param_2 ^ param_4) & 0x80000000) << 0x20;
      }
    }
    else
    {
      bVar1 = (param_2 & 0x7fffffff) == 0;
      bVar5 = param_1 == 0 && bVar1;
      if (param_1 != 0 || !bVar1)
      {
        bVar5 = param_3 == 0 && (param_4 & 0x7fffffff) == 0;
      }
      if (!bVar5)
      {
        if (unaff_r4 == 0)
        {
          uVar4 = param_2 & 0x80000000;
          do
          {
            uVar2 = param_1 & 0x80000000;
            param_1 <<= 1;
            param_2 = param_2 * 2 + (uint)(uVar2 != 0);
          } while ((param_2 & 0x100000) == 0);
          param_2 |= uVar4;
          if (uVar3 != 0)
          {
            return CONCAT44(param_2,param_1);
          }
        }
        do
        {
          uVar4 = param_3 & 0x80000000;
          param_3 <<= 1;
          param_4 = param_4 * 2 + (uint)(uVar4 != 0);
        } while ((param_4 & 0x100000) == 0);
        return CONCAT44(param_2,param_1);
      }
      if (param_1 != 0 || (param_2 & 0x7fffffff) != 0) goto LAB_0800300c;
      if (param_3 != 0 || (param_4 & 0x7fffffff) != 0) goto LAB_08002fd0;
    }
  }
  return CONCAT44(uVar4,param_1) | 0x7ff8000000000000;
}



uint __gedf2(uint param_1,uint param_2,uint param_3,uint param_4)
{
  uint uVar1;
  bool bVar2;
  bool bVar3;
  
  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&
     ((((int)(param_2 << 1) >> 0x15 == -1 && (param_1 != 0 || (param_2 & 0xfffff) != 0)) ||
      (((int)(param_4 << 1) >> 0x15 == -1 && (param_3 != 0 || (param_4 & 0xfffff) != 0))))))
  {
    return 0xffffffff;
  }
  bVar2 = (param_2 & 0x7fffffff) == 0;
  bVar3 = param_1 == 0 && bVar2;
  if (param_1 == 0 && bVar2)
  {
    bVar3 = param_3 == 0 && (param_4 & 0x7fffffff) == 0;
  }
  if (!bVar3)
  {
    bVar3 = param_2 == param_4;
  }
  if (bVar3)
  {
    bVar3 = param_1 == param_3;
  }
  if (!bVar3)
  {
    uVar1 = param_2 ^ param_4;
    bVar2 = uVar1 == 0;
    if (-1 < (int)uVar1)
    {
      bVar2 = param_2 == param_4;
    }
    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;
    if (bVar2)
    {
      bVar3 = param_3 <= param_1;
    }
    uVar1 = (int)param_4 >> 0x1f;
    if (!bVar3)
    {
      uVar1 = ~uVar1;
    }
    return uVar1 | 1;
  }
  return 0;
}



uint __ledf2(uint param_1,uint param_2,uint param_3,uint param_4)
{
  uint uVar1;
  bool bVar2;
  bool bVar3;
  
  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&
     ((((int)(param_2 << 1) >> 0x15 == -1 && (param_1 != 0 || (param_2 & 0xfffff) != 0)) ||
      (((int)(param_4 << 1) >> 0x15 == -1 && (param_3 != 0 || (param_4 & 0xfffff) != 0))))))
  {
    return 1;
  }
  bVar2 = (param_2 & 0x7fffffff) == 0;
  bVar3 = param_1 == 0 && bVar2;
  if (param_1 == 0 && bVar2)
  {
    bVar3 = param_3 == 0 && (param_4 & 0x7fffffff) == 0;
  }
  if (!bVar3)
  {
    bVar3 = param_2 == param_4;
  }
  if (bVar3)
  {
    bVar3 = param_1 == param_3;
  }
  if (!bVar3)
  {
    uVar1 = param_2 ^ param_4;
    bVar2 = uVar1 == 0;
    if (-1 < (int)uVar1)
    {
      bVar2 = param_2 == param_4;
    }
    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;
    if (bVar2)
    {
      bVar3 = param_3 <= param_1;
    }
    uVar1 = (int)param_4 >> 0x1f;
    if (!bVar3)
    {
      uVar1 = ~uVar1;
    }
    return uVar1 | 1;
  }
  return 0;
}



uint __nedf2(uint param_1,uint param_2,uint param_3,uint param_4)
{
  uint uVar1;
  bool bVar2;
  bool bVar3;
  
  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&
     ((((int)(param_2 << 1) >> 0x15 == -1 && (param_1 != 0 || (param_2 & 0xfffff) != 0)) ||
      (((int)(param_4 << 1) >> 0x15 == -1 && (param_3 != 0 || (param_4 & 0xfffff) != 0))))))
  {
    return 1;
  }
  bVar2 = (param_2 & 0x7fffffff) == 0;
  bVar3 = param_1 == 0 && bVar2;
  if (param_1 == 0 && bVar2)
  {
    bVar3 = param_3 == 0 && (param_4 & 0x7fffffff) == 0;
  }
  if (!bVar3)
  {
    bVar3 = param_2 == param_4;
  }
  if (bVar3)
  {
    bVar3 = param_1 == param_3;
  }
  if (!bVar3)
  {
    uVar1 = param_2 ^ param_4;
    bVar2 = uVar1 == 0;
    if (-1 < (int)uVar1)
    {
      bVar2 = param_2 == param_4;
    }
    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;
    if (bVar2)
    {
      bVar3 = param_3 <= param_1;
    }
    uVar1 = (int)param_4 >> 0x1f;
    if (!bVar3)
    {
      uVar1 = ~uVar1;
    }
    return uVar1 | 1;
  }
  return 0;
}



void __aeabi_cdrcmple(uint param_1,uint param_2,uint param_3,uint param_4)
{
  __aeabi_cdcmpeq(param_3,param_4,param_1,param_2);
  return;
}



uint __aeabi_cdcmpeq(uint param_1,uint param_2,uint param_3,uint param_4)
{
  __nedf2(param_1,param_2,param_3,param_4);
  return param_1;
}



bool __aeabi_dcmpeq(uint param_1,uint param_2,uint param_3,uint param_4)
{
  char in_ZR;
  
  __aeabi_cdcmpeq(param_1,param_2,param_3,param_4);
  return in_ZR != '\0';
}



bool __aeabi_dcmplt(uint param_1,uint param_2,uint param_3,uint param_4)
{
  char in_CY;
  
  __aeabi_cdcmpeq(param_1,param_2,param_3,param_4);
  return in_CY == '\0';
}



bool __aeabi_dcmple(uint param_1,uint param_2,uint param_3,uint param_4)
{
  undefined1 in_ZR;
  undefined1 in_CY;
  
  __aeabi_cdcmpeq(param_1,param_2,param_3,param_4);
  return !(bool)in_CY || (bool)in_ZR;
}



bool __aeabi_dcmpge(uint param_1,uint param_2,uint param_3,uint param_4)
{
  undefined1 in_ZR;
  undefined1 in_CY;
  
  __aeabi_cdrcmple(param_1,param_2,param_3,param_4);
  return !(bool)in_CY || (bool)in_ZR;
}



bool __aeabi_dcmpgt(uint param_1,uint param_2,uint param_3,uint param_4)
{
  char in_CY;
  
  __aeabi_cdrcmple(param_1,param_2,param_3,param_4);
  return in_CY == '\0';
}



uint __aeabi_d2iz(uint param_1,uint param_2)
{
  uint uVar1;
  int iVar2;
  uint uVar3;
  
  iVar2 = param_2 * 2 + 0x200000;
  if (param_2 * 2 < 0xffe00000)
  {
    if (-1 < iVar2)
    {
      return 0;
    }
    uVar1 = iVar2 >> 0x15;
    uVar3 = -uVar1 - 0x3e1;
    if (uVar1 < 0xfffffc20 && uVar3 != 0)
    {
      uVar1 = (param_2 << 0xb | 0x80000000 | param_1 >> 0x15) >> (uVar3 & 0xff);
      if ((param_2 & 0x80000000) != 0)
      {
        uVar1 = -uVar1;
      }
      return uVar1;
    }
  }
  else if (param_1 != 0 || (param_2 & 0xfffff) != 0)
  {
    return 0;
  }
  uVar1 = param_2 & 0x80000000;
  if (uVar1 == 0)
  {
    uVar1 = 0x7fffffff;
  }
  return uVar1;
}



uint __aeabi_d2uiz(uint param_1,uint param_2)
{
  int iVar1;
  uint uVar2;
  
  if ((param_2 & 0x80000000) != 0)
  {
    return 0;
  }
  iVar1 = param_2 * 2 + 0x200000;
  if (param_2 * 2 < 0xffe00000)
  {
    if (-1 < iVar1)
    {
      return 0;
    }
    uVar2 = -(iVar1 >> 0x15) - 0x3e1;
    if (-1 < (int)uVar2)
    {
      return (param_2 << 0xb | 0x80000000 | param_1 >> 0x15) >> (uVar2 & 0xff);
    }
  }
  else if (param_1 != 0 || (param_2 & 0xfffff) != 0)
  {
    return 0;
  }
  return 0xffffffff;
}



undefined4 __aeabi_uldivmod(undefined4 param_1,undefined4 param_2,int param_3,int param_4)
{
  undefined4 uVar1;
  UDItype UVar2;
  UDItype local_8;
  
  if ((param_4 == 0) && (param_3 == 0))
  {
    uVar1 = __aeabi_idiv0();
    return uVar1;
  }
  UVar2 = __udivmoddi4(CONCAT44(param_2,param_1),CONCAT44(param_4,param_3),&local_8);
  return (int)UVar2;
}



UDItype __udivmoddi4(UDItype n,UDItype d,UDItype *rp)
{
  code *pcVar1;
  ulonglong uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  bool bVar14;
  
  uVar9 = (uint)(d >> 0x20);
  uVar5 = (uint)d;
  uVar3 = (uint)(n >> 0x20);
  uVar4 = (uint)n;
  if (uVar9 == 0)
  {
    if (uVar3 < uVar5)
    {
      iVar6 = LZCOUNT(uVar5);
      uVar9 = uVar5;
      if (iVar6 != 0)
      {
        uVar9 = uVar5 << iVar6;
        n = CONCAT44(uVar4 >> (0x20U - iVar6 & 0xff) | uVar3 << iVar6,uVar4 << iVar6);
      }
      uVar4 = (uint)(n >> 0x20);
      uVar10 = uVar9 >> 0x10;
      uVar8 = uVar4 / uVar10;
      uVar7 = (uint)n >> 0x10 | (uVar4 - uVar10 * uVar8) * 0x10000;
      uVar4 = uVar8 * (uVar9 & 0xffff);
      uVar3 = uVar8;
      if (uVar7 <= uVar4 && uVar4 - uVar7 != 0)
      {
        bVar14 = CARRY4(uVar9,uVar7);
        uVar7 = uVar9 + uVar7;
        uVar3 = uVar8 - 1;
        if ((!bVar14) && (uVar7 <= uVar4 && uVar4 - uVar7 != 0))
        {
          uVar3 = uVar8 - 2;
          uVar7 += uVar9;
        }
      }
      uVar8 = (uVar7 - uVar4) / uVar10;
      uVar7 = (uint)n & 0xffff | ((uVar7 - uVar4) - uVar10 * uVar8) * 0x10000;
      uVar10 = uVar8 * (uVar9 & 0xffff);
      uVar4 = uVar8;
      if (uVar7 <= uVar10 && uVar10 - uVar7 != 0)
      {
        bVar14 = CARRY4(uVar9,uVar7);
        uVar7 = uVar9 + uVar7;
        uVar4 = uVar8 - 1;
        if ((!bVar14) && (uVar7 <= uVar10 && uVar10 - uVar7 != 0))
        {
          uVar4 = uVar8 - 2;
          uVar7 += uVar9;
        }
      }
      uVar4 |= uVar3 << 0x10;
      uVar7 -= uVar10;
      uVar9 = 0;
    }
    else
    {
      if (uVar5 == 0)
      {
                    // WARNING: Does not return
        pcVar1 = (code *)software_udf(0xff,0x8003474);
        (*pcVar1)();
      }
      iVar6 = LZCOUNT(uVar5);
      if (iVar6 == 0)
      {
        uVar3 -= uVar5;
        uVar13 = uVar5 >> 0x10;
        uVar11 = uVar5 & 0xffff;
        uVar9 = 1;
        uVar8 = uVar5;
      }
      else
      {
        uVar8 = uVar5 << iVar6;
        uVar13 = uVar8 >> 0x10;
        uVar9 = uVar3 >> (0x20U - iVar6 & 0xff);
        uVar3 = uVar3 << iVar6 | uVar4 >> (0x20U - iVar6 & 0xff);
        uVar12 = uVar9 / uVar13;
        uVar11 = uVar8 & 0xffff;
        uVar10 = uVar3 >> 0x10 | (uVar9 - uVar13 * uVar12) * 0x10000;
        uVar9 = uVar12 * uVar11;
        uVar4 <<= iVar6;
        uVar7 = uVar12;
        if (uVar10 <= uVar9 && uVar9 - uVar10 != 0)
        {
          bVar14 = CARRY4(uVar8,uVar10);
          uVar10 = uVar8 + uVar10;
          uVar7 = uVar12 - 1;
          if ((!bVar14) && (uVar10 <= uVar9 && uVar9 - uVar10 != 0))
          {
            uVar7 = uVar12 - 2;
            uVar10 += uVar8;
          }
        }
        uVar12 = (uVar10 - uVar9) / uVar13;
        uVar3 = uVar3 & 0xffff | ((uVar10 - uVar9) - uVar13 * uVar12) * 0x10000;
        uVar10 = uVar12 * uVar11;
        uVar9 = uVar12;
        if (uVar3 <= uVar10 && uVar10 - uVar3 != 0)
        {
          bVar14 = CARRY4(uVar8,uVar3);
          uVar3 = uVar8 + uVar3;
          uVar9 = uVar12 - 1;
          if ((!bVar14) && (uVar3 <= uVar10 && uVar10 - uVar3 != 0))
          {
            uVar9 = uVar12 - 2;
            uVar3 += uVar8;
          }
        }
        uVar3 -= uVar10;
        uVar9 |= uVar7 << 0x10;
      }
      uVar12 = uVar3 / uVar13;
      uVar7 = uVar4 >> 0x10 | (uVar3 - uVar13 * uVar12) * 0x10000;
      uVar10 = uVar11 * uVar12;
      uVar3 = uVar12;
      if (uVar7 <= uVar10 && uVar10 - uVar7 != 0)
      {
        bVar14 = CARRY4(uVar8,uVar7);
        uVar7 = uVar8 + uVar7;
        uVar3 = uVar12 - 1;
        if ((!bVar14) && (uVar7 <= uVar10 && uVar10 - uVar7 != 0))
        {
          uVar3 = uVar12 - 2;
          uVar7 += uVar8;
        }
      }
      uVar12 = (uVar7 - uVar10) / uVar13;
      uVar7 = uVar4 & 0xffff | ((uVar7 - uVar10) - uVar13 * uVar12) * 0x10000;
      uVar11 *= uVar12;
      uVar4 = uVar12;
      if (uVar7 <= uVar11 && uVar11 - uVar7 != 0)
      {
        bVar14 = CARRY4(uVar8,uVar7);
        uVar7 = uVar8 + uVar7;
        uVar4 = uVar12 - 1;
        if ((!bVar14) && (uVar7 <= uVar11 && uVar11 - uVar7 != 0))
        {
          uVar4 = uVar12 - 2;
          uVar7 += uVar8;
        }
      }
      uVar7 -= uVar11;
      uVar4 |= uVar3 << 0x10;
    }
    if (rp != (UDItype *)0x0)
    {
      *(uint *)rp = uVar7 >> LZCOUNT(uVar5);
      *(undefined4 *)((int)rp + 4) = 0;
    }
  }
  else if (uVar3 < uVar9)
  {
    if (rp != (UDItype *)0x0)
    {
      *rp = n;
      return 0;
    }
    uVar4 = 0;
    uVar9 = 0;
  }
  else
  {
    iVar6 = LZCOUNT(uVar9);
    if (iVar6 != 0)
    {
      uVar11 = 0x20 - iVar6;
      uVar7 = uVar9 << iVar6 | uVar5 >> (uVar11 & 0xff);
      uVar13 = uVar7 >> 0x10;
      uVar9 = uVar3 >> (uVar11 & 0xff);
      uVar8 = uVar4 >> (uVar11 & 0xff) | uVar3 << iVar6;
      uVar10 = uVar9 / uVar13;
      uVar9 = uVar8 >> 0x10 | (uVar9 - uVar13 * uVar10) * 0x10000;
      uVar12 = uVar10 * (uVar7 & 0xffff);
      uVar4 <<= iVar6;
      uVar3 = uVar10;
      if (uVar9 <= uVar12 && uVar12 - uVar9 != 0)
      {
        bVar14 = CARRY4(uVar7,uVar9);
        uVar9 = uVar7 + uVar9;
        uVar3 = uVar10 - 1;
        if ((!bVar14) && (uVar9 <= uVar12 && uVar12 - uVar9 != 0))
        {
          uVar3 = uVar10 - 2;
          uVar9 += uVar7;
        }
      }
      uVar10 = (uVar9 - uVar12) / uVar13;
      uVar8 = uVar8 & 0xffff | ((uVar9 - uVar12) - uVar13 * uVar10) * 0x10000;
      uVar12 = uVar10 * (uVar7 & 0xffff);
      uVar9 = uVar10;
      if (uVar8 <= uVar12 && uVar12 - uVar8 != 0)
      {
        bVar14 = CARRY4(uVar7,uVar8);
        uVar8 = uVar7 + uVar8;
        uVar9 = uVar10 - 1;
        if ((!bVar14) && (uVar8 <= uVar12 && uVar12 - uVar8 != 0))
        {
          uVar9 = uVar10 - 2;
          uVar8 += uVar7;
        }
      }
      uVar9 |= uVar3 << 0x10;
      uVar2 = (ulonglong)uVar9 * (ulonglong)(uVar5 << iVar6);
      if ((CONCAT44(uVar8 - uVar12,uVar4) < uVar2) || ((false && (uVar4 < (uint)uVar2))))
      {
        uVar2 -= CONCAT44(uVar7,uVar5 << iVar6);
        uVar9 -= 1;
      }
      if (rp != (UDItype *)0x0)
      {
        uVar3 = ((uVar8 - uVar12) - (int)(uVar2 >> 0x20)) - (uint)(uVar4 < (uint)uVar2);
        *(uint *)rp = uVar3 << (uVar11 & 0xff) | uVar4 - (uint)uVar2 >> iVar6;
        *(uint *)((int)rp + 4) = uVar3 >> iVar6;
      }
      return (UDItype)uVar9;
    }
    if ((uVar9 < uVar3) || (uVar5 <= uVar4))
    {
      n -= d;
      uVar4 = 1;
    }
    else
    {
      uVar4 = 0;
    }
    uVar9 = 0;
    if (rp != (UDItype *)0x0)
    {
      *rp = n;
    }
  }
  return CONCAT44(uVar9,uVar4);
}



void __aeabi_idiv0(void)
{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void HardFault_Handler(void)
{
  uint32_t *hardfault_args;
  uint unaff_lr;
  
  if ((unaff_lr & 4) == 0)
  {
    hardfault_args = (uint32_t *)getMainStackPointer();
  }
  else
  {
    hardfault_args = (uint32_t *)getProcessStackPointer();
  }
  HardFault_Handler_C(hardfault_args);
  return;
}



void HardFault_Handler_C(uint32_t *hardfault_args)
{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t *hardfault_args_local;
  uint32_t stacked_psr;
  uint32_t stacked_pc;
  uint32_t stacked_lr;
  uint32_t stacked_r12;
  uint32_t stacked_r3;
  uint32_t stacked_r2;
  uint32_t stacked_r1;
  uint32_t stacked_r0;
  
  uVar1 = *hardfault_args;
  uVar2 = hardfault_args[1];
  uVar3 = hardfault_args[2];
  uVar4 = hardfault_args[3];
  uVar5 = hardfault_args[4];
  uVar6 = hardfault_args[5];
  uVar7 = hardfault_args[6];
  uVar8 = hardfault_args[7];
  puts("HardFault Handler:");
  printf("R0  = 0x%08lX\n",uVar1);
  printf("R1  = 0x%08lX\n",uVar2);
  printf("R2  = 0x%08lX\n",uVar3);
  printf("R3  = 0x%08lX\n",uVar4);
  printf("R12 = 0x%08lX\n",uVar5);
  printf("LR  = 0x%08lX\n",uVar6);
  printf("PC  = 0x%08lX\n",uVar7);
  printf("PSR = 0x%08lX\n",uVar8);
  do
  {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void show_message_start_lorastudio(void)
{
  smtc_display_clear();
  smtc_display_print_format_string(0,0,"Please connect me to");
  smtc_display_print_format_string(0,0x10,"--- LoRaStudio ---");
  smtc_display_print_format_string(0,0x20,"Download from website");
  smtc_display_print_format_string(0,0x28,"www.semtech.com/");
  smtc_display_print_format_string(0,0x30,"products/wireless-rf/");
  smtc_display_print_format_string(0,0x38,"lora-plus/lr2021");
  smtc_display_render();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void show_message_standalone_mode(void)
{
  smtc_display_clear();
  smtc_display_print_format_string(0,0,"Running in");
  smtc_display_print_format_string(0,0x10,"--- Standalone ---");
  smtc_display_print_format_string(0,0x20,"Press the user button");
  smtc_display_print_format_string(0,0x28,"to start your");
  smtc_display_print_format_string(0,0x30,"application");
  smtc_display_render();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void show_message_connected_mode(void)
{
  smtc_display_clear();
  smtc_display_print_format_string(0,0,"Running in");
  smtc_display_print_format_string(0,0x10,"--- Connected ---");
  smtc_display_print_format_string(0,0x20,"Connected to LoRaStudio");
  smtc_display_render();
  return;
}



// WARNING: Unknown calling convention

int main(void)
{
  bool bVar1;
  bool bVar2;
  smtc_hal_mcu_status_t sVar3;
  _Bool _Var4;
  _Bool _Var5;
  uint32_t uVar6;
  command_t command_received;
  hci_t hci;
  _Bool datagram_valid;
  _Bool in_standalone_mode;
  uint32_t start_ms;
  smtc_hal_mcu_status_t status;
  _Bool first_exchange;
  _Bool msg_shown;
  uint32_t now_ms;
  
  sVar3 = smtc_hal_mcu_init();
  if (sVar3 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar3 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029500,0x8033a2c,0xb2,0x80294e4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029500,0x8033a2c,0xb2,(uint)sVar3);
    }
  }
  uart_init((_func_void *)0x8004df9,(_func_void *)0x8004e19,(_func_void *)0x8004e39,
            (_func_void *)0x8004e59);
  support_timing_init();
  user_button_init();
  diagnostics_init();
  memset(&hci,0,0x1014);
  hci_init(&hci);
  print_init(&hci);
  shield_manager_init(&hci);
  configuration_manager_init(&manager,&hci);
  configuration_manager_init_nvm_manager();
  common_radio_parameters_init();
  display_init();
  display_show_logo();
  dynamic_logs_nvm_init();
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Starting...");
  demo_manager_register_demos(&manager);
  demo_manager_print_registered_demos();
  common_radio_register_configuration_to_manager(&manager);
  configuration_manager_restore_from_nvm(&manager);
  demo_manager_load_demo_to_start_from_nvm(&manager);
  shield_manager_restore_shield_from_nvm();
  restore_running_mode();
  dynamic_log_restore_status();
  hci_start_rx(&hci);
  support_timing_init();
  uVar6 = support_timing_get_time();
  bVar1 = false;
  _Var4 = is_running_mode_standalone();
  bVar2 = false;
  now_ms = uVar6;
  do
  {
    hci_run(&hci);
    demo_manager_runtime_demo();
    shield_manager_runtime();
    dynamic_log_dump_runtime();
    _Var5 = hci_has_datagram_available(&hci);
    if (_Var5)
    {
      memset(&command_received,0,0x804);
      _Var5 = datagram_parser_parse((uint)hci.datagram.length,hci.datagram.data,&command_received);
      hci_reset_rx(&hci);
      if (_Var5)
      {
        demo_manager_interpret_command(&command_received);
        configuration_manager_interpret_command(&manager,&command_received);
        shield_manager_interpret_command(&command_received);
        version_information_command_interpret(&command_received,&hci);
        bVar2 = true;
      }
      hci_send_completed(&hci);
      hci_start_rx(&hci);
    }
    if ((!bVar1) && (!bVar2))
    {
      if (5000 < now_ms - uVar6)
      {
        if ((_Var4) || (bVar2))
        {
          show_message_standalone_mode();
        }
        else
        {
          show_message_start_lorastudio();
        }
        bVar1 = true;
      }
      now_ms = support_timing_get_time();
    }
    if (((bVar1) && (bVar2)) && (_Var5 = is_running_mode_waiting_for_connection(), _Var5))
    {
      show_message_connected_mode();
      running_mode_set_connected();
    }
  } while( true );
}



void print_init(hci_t *hci_instance_pointer)
{
  hci_t *hci_instance_pointer_local;
  
  if (hci_instance_pointer != (hci_t *)0x0)
  {
    hci = hci_instance_pointer;
  }
  return;
}



void array_to_string(uint8_t *array,uint16_t len,char *string)
{
  int iVar1;
  char *string_local;
  uint16_t len_local;
  uint8_t *array_local;
  uint16_t i;
  char *index;
  
  index = string;
  for (i = 0; i < len; i += 1)
  {
    iVar1 = sprintf(index,"%02X",(uint)array[i]);
    index = index + iVar1;
    if (((i & 0x1f) == 0) && (i != 0))
    {
      iVar1 = sprintf(index,"\n");
      index = index + iVar1;
    }
  }
  return;
}



hci_return_code_t
log_message(DeviceMessage__Level level,DeviceMessage__LogSource source,char *string)
{
  hci_return_code_t hVar1;
  char *string_local;
  DeviceMessage__LogSource source_local;
  DeviceMessage__Level level_local;
  
  hVar1 = _log_message(level,source,string,'\n');
  return hVar1;
}



hci_return_code_t
dump_message(DeviceMessage__Level level,DeviceMessage__LogSource source,char *string)
{
  hci_return_code_t hVar1;
  char *string_local;
  DeviceMessage__LogSource source_local;
  DeviceMessage__Level level_local;
  
  hVar1 = _log_message(level,source,string,'\x11');
  return hVar1;
}



hci_return_code_t
_log_message(DeviceMessage__Level level,DeviceMessage__LogSource source,char *string,uint8_t tag)
{
  _Bool _Var1;
  uint8_t tag_local;
  char *string_local;
  DeviceMessage__LogSource source_local;
  DeviceMessage__Level level_local;
  hci_return_code_t return_code;
  hci_datagram_t datagram;
  
  memset(&datagram,0,0x804);
  datagram.tag = tag;
  _Var1 = datagram_parser_prepare_log(string,level,source,datagram.data,&datagram.length,0x800);
  if (_Var1)
  {
    return_code = hci_send_datagram(hci,&datagram);
    diagnostics_save_event_with_data('\x10',&return_code,1);
  }
  else
  {
    return_code = HCI_RETURN_CODE_MALFORMED_DATAGRAM;
  }
  return return_code;
}



size_t strnlen(char *__string,size_t __maxlen)
{
  size_t maxlen_local;
  char *s_local;
  size_t len;
  
  for (len = 0; (len < __maxlen && (__string[len] != '\0')); len += 1)
  {
  }
  return len;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_logs_nvm_init(void)
{
  nvm_manager_status_type_t nVar1;
  nvm_manager_status_type_t nvm_manager_status;
  
  nVar1 = nvm_manager_nvm_init(&log_nvm_instance,0x80f0800,0x80fc000);
  if (nVar1 != NVM_MANAGER_OK)
  {
    log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Error while initializing NVM for logs");
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_log_save_status(void)
{
  config_manager_nvm_status_type_t cVar1;
  nvm_logs_status_t log_status;
  config_manager_nvm_status_type_t status;
  
  log_status.file_id = file_id;
  log_status.logs_index_to_write = logs_index_to_write;
  cVar1 = config_manager_nvm_store_logs_status((uint8_t *)&log_status,4);
  if (cVar1 == CONFIG_MANAGER_NVM_OK)
  {
    memset(message,0,0xff);
    snprintf(message,0xff,
             "Logs status saved successfully\n\t-- file_id: 0x%04X\n\t-- logs_index_to_write: 0x%02x"
             ,(uint)file_id,(uint)logs_index_to_write);
    log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,message);
  }
  else
  {
    log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Error while saving logs status");
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_log_restore_status(void)
{
  config_manager_nvm_status_type_t cVar1;
  nvm_manager_status_type_t nVar2;
  uint16_t len;
  uint16_t length;
  nvm_logs_status_t log_status;
  nvm_manager_status_type_t nvm_manager_status;
  config_manager_nvm_status_type_t status;
  
  length = 0;
  cVar1 = config_manager_nvm_retrieve_logs_status((uint8_t *)&log_status,&length);
  if ((cVar1 == CONFIG_MANAGER_NVM_OK) && (length == 4))
  {
    file_id = log_status.file_id;
    logs_index_to_write = log_status.logs_index_to_write;
    len = 0;
    nVar2 = nvm_manager_nvm_read(log_nvm_instance,log_status.file_id,logs_in_RAM,&len);
    if (nVar2 == NVM_MANAGER_OK)
    {
      if (len < 0x7f9)
      {
        memset(message,0,0xff);
        snprintf(message,0xff,
                 "Logs status restored successfully\n\t-- file_id: 0x%04X\n\t-- logs_index_to_write: 0x%02x"
                 ,(uint)file_id,(uint)logs_index_to_write);
        log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,message)
        ;
      }
      else
      {
        log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                    "Error: Read log file is too big. Please check the NVM status.");
      }
    }
    else
    {
      log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                  "Error: Could not read current log file. Please check the NVM status.");
    }
  }
  else if (cVar1 == CONFIG_MANAGER_NVM_NOT_FOUND)
  {
    file_id = 0x8000;
    logs_index_to_write = 0;
    memset(logs_in_RAM,0,0x7f8);
    log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Logs status not found in NVM, factory reset performed");
    dynamic_log_message_nvm_factory_reset();
  }
  else
  {
    log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Error while restoring logs log_status : bad length");
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_log_message_nvm_factory_reset(void)
{
  nvm_manager_status_type_t nVar1;
  nvm_manager_status_type_t nvm_manager_status;
  
  file_id = 0x8000;
  logs_index_to_write = 0;
  memset(logs_in_RAM,0,0x7f8);
  nVar1 = nvm_manager_nvm_factory_reset(log_nvm_instance);
  if (nVar1 != NVM_MANAGER_OK)
  {
    log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Failed to perform NVM factory reset on logs instance.");
  }
  log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
              "Factory reset of log files completed successfully.");
  return;
}



// WARNING: Variable defined which should be unmapped: argp

void dynamic_log_message(DeviceMessage__Level level,DeviceMessage__LogSource source,
                        _Bool save_in_nvm,char *fmt,...)
{
  _Bool _Var1;
  int iVar2;
  size_t sVar3;
  _Bool save_in_nvm_local;
  DeviceMessage__LogSource source_local;
  DeviceMessage__Level level_local;
  nvm_log_t log_to_save;
  char string [2048];
  va_list argp;
  uint16_t log_length;
  char *fmt_local;
  
  string[0] = '\0';
  string[1] = '\0';
  string[2] = '\0';
  string[3] = '\0';
  memset(string + 4,0,0x7fc);
  iVar2 = vsnprintf(string,0x800,fmt,&stack0x00000000);
  if (0 < iVar2)
  {
    _Var1 = is_running_mode_connected();
    if ((_Var1) || (!save_in_nvm))
    {
      log_message(level,source,string);
    }
    else
    {
      sVar3 = strnlen(string,0x800);
      log_to_save.header.level = (uint8_t)level;
      log_to_save.header.source = (uint8_t)source;
      log_to_save.string[0] = '\0';
      log_to_save.string[1] = '\0';
      log_to_save.string[2] = '\0';
      log_to_save.string[3] = '\0';
      log_to_save.header.length = (uint16_t)sVar3;
      memset(log_to_save.string + 4,0,0x7fc);
      memcpy(log_to_save.string,string,sVar3 & 0xffff);
      buffered_save((uint8_t *)&log_to_save,(uint16_t)sVar3 + 4,&logs_index_to_write,true);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_log_message_back_up(void)
{
  save_logs_in_nvm(0x7f8);
  dynamic_log_save_status();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_log_dump_runtime(void)
{
  nvm_manager_status_type_t nVar1;
  hci_return_code_t hVar2;
  ushort uVar3;
  size_t __n;
  uint16_t num_copied_byte_dump;
  nvm_manager_status_type_t nvm_manager_status;
  
  if (dumping_in_progress)
  {
    if (size_to_dump < 1)
    {
      dumping_in_progress = false;
      dynamic_log_dump_runtime::offset = 0;
      dynamic_log_dump_runtime::load_from_nvm = true;
    }
    else
    {
      if (dynamic_log_dump_runtime::load_from_nvm)
      {
        nVar1 = nvm_manager_nvm_read
                          (log_nvm_instance,file_id_to_start_dump,
                           dynamic_log_dump_runtime::logs_in_NVM,
                           &dynamic_log_dump_runtime::logs_in_NVM_len);
        if (nVar1 == NVM_MANAGER_OK)
        {
          dynamic_log_dump_runtime::load_from_nvm = false;
          dynamic_log_dump_runtime::currently_dumped_file_id = file_id_to_start_dump;
          file_id_to_start_dump += 1;
          if (0x8016 < file_id_to_start_dump)
          {
            file_id_to_start_dump = 0x8000;
          }
          dynamic_log_dump_runtime::offset = 0;
        }
        else
        {
          if (nVar1 != NVM_MANAGER_DATA_NOT_FOUND_ERROR)
          {
            log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                        "Error while reading logs from NVM");
            dumping_in_progress = false;
            return;
          }
          dynamic_log_dump_runtime::offset = 0;
        }
      }
      dynamic_log_dump_runtime::log_to_dump.header.length =
           (ushort)dynamic_log_dump_runtime::logs_in_NVM[dynamic_log_dump_runtime::offset + 1] *
           0x100 + (ushort)dynamic_log_dump_runtime::logs_in_NVM[dynamic_log_dump_runtime::offset];
      if (dynamic_log_dump_runtime::log_to_dump.header.length == 0)
      {
        if ((dynamic_log_dump_runtime::currently_dumped_file_id == split_file_id) &&
           (dynamic_log_dump_runtime::offset == logs_index_to_write))
        {
          log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                      "Dump completed successfully");
          if (size_to_dump != 0)
          {
            memset(message,0,0xff);
            snprintf(message,0xff,"Size to dump not null at end of dump :%ld",size_to_dump);
            log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                        message);
            dynamic_log_dump_runtime::log_to_dump.header.length = (uint16_t)size_to_dump;
            dynamic_log_dump_runtime::log_to_dump.header.level = '\0';
            dynamic_log_dump_runtime::log_to_dump.header.source = '\0';
            memset(dynamic_log_dump_runtime::log_to_dump.string,0,0x800);
            __n = size_to_dump;
            if (0x7fe < size_to_dump)
            {
              __n = 0x7ff;
            }
            memset(dynamic_log_dump_runtime::log_to_dump.string,0x20,__n);
            hVar2 = dump_message((uint)dynamic_log_dump_runtime::log_to_dump.header.level,
                                 (uint)dynamic_log_dump_runtime::log_to_dump.header.source,
                                 dynamic_log_dump_runtime::log_to_dump.string);
            if (hVar2 != HCI_RETURN_CODE_OK_DATAGRAM_BUFFERED)
            {
              return;
            }
          }
          dumping_in_progress = false;
        }
        dynamic_log_dump_runtime::offset = 0;
        dynamic_log_dump_runtime::load_from_nvm = true;
      }
      else
      {
        uVar3 = dynamic_log_dump_runtime::log_to_dump.header.length + 4;
        if ((uint)dynamic_log_dump_runtime::logs_in_NVM_len <
            (uint)uVar3 + (uint)dynamic_log_dump_runtime::offset)
        {
          memset(message,0,0xff);
          snprintf(message,0xff,"offset + num_copied_byte_dump :%04x + %04x=%04x",
                   (uint)dynamic_log_dump_runtime::offset,(uint)uVar3,
                   (uint)uVar3 + (uint)dynamic_log_dump_runtime::offset);
          log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                      message);
          dynamic_log_dump_runtime::load_from_nvm = true;
        }
        else
        {
          memcpy(&dynamic_log_dump_runtime::log_to_dump,
                 dynamic_log_dump_runtime::logs_in_NVM + dynamic_log_dump_runtime::offset,
                 (uint)uVar3);
          hVar2 = dump_message((uint)dynamic_log_dump_runtime::log_to_dump.header.level,
                               (uint)dynamic_log_dump_runtime::log_to_dump.header.source,
                               dynamic_log_dump_runtime::log_to_dump.string);
          if (hVar2 == HCI_RETURN_CODE_OK_DATAGRAM_BUFFERED)
          {
            dynamic_log_dump_runtime::offset = uVar3 + dynamic_log_dump_runtime::offset;
            size_to_dump -= (uint)uVar3;
            if (size_to_dump == 0)
            {
              log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          "Dump completed successfully");
              dumping_in_progress = false;
              dynamic_log_dump_runtime::offset = 0;
              dynamic_log_dump_runtime::load_from_nvm = true;
            }
            if (size_to_dump < 0)
            {
              memset(message,0,0xff);
              snprintf(message,0xff,"WARNING : Size to dump became non-positive :%ld",size_to_dump);
              log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          message);
              dynamic_log_dump_runtime::load_from_nvm = true;
              dumping_in_progress = false;
              dynamic_log_dump_runtime::offset = 0;
            }
            memset(&dynamic_log_dump_runtime::log_to_dump,0,0x804);
          }
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dynamic_log_message_nvm_dump(void)
{
  _Bool all_file_ids_used;
  
  all_file_ids_used = false;
  size_to_dump = dynamic_log_message_get_nvm_logs_size(&all_file_ids_used);
  memset(message,0,0xff);
  snprintf(message,0xff,"Size to dump :0x%04lX",size_to_dump);
  log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,message);
  original_size_to_dump = (uint16_t)size_to_dump;
  if (all_file_ids_used == false)
  {
    file_id_to_start_dump = 0x8000;
  }
  else
  {
    file_id_to_start_dump = get_next_file_id(file_id);
  }
  split_file_id = file_id;
  dumping_in_progress = true;
  return;
}



uint32_t dynamic_log_message_get_nvm_logs_size(_Bool *all_file_ids_used)
{
  undefined1 uVar1;
  uint32_t uVar2;
  bool bVar3;
  _Bool *all_file_ids_used_local;
  uint16_t nb_files;
  uint32_t logs_size;
  nvm_manager_status_type_t status;
  
  logs_size = 0;
  nb_files = 0;
  status = nvm_manager_nvm_get_stored_data_size(log_nvm_instance,&logs_size,&nb_files);
  if (status == NVM_MANAGER_OK)
  {
    if (all_file_ids_used != (_Bool *)0x0)
    {
      bVar3 = nb_files == 0x17;
      if (bVar3)
      {
        nb_files = 1;
      }
      uVar1 = (undefined1)nb_files;
      if (!bVar3)
      {
        uVar1 = false;
      }
      *all_file_ids_used = (_Bool)uVar1;
    }
    uVar2 = (logs_size + logs_index_to_write) - 0x7f8;
  }
  else
  {
    log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Error while getting NVM logs size");
    uVar2 = 0;
  }
  return uVar2;
}



_Bool dynamic_log_message_prepare_get_logs_size
                (uint8_t *buffer,uint16_t *packed_buffer_length,uint16_t max_length)
{
  size_t sVar1;
  undefined1 uVar2;
  uint uVar3;
  uint uVar4;
  uint16_t max_length_local;
  uint16_t *packed_buffer_length_local;
  uint8_t *buffer_local;
  DeviceMessage__NvmLogsSize nvm_logs_size;
  size_t packed_size;
  
  nvm_logs_size.base.descriptor = &device_message__nvm_logs_size__descriptor;
  nvm_logs_size.base.n_unknown_fields = 0;
  nvm_logs_size.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  nvm_logs_size.size = 0;
  nvm_logs_size.size = dynamic_log_message_get_nvm_logs_size((_Bool *)0x0);
  sVar1 = device_message__nvm_logs_size__get_packed_size(&nvm_logs_size);
  *packed_buffer_length = (uint16_t)sVar1;
  if (max_length < *packed_buffer_length)
  {
    uVar2 = 0;
  }
  else
  {
    sVar1 = device_message__nvm_logs_size__pack(&nvm_logs_size,buffer);
    uVar3 = (uint)max_length;
    uVar4 = uVar3;
    if (sVar1 <= uVar3)
    {
      uVar4 = 1;
    }
    uVar2 = (undefined1)uVar4;
    if (uVar3 < sVar1)
    {
      uVar2 = 0;
    }
  }
  return (_Bool)uVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void next_file_id(void)
{
  file_id = get_next_file_id(file_id);
  return;
}



uint16_t get_next_file_id(uint16_t current_file_id)
{
  uint16_t current_file_id_local;
  uint16_t next_file_id;
  
  next_file_id = current_file_id + 1;
  if (0x8016 < next_file_id)
  {
    next_file_id = 0x8000;
  }
  return next_file_id;
}



void save_logs_in_nvm(uint16_t length)
{
  nvm_manager_status_type_t nVar1;
  uint16_t length_local;
  nvm_manager_status_type_t nvm_manager_status;
  
  nVar1 = nvm_manager_nvm_replace(log_nvm_instance,file_id,logs_in_RAM,length);
  if (nVar1 != NVM_MANAGER_OK)
  {
    log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                "Error while saving logs in NVM");
  }
  return;
}



void buffered_save(uint8_t *buffer,uint16_t length,uint16_t *index,_Bool reset_if_full)
{
  uint16_t *index_local;
  _Bool reset_if_full_local;
  uint16_t length_local;
  uint8_t *buffer_local;
  
  if ((uint)length + (uint)*index < 0x7f8)
  {
    memcpy(logs_in_RAM + *index,buffer,(uint)length);
    *index = length + *index;
  }
  else
  {
    if ((uint)length + (uint)*index == 0x7f8)
    {
      memcpy(logs_in_RAM + *index,buffer,(uint)length);
      *index = length + *index;
    }
    save_logs_in_nvm(0x7f8);
    if (reset_if_full)
    {
      memset(logs_in_RAM,0,0x7f8);
      *index = 0;
      next_file_id();
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void running_mode_set_connected(void)
{
  running_mode = RUN_MODE_CONNECTED;
  user_button_disable();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void running_mode_set_standalone(void)
{
  running_mode = RUN_MODE_STANDALONE;
  user_button_enable();
  return;
}



// WARNING: Unknown calling convention

_Bool is_running_mode_standalone(void)
{
  return running_mode == RUN_MODE_STANDALONE;
}



// WARNING: Unknown calling convention

_Bool is_running_mode_connected(void)
{
  return running_mode == RUN_MODE_CONNECTED;
}



// WARNING: Unknown calling convention

_Bool is_running_mode_waiting_for_connection(void)
{
  return running_mode == RUN_MODE_WAITING_FOR_CONNECTION;
}



_Bool running_mode_prepare_get_mode
                (uint8_t *buffer,uint16_t *packed_buffer_length,uint16_t max_length)
{
  ushort uVar1;
  size_t sVar2;
  uint16_t max_length_local;
  uint16_t *packed_buffer_length_local;
  uint8_t *buffer_local;
  DeviceMessage__RunningMode running_mode_message;
  
  running_mode_message.base.descriptor = &device_message__running_mode__descriptor;
  running_mode_message.base.n_unknown_fields = 0;
  running_mode_message.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  running_mode_message.running_mode =
       (DeviceMessage__RunningModeValue)(running_mode != RUN_MODE_CONNECTED);
  sVar2 = device_message__running_mode__get_packed_size(&running_mode_message);
  *packed_buffer_length = (uint16_t)sVar2;
  uVar1 = *packed_buffer_length;
  if (uVar1 <= max_length)
  {
    device_message__running_mode__pack(&running_mode_message,buffer);
  }
  return uVar1 <= max_length;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void restore_running_mode(void)
{
  undefined4 uVar1;
  _Bool is_connected_mode;
  config_manager_nvm_status_type_t status;
  
  is_connected_mode = true;
  status = config_manager_nvm_retrieve_running_mode(&is_connected_mode);
  if (status == CONFIG_MANAGER_NVM_OK)
  {
    running_mode = is_connected_mode ^ RUN_MODE_STANDALONE;
    if (running_mode == RUN_MODE_CONNECTED)
    {
      uVar1 = 0x80298c0;
    }
    else
    {
      uVar1 = 0x80298cc;
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Running mode is %s",uVar1);
  }
  else if (status == CONFIG_MANAGER_NVM_NOT_FOUND)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"Running mode not found in NVM, setting default mode to RUN_MODE_CONNECTED"
                       );
    running_mode = RUN_MODE_CONNECTED;
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Error while reading running mode from NVM, setting default mode to RUN_MODE_CONNECTED"
                       );
    running_mode = RUN_MODE_CONNECTED;
  }
  if (running_mode == RUN_MODE_CONNECTED)
  {
    user_button_disable();
    running_mode = RUN_MODE_WAITING_FOR_CONNECTION;
  }
  else
  {
    user_button_enable();
  }
  return;
}



hci_buffer_return_code_t hci_init(hci_t *hci)
{
  hci_buffer_return_code_t hVar1;
  hci_t *hci_local;
  
  hci->last_error = HCI_NO_ERROR;
  hci->rx_state = HCI_STATE_RX_IDLE;
  hci->tx_state = HCI_STATE_TX_IDLE;
  hci->has_datagram_available = false;
  hVar1 = hci_buffer_init(datagram_buffering,0x4000,&hci_buffer);
  if (hVar1 == HCI_BUFFER_RETURN_CODE_OK)
  {
    hci->hci_buffer = &hci_buffer;
  }
  else
  {
    hci->hci_buffer = (hci_buffer_t *)0x0;
  }
  return hVar1 != HCI_BUFFER_RETURN_CODE_OK;
}



void hci_reset_rx(hci_t *hci)
{
  hci_t *hci_local;
  
  hci->last_error = HCI_NO_ERROR;
  hci->rx_state = HCI_STATE_RX_IDLE;
  hci->has_datagram_available = false;
  return;
}



_Bool hci_has_datagram_available(hci_t *hci)
{
  hci_t *hci_local;
  
  return hci->has_datagram_available;
}



void hci_run(hci_t *hci)
{
  hci_tx_state_t hVar1;
  uint16_t uVar2;
  uint16_t uVar3;
  uint32_t uVar4;
  hci_t *hci_local;
  uint16_t remaining_bytes_to_send;
  uint32_t now_ms;
  
  if (false)
  {
code_r0x0800499e:
  }
  else
  {
    switch(hci->rx_state)
    {
    default:
      goto code_r0x0800499e;
    case HCI_STATE_RX_INIT:
      hci_register_waiting_dma(hci);
      uart_receive(hci->rx_buffer,3);
      hci->rx_state = HCI_STATE_RX_WAIT_HEADER;
      hci->has_datagram_available = false;
      break;
    case HCI_STATE_RX_WAIT_DATA:
      if ((rx_header_date != 0) && (uVar4 = support_timing_get_time(), 900 < uVar4 - rx_header_date)
         )
      {
        diagnostics_save_event('\"');
        hci->rx_state = HCI_STATE_RX_INIT;
        rx_header_date = 0;
      }
    }
  }
  hVar1 = hci->tx_state;
  if (hVar1 != HCI_STATE_TX_DATA_SENT)
  {
    if (HCI_STATE_TX_DATA_SENT < hVar1)
    {
      return;
    }
    if (hVar1 != HCI_STATE_TX_IDLE)
    {
      if (hVar1 != HCI_STATE_TX_SEND_DATA)
      {
        return;
      }
      if (hci->ack_to_send != false)
      {
        hci->ack_to_send = false;
        hci->tx_state = HCI_STATE_TX_SEND_ACK;
        hci_send_ack(hci);
        return;
      }
      if (hci->hci_buffer->bytes_stored == 0)
      {
        return;
      }
      uVar2 = hci->hci_buffer->bytes_stored;
      hci_buffer_pop(hci->hci_buffer,hci->tx_buffer,0x800);
      uVar3 = hci->hci_buffer->bytes_stored;
      hci_register_waiting_dma(hci);
      uart_send(hci->tx_buffer,(uint)(ushort)(uVar2 - uVar3));
      hci->tx_state = HCI_STATE_TX_WAIT_DATA_SENT;
      return;
    }
  }
  if ((hci->ack_to_send == false) && (hci->hci_buffer->bytes_stored == 0))
  {
    hci->tx_state = HCI_STATE_TX_IDLE;
  }
  else
  {
    hci->tx_state = HCI_STATE_TX_SEND_DATA;
  }
  return;
}



hci_return_code_t hci_start_rx(hci_t *hci)
{
  hci_return_code_t hVar1;
  hci_t *hci_local;
  
  if (hci->rx_state == HCI_STATE_RX_IDLE)
  {
    hci->rx_state = HCI_STATE_RX_INIT;
    hVar1 = HCI_RETURN_CODE_OK;
  }
  else
  {
    hVar1 = HCI_RETURN_CODE_BAD_STATE;
  }
  return hVar1;
}



hci_return_code_t hci_send_completed(hci_t *hci)
{
  hci_t *hci_local;
  
  hci->ack_to_send = true;
  return HCI_RETURN_CODE_OK;
}



hci_return_code_t hci_send_datagram(hci_t *hci,hci_datagram_t *datagram)
{
  hci_return_code_t hVar1;
  hci_datagram_t *datagram_local;
  hci_t *hci_local;
  
  hVar1 = hci_send_datagram_with_priority(hci,datagram,HCI_LOGS);
  return hVar1;
}



hci_return_code_t
hci_send_datagram_with_priority
          (hci_t *hci,hci_datagram_t *datagram,hci_priority_datagram_t priotrity)
{
  hci_buffer_return_code_t hVar1;
  hci_return_code_t hVar2;
  hci_priority_datagram_t priotrity_local;
  hci_datagram_t *datagram_local;
  hci_t *hci_local;
  
  if (datagram->length < 0x7fe)
  {
    if (priotrity == HCI_PROTOCOL)
    {
      diagnostics_save_event('\x11');
      hci_prepare_and_send_datagram(hci,datagram);
    }
    if (priotrity == HCI_LOGS)
    {
      hVar1 = hci_buffer_push(hci->hci_buffer,datagram);
      if (hVar1 == HCI_BUFFER_RETURN_CODE_OK)
      {
        diagnostics_save_event(0xdd);
        hVar2 = HCI_RETURN_CODE_OK_DATAGRAM_BUFFERED;
      }
      else
      {
        hVar2 = HCI_RETURN_CODE_ERROR_DATAGRAM_NOT_SENT;
      }
    }
    else
    {
      hVar2 = HCI_RETURN_CODE_OK;
    }
  }
  else
  {
    hVar2 = HCI_RETURN_CODE_TX_BUFFER_TOO_LOW;
  }
  return hVar2;
}



void hci_prepare_and_send_datagram(hci_t *hci,hci_datagram_t *datagram)
{
  hci_datagram_t *datagram_local;
  hci_t *hci_local;
  uint16_t data_index;
  
  hci->tx_buffer[0] = datagram->tag;
  hci->tx_buffer[1] = (uint8_t)(datagram->length >> 8);
  hci->tx_buffer[2] = (uint8_t)datagram->length;
  for (data_index = 0; data_index < datagram->length; data_index += 1)
  {
    hci->tx_buffer[data_index + 3] = datagram->data[data_index];
  }
  hci_register_waiting_dma(hci);
  uart_send(hci->tx_buffer,datagram->length + 3);
  return;
}



void hci_send_ack(hci_t *hci)
{
  hci_t *hci_local;
  hci_datagram_t ack;
  
  memset(&ack,0,0x804);
  diagnostics_save_event(0xa0);
  hci_send_datagram_with_priority(hci,&ack,HCI_PROTOCOL);
  return;
}



void hci_register_waiting_dma(hci_t *hci)
{
  hci_t *hci_local;
  
  waiting_dma = hci;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hci_unregister_waiting_dma(void)
{
  waiting_dma = (hci_t *)0x0;
  return;
}



void hci_check_and_unregister_waiting_dma(hci_t *hci)
{
  hci_t *hci_local;
  
  if ((hci->rx_state == HCI_STATE_RX_IDLE) && (hci->tx_state == HCI_STATE_TX_IDLE))
  {
    hci_unregister_waiting_dma();
  }
  return;
}



void hci_interrupt_handler(hci_t *hci,hci_irq_source_t irq_source)
{
  hci_irq_source_t irq_source_local;
  hci_t *hci_local;
  
  switch(irq_source)
  {
  case HCI_IRQ_SOURCE_TX:
    if (hci->tx_state == HCI_STATE_TX_SEND_ACK)
    {
      hci->tx_state = HCI_STATE_TX_DATA_SENT;
      diagnostics_save_event(0xaa);
      hci_check_and_unregister_waiting_dma(hci);
    }
    else if (hci->tx_state == HCI_STATE_TX_WAIT_DATA_SENT)
    {
      hci->tx_state = HCI_STATE_TX_DATA_SENT;
    }
    break;
  case HCI_IRQ_SOURCE_RX:
    if (hci->rx_state == HCI_STATE_RX_WAIT_HEADER)
    {
      (hci->datagram).tag = hci->rx_buffer[0];
      (hci->datagram).length = (ushort)hci->rx_buffer[2] + (ushort)hci->rx_buffer[1] * 0x100;
      if ((hci->datagram).length == 0)
      {
        hci->has_datagram_available = true;
        hci->rx_state = HCI_STATE_RX_IDLE;
      }
      else
      {
        hci->rx_state = HCI_STATE_RX_WAIT_DATA;
        hci_register_waiting_dma(hci);
        uart_receive((hci->datagram).data,(uint)(hci->datagram).length);
      }
      rx_header_date = support_timing_get_time();
    }
    else if (hci->rx_state == HCI_STATE_RX_WAIT_DATA)
    {
      diagnostics_save_event_with_data(0xee,(hci->datagram).data,(hci->datagram).length);
      hci->has_datagram_available = true;
      hci->rx_state = HCI_STATE_RX_IDLE;
    }
    else
    {
      diagnostics_save_event('D');
    }
    break;
  case HCI_IRQ_ERROR_TX:
    diagnostics_save_event('3');
    break;
  case HCI_IRQ_ERROR_RX:
    diagnostics_save_event('\"');
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hci_receive_callback(void)
{
  if (waiting_dma != (hci_t *)0x0)
  {
    hci_interrupt_handler(waiting_dma,HCI_IRQ_SOURCE_RX);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hci_transmit_callback(void)
{
  if (waiting_dma != (hci_t *)0x0)
  {
    hci_interrupt_handler(waiting_dma,HCI_IRQ_SOURCE_TX);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hci_receive_error_callback(void)
{
  if (waiting_dma != (hci_t *)0x0)
  {
    hci_interrupt_handler(waiting_dma,HCI_IRQ_ERROR_RX);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hci_transmit_error_callback(void)
{
  if (waiting_dma != (hci_t *)0x0)
  {
    hci_interrupt_handler(waiting_dma,HCI_IRQ_ERROR_TX);
  }
  return;
}



hci_buffer_return_code_t hci_buffer_init(uint8_t *buffer,uint32_t length,hci_buffer_t *hci_buffer)
{
  hci_buffer_return_code_t hVar1;
  hci_buffer_t *hci_buffer_local;
  uint32_t length_local;
  uint8_t *buffer_local;
  
  if (((buffer == (uint8_t *)0x0) || (length == 0)) || (0x4000 < length))
  {
    hVar1 = HCI_BUFFER_RETURN_CODE_BAD_PARAMETER;
  }
  else
  {
    hci_buffer->buffer = buffer;
    hci_buffer->size = (uint16_t)length;
    hci_buffer->bytes_stored = 0;
    hci_buffer->start_index = 0;
    hci_buffer->end_index = 0;
    memset(hci_buffer->buffer,0,length);
    hVar1 = HCI_BUFFER_RETURN_CODE_OK;
  }
  return hVar1;
}



hci_buffer_return_code_t hci_buffer_push(hci_buffer_t *hci_buffer,hci_datagram_t *datagram)
{
  uint16_t uVar1;
  hci_buffer_return_code_t hVar2;
  uint32_t uVar3;
  hci_datagram_t *datagram_local;
  hci_buffer_t *hci_buffer_local;
  uint32_t data_length_to_copy;
  
  data_length_to_copy = (uint32_t)datagram->length;
  if ((uint)hci_buffer->size < datagram->length + 3 + (uint)hci_buffer->bytes_stored)
  {
    hVar2 = HCI_BUFFER_RETURN_CODE_BUFFER_TOO_SMALL;
  }
  else
  {
    uVar3 = hci_buffer->end_index;
    hci_buffer->end_index = uVar3 + 1;
    hci_buffer->buffer[uVar3] = datagram->tag;
    hci_buffer->end_index =
         hci_buffer->end_index -
         (uint)hci_buffer->size * (hci_buffer->end_index / (uint)hci_buffer->size);
    uVar1 = datagram->length;
    uVar3 = hci_buffer->end_index;
    hci_buffer->end_index = uVar3 + 1;
    hci_buffer->buffer[uVar3] = (uint8_t)(uVar1 >> 8);
    hci_buffer->end_index =
         hci_buffer->end_index -
         (uint)hci_buffer->size * (hci_buffer->end_index / (uint)hci_buffer->size);
    uVar1 = datagram->length;
    uVar3 = hci_buffer->end_index;
    hci_buffer->end_index = uVar3 + 1;
    hci_buffer->buffer[uVar3] = (uint8_t)uVar1;
    hci_buffer->end_index =
         hci_buffer->end_index -
         (uint)hci_buffer->size * (hci_buffer->end_index / (uint)hci_buffer->size);
    if ((uint)hci_buffer->size < hci_buffer->end_index + (uint)datagram->length)
    {
      data_length_to_copy = (uint)hci_buffer->size - hci_buffer->end_index;
    }
    memcpy(hci_buffer->buffer + hci_buffer->end_index,datagram->data,data_length_to_copy);
    hci_buffer->end_index = hci_buffer->end_index + data_length_to_copy;
    hci_buffer->end_index =
         hci_buffer->end_index -
         (uint)hci_buffer->size * (hci_buffer->end_index / (uint)hci_buffer->size);
    if (data_length_to_copy != datagram->length)
    {
      hci_buffer->end_index = 0;
      memcpy(hci_buffer->buffer,datagram->data + data_length_to_copy,
             datagram->length - data_length_to_copy);
      hci_buffer->end_index = hci_buffer->end_index + (datagram->length - data_length_to_copy);
    }
    hci_buffer->bytes_stored = datagram->length + hci_buffer->bytes_stored + 3;
    hVar2 = HCI_BUFFER_RETURN_CODE_OK;
  }
  return hVar2;
}



hci_buffer_return_code_t hci_buffer_pop(hci_buffer_t *hci_buffer,uint8_t *tx_buffer,uint32_t size)
{
  ushort uVar1;
  ushort uVar2;
  hci_buffer_return_code_t hVar3;
  uint uVar4;
  uint uVar5;
  uint32_t size_local;
  uint8_t *tx_buffer_local;
  hci_buffer_t *hci_buffer_local;
  uint16_t nb_bytes_2nd_segment;
  uint16_t nb_bytes_1st_segment;
  uint16_t next_datagram_size;
  uint16_t output_buffer_index;
  uint32_t remaining_space;
  
  output_buffer_index = 0;
  if ((tx_buffer == (uint8_t *)0x0) || (size == 0))
  {
    hVar3 = HCI_BUFFER_RETURN_CODE_BAD_PARAMETER;
  }
  else
  {
    remaining_space = size;
    if (hci_buffer->bytes_stored == 0)
    {
      hVar3 = HCI_BUFFER_RETURN_CODE_EMPTY;
    }
    else
    {
      do
      {
        uVar4 = hci_buffer->start_index + 1;
        uVar5 = hci_buffer->start_index + 2;
        uVar1 = (ushort)hci_buffer->buffer
                        [uVar5 - (uint)hci_buffer->size * (uVar5 / hci_buffer->size)] +
                (ushort)hci_buffer->buffer
                        [uVar4 - (uint)hci_buffer->size * (uVar4 / hci_buffer->size)] * 0x100 + 3;
        if (remaining_space < uVar1)
        {
          if (remaining_space == size)
          {
            return HCI_BUFFER_RETURN_CODE_POP_OUTPUT_BUFFER_TOO_SMALL;
          }
          return HCI_BUFFER_RETURN_CODE_POP_OK_BUT_DATA_REMAINS;
        }
        if ((uint)hci_buffer->size < (uint)uVar1 + hci_buffer->start_index)
        {
          uVar2 = hci_buffer->size - (short)hci_buffer->start_index;
          memcpy(tx_buffer + output_buffer_index,hci_buffer->buffer + hci_buffer->start_index,
                 (uint)uVar2);
          memcpy(tx_buffer + (uint)uVar2 + (uint)output_buffer_index,hci_buffer->buffer,
                 (uint)(ushort)(uVar1 - uVar2));
        }
        else
        {
          memcpy(tx_buffer + output_buffer_index,hci_buffer->buffer + hci_buffer->start_index,
                 (uint)uVar1);
        }
        output_buffer_index = uVar1 + output_buffer_index;
        uVar4 = (uint)uVar1 + hci_buffer->start_index;
        hci_buffer->start_index = uVar4 - (uint)hci_buffer->size * (uVar4 / hci_buffer->size);
        hci_buffer->bytes_stored = hci_buffer->bytes_stored - uVar1;
        remaining_space -= uVar1;
      } while (hci_buffer->bytes_stored != 0);
      hVar3 = HCI_BUFFER_RETURN_CODE_OK;
    }
  }
  return hVar3;
}



_Bool datagram_parser_parse(size_t length,uint8_t *buffer,command_t *command)
{
  DeviceMessage__ToDevice *message;
  size_t sVar1;
  DeviceMessage__Demo DVar2;
  command_t *command_local;
  uint8_t *buffer_local;
  size_t length_local;
  size_t configuration_buffer_size;
  DeviceMessage__ToDevice *to_device;
  _Bool datagram_valid;
  
  message = device_message__to_device__unpack((ProtobufCAllocator *)0x0,length,buffer);
  datagram_valid = true;
  switch(message->message_case)
  {
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE__NOT_SET:
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_START_DEMO:
    command->type = COMMAND_TYPE_START_DEMO;
    switch(((message->field_2).start_demo)->demo)
    {
    case DEVICE_MESSAGE__DEMO__DEMO_TX_CW:
      (command->argument).set_configuration.buffer[0] = '\0';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_PER:
      (command->argument).set_configuration.buffer[0] = '\x01';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_EXAMPLE:
      (command->argument).set_configuration.buffer[0] = '\x02';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_STATIC_MODE:
      (command->argument).set_configuration.buffer[0] = '\x03';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG:
      (command->argument).set_configuration.buffer[0] = '\x04';
      break;
    default:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,"Received <Start Demo> command with unknown demo index : %d",
                          ((message->field_2).start_demo)->demo);
    }
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_STOP_DEMO:
    command->type = COMMAND_TYPE_STOP_DEMO;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_GET_CONFIGURATION:
    command->type = COMMAND_TYPE_GET_CONFIGURATION;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_SET_CONFIGURATION:
    command->type = COMMAND_TYPE_SET_CONFIGURATION;
    sVar1 = device_message__configuration__get_packed_size((message->field_2).set_configuration);
    if (sVar1 < 0x7fe)
    {
      (command->argument).set_configuration.buffer_length = (uint16_t)sVar1;
      device_message__configuration__pack
                ((message->field_2).set_configuration,&(command->argument).start_demo.demo_to_start)
      ;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,
                          "Configuration message is too big, cannot process it. MAX size: %d, received size: %d"
                          ,0x7fe,sVar1);
    }
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_SET_SHIELD:
    command->type = COMMAND_TYPE_SET_SHIELD;
    DVar2 = ((message->field_2).start_demo)->demo;
    if (DVar2 < 0xf)
    {
      switch(DVar2)
      {
      case DEVICE_MESSAGE__DEMO__DEMO_TX_CW:
        (command->argument).set_configuration.buffer[0] = '\0';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PER:
        (command->argument).set_configuration.buffer[0] = '\x01';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_EXAMPLE:
        (command->argument).set_configuration.buffer[0] = '\x02';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_STATIC_MODE:
        (command->argument).set_configuration.buffer[0] = '\x03';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG:
        (command->argument).set_configuration.buffer[0] = '\x04';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG|DEVICE_MESSAGE__DEMO__DEMO_PER:
        (command->argument).set_configuration.buffer[0] = '\x05';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG|DEVICE_MESSAGE__DEMO__DEMO_EXAMPLE:
        (command->argument).set_configuration.buffer[0] = '\x06';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG|DEVICE_MESSAGE__DEMO__DEMO_STATIC_MODE:
        (command->argument).set_configuration.buffer[0] = '\a';
        break;
      case 8:
        (command->argument).set_configuration.buffer[0] = '\b';
        break;
      case 9:
        (command->argument).set_configuration.buffer[0] = '\t';
        break;
      case 10:
        (command->argument).set_configuration.buffer[0] = '\n';
        break;
      case 0xb:
        (command->argument).set_configuration.buffer[0] = '\v';
        break;
      case 0xc:
        (command->argument).set_configuration.buffer[0] = '\f';
        break;
      case 0xd:
        (command->argument).set_configuration.buffer[0] = '\r';
        break;
      case 0xe:
        (command->argument).set_configuration.buffer[0] = '\x0e';
        break;
      default:
        goto switchD_080052ea_default;
      }
    }
    else
    {
      if (DVar2 == 0xff)
      {
        (command->argument).set_configuration.buffer[0] = '\x0f';
        break;
      }
switchD_080052ea_default:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,"Receive <Set Shield> command with unknown shield: %d",
                          ((message->field_2).start_demo)->demo);
    }
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_GET_SHIELD:
    command->type = COMMAND_TYPE_GET_SHIELD;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_GET_ALL_SHIELDS:
    command->type = COMMAND_TYPE_GET_ALL_SHIELDS;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_GET_VERSION_INFORMATION:
    command->type = COMMAND_TYPE_GET_VERSION_INFORMATION;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_IDENTIFY:
    command->type = COMMAND_TYPE_IDENTIFY;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_STORE_CURRENT_CONFIGURATION_IN_NVM:
    command->type = COMMAND_TYPE_STORE_CURRENT_CONFIGURATION_IN_NVM;
    switch(((message->field_2).store_current_configuration_in_nvm)->demo)
    {
    case DEVICE_MESSAGE__DEMO__DEMO_TX_CW:
      (command->argument).set_configuration.buffer[1] = '\0';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_PER:
      (command->argument).set_configuration.buffer[1] = '\x01';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_EXAMPLE:
      (command->argument).set_configuration.buffer[1] = '\x02';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_STATIC_MODE:
      (command->argument).set_configuration.buffer[1] = '\x03';
      break;
    case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG:
      (command->argument).set_configuration.buffer[1] = '\x04';
      break;
    default:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,"Received <Start Demo> command with unknown demo index : %d",
                          ((message->field_2).start_demo)->demo);
    }
    DVar2 = ((message->field_2).start_demo)->demo;
    if (DVar2 < 0xf)
    {
      switch(DVar2)
      {
      case DEVICE_MESSAGE__DEMO__DEMO_TX_CW:
        (command->argument).set_configuration.buffer[0] = '\0';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PER:
        (command->argument).set_configuration.buffer[0] = '\x01';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_EXAMPLE:
        (command->argument).set_configuration.buffer[0] = '\x02';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_STATIC_MODE:
        (command->argument).set_configuration.buffer[0] = '\x03';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG:
        (command->argument).set_configuration.buffer[0] = '\x04';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG|DEVICE_MESSAGE__DEMO__DEMO_PER:
        (command->argument).set_configuration.buffer[0] = '\x05';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG|DEVICE_MESSAGE__DEMO__DEMO_EXAMPLE:
        (command->argument).set_configuration.buffer[0] = '\x06';
        break;
      case DEVICE_MESSAGE__DEMO__DEMO_PING_PONG|DEVICE_MESSAGE__DEMO__DEMO_STATIC_MODE:
        (command->argument).set_configuration.buffer[0] = '\a';
        break;
      case 8:
        (command->argument).set_configuration.buffer[0] = '\b';
        break;
      case 9:
        (command->argument).set_configuration.buffer[0] = '\t';
        break;
      case 10:
        (command->argument).set_configuration.buffer[0] = '\n';
        break;
      case 0xb:
        (command->argument).set_configuration.buffer[0] = '\v';
        break;
      case 0xc:
        (command->argument).set_configuration.buffer[0] = '\f';
        break;
      case 0xd:
        (command->argument).set_configuration.buffer[0] = '\r';
        break;
      case 0xe:
        (command->argument).set_configuration.buffer[0] = '\x0e';
        break;
      default:
        goto switchD_08005460_default;
      }
    }
    else
    {
      if (DVar2 == 0xff)
      {
        (command->argument).set_configuration.buffer[0] = '\x0f';
        break;
      }
switchD_08005460_default:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,"Receive <Set Shield> command with unknown shield: %d",
                          ((message->field_2).start_demo)->demo);
    }
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_NVM_FACTORY_RESET:
    command->type = COMMAND_TYPE_FACTORY_RESET_NVM;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_LOAD_FROM_NVM:
    command->type = COMMAND_TYPE_LOAD_CONFIGURATION_FROM_NVM;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_SET_RUNNING_MODE:
    command->type = COMMAND_TYPE_SET_RUNNING_MODE;
    if (((message->field_2).start_demo)->demo == DEVICE_MESSAGE__DEMO__DEMO_TX_CW)
    {
      (command->argument).set_configuration.buffer[0] = '\0';
    }
    if (((message->field_2).start_demo)->demo == DEVICE_MESSAGE__DEMO__DEMO_PER)
    {
      (command->argument).set_configuration.buffer[0] = '\x01';
    }
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_GET_RUNNING_MODE:
    command->type = COMMAND_TYPE_GET_RUNNING_MODE;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_GET_NVM_LOGS_SIZE:
    command->type = COMMAND_TYPE_GET_NVM_LOGS_SIZE;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_DUMP_NVM_LOGS:
    command->type = COMMAND_TYPE_DUMP_NVM_LOGS;
    break;
  case DEVICE_MESSAGE__TO_DEVICE__MESSAGE_PUSH_BUTTON:
    command->type = COMMAND_TYPE_PUSH_BUTTON;
    break;
  default:
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Received unknown message: %d",message->message_case);
    datagram_valid = false;
  }
  device_message__to_device__free_unpacked(message,(ProtobufCAllocator *)0x0);
  return datagram_valid;
}



_Bool datagram_parser_prepare_log
                (char *string,DeviceMessage__Level level,DeviceMessage__LogSource type,
                uint8_t *buffer,uint16_t *packed_buffer_length,uint16_t max_length)
{
  ushort uVar1;
  size_t sVar2;
  uint8_t *buffer_local;
  DeviceMessage__LogSource type_local;
  DeviceMessage__Level level_local;
  char *string_local;
  DeviceMessage__Log log_message;
  
  log_message.base.descriptor = &device_message__log__descriptor;
  log_message.base.n_unknown_fields = 0;
  log_message.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  log_message.message = string;
  log_message.level = level;
  log_message.type = type;
  sVar2 = device_message__log__get_packed_size(&log_message);
  *packed_buffer_length = (uint16_t)sVar2;
  uVar1 = *packed_buffer_length;
  if (uVar1 <= max_length)
  {
    device_message__log__pack(&log_message,buffer);
  }
  return uVar1 <= max_length;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_uart_inst_t * get_uart_instance(void)
{
  return &inst_uart;
}



void uart_init(_func_void *callback_rx,_func_void *callback_tx,_func_void *callback_error_rx,
              _func_void *callback_error_tx)
{
  smtc_hal_mcu_status_t sVar1;
  _func_void *callback_error_tx_local;
  _func_void *callback_error_rx_local;
  _func_void *callback_tx_local;
  _func_void *callback_rx_local;
  smtc_hal_mcu_status_t status;
  
  sVar1 = support_uart_init(callback_rx,callback_tx,callback_error_rx,callback_error_tx);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029acc,0x8033a34,0x59,0x8029ab0);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029acc,0x8033a34,0x59,(uint)sVar1);
    }
  }
  return;
}



void uart_send(uint8_t *buffer,uint32_t length)
{
  smtc_hal_mcu_status_t sVar1;
  uint32_t length_local;
  uint8_t *buffer_local;
  smtc_hal_mcu_status_t status;
  
  sVar1 = smtc_hal_mcu_uart_dma_send(inst_uart,buffer,length);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029acc,0x8033a40,0x5e,0x8029ab0);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029acc,0x8033a40,0x5e,(uint)sVar1);
    }
  }
  return;
}



void uart_receive(uint8_t *buffer,uint32_t length)
{
  uint32_t length_local;
  uint8_t *buffer_local;
  uint32_t retry_cnt;
  smtc_hal_mcu_status_t status;
  
  status = smtc_hal_mcu_uart_dma_receive(inst_uart,buffer,length);
  if (status != SMTC_HAL_MCU_STATUS_OK)
  {
    for (retry_cnt = 0; (status != SMTC_HAL_MCU_STATUS_OK && (retry_cnt < 1000)); retry_cnt += 1)
    {
      while (status != SMTC_HAL_MCU_STATUS_OK)
      {
        status = smtc_hal_mcu_uart_dma_abort_rx(inst_uart);
        smtc_hal_mcu_wait_ms(10);
      }
      status = smtc_hal_mcu_uart_dma_receive(inst_uart,buffer,length);
    }
  }
  return;
}



demo_status_t demo_start(demo_t *demo)
{
  demo_status_t dVar1;
  demo_t *demo_local;
  
  dVar1 = (*demo->vtable->demo_start)(demo);
  return dVar1;
}



demo_status_t demo_stop(demo_t *demo)
{
  demo_status_t dVar1;
  demo_t *demo_local;
  
  dVar1 = (*demo->vtable->demo_stop)(demo);
  return dVar1;
}



demo_status_t demo_runtime(demo_t *demo)
{
  demo_status_t dVar1;
  demo_t *demo_local;
  
  dVar1 = (*demo->vtable->demo_runtime)(demo);
  return dVar1;
}



void demo_register_configurations_to_manager(demo_t *demo,configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  demo_t *demo_local;
  
  (*demo->vtable->register_configurations_to_manager)(demo,manager);
  return;
}



void demo_manager_register_demos(configuration_manager_t *manager)
{
  demo_interface_t *local_a8;
  char acStack_a4 [4];
  char acStack_a0 [4];
  char acStack_9c [4];
  char local_98 [4];
  char acStack_94 [4];
  char acStack_90 [12];
  configuration_item_interface_t *pcStack_84;
  size_t sStack_80;
  static_mode_t sStack_7c;
  undefined3 uStack_7b;
  static_mode_t local_78;
  undefined3 uStack_77;
  demo_interface_t *local_50;
  char acStack_4c [4];
  char acStack_48 [4];
  char acStack_44 [4];
  char local_40 [4];
  char acStack_3c [4];
  char acStack_38 [8];
  configuration_item_interface_t *local_30;
  size_t sStack_2c;
  uint32_t uStack_28;
  _Bool _Stack_24;
  undefined3 uStack_23;
  uint32_t local_20;
  configuration_manager_t *manager_local;
  
  manager_local = manager;
  demo_example_get_instance();
  demo_manager_register_demos::demo_example.base.vtable = local_50;
  demo_manager_register_demos::demo_example.base.demo_name[0] = acStack_4c[0];
  demo_manager_register_demos::demo_example.base.demo_name[1] = acStack_4c[1];
  demo_manager_register_demos::demo_example.base.demo_name[2] = acStack_4c[2];
  demo_manager_register_demos::demo_example.base.demo_name[3] = acStack_4c[3];
  demo_manager_register_demos::demo_example.base.demo_name[4] = acStack_48[0];
  demo_manager_register_demos::demo_example.base.demo_name[5] = acStack_48[1];
  demo_manager_register_demos::demo_example.base.demo_name[6] = acStack_48[2];
  demo_manager_register_demos::demo_example.base.demo_name[7] = acStack_48[3];
  demo_manager_register_demos::demo_example.base.demo_name[8] = acStack_44[0];
  demo_manager_register_demos::demo_example.base.demo_name[9] = acStack_44[1];
  demo_manager_register_demos::demo_example.base.demo_name[10] = acStack_44[2];
  demo_manager_register_demos::demo_example.base.demo_name[0xb] = acStack_44[3];
  demo_manager_register_demos::demo_example.base.demo_name[0xc] = local_40[0];
  demo_manager_register_demos::demo_example.base.demo_name[0xd] = local_40[1];
  demo_manager_register_demos::demo_example.base.demo_name[0xe] = local_40[2];
  demo_manager_register_demos::demo_example.base.demo_name[0xf] = local_40[3];
  demo_manager_register_demos::demo_example.base.demo_name[0x10] = acStack_3c[0];
  demo_manager_register_demos::demo_example.base.demo_name[0x11] = acStack_3c[1];
  demo_manager_register_demos::demo_example.base.demo_name[0x12] = acStack_3c[2];
  demo_manager_register_demos::demo_example.base.demo_name[0x13] = acStack_3c[3];
  demo_manager_register_demos::demo_example.base.demo_name[0x14] = acStack_38[0];
  demo_manager_register_demos::demo_example.base.demo_name[0x15] = acStack_38[1];
  demo_manager_register_demos::demo_example.base.demo_name[0x16] = acStack_38[2];
  demo_manager_register_demos::demo_example.base.demo_name[0x17] = acStack_38[3];
  demo_manager_register_demos::demo_example.base.demo_name[0x18] = acStack_38[4];
  demo_manager_register_demos::demo_example.base.demo_id = acStack_38[5];
  demo_manager_register_demos::demo_example.base._30_1_ = acStack_38[6];
  demo_manager_register_demos::demo_example.base._31_1_ = acStack_38[7];
  demo_manager_register_demos::demo_example.delay_ms.base.vtable = local_30;
  demo_manager_register_demos::demo_example.delay_ms.base.size = sStack_2c;
  demo_manager_register_demos::demo_example.delay_ms.val = uStack_28;
  demo_manager_register_demos::demo_example.running = _Stack_24;
  demo_manager_register_demos::demo_example._45_3_ = uStack_23;
  demo_manager_register_demos::demo_example.iteration = local_20;
  demo_per_get_instance();
  memcpy(&demo_manager_register_demos::demo_per,&local_a8,0x54);
  demo_static_mode_get_instance();
  demo_manager_register_demos::demo_static_mode.base.vtable = local_a8;
  demo_manager_register_demos::demo_static_mode.base.demo_name[0] = acStack_a4[0];
  demo_manager_register_demos::demo_static_mode.base.demo_name[1] = acStack_a4[1];
  demo_manager_register_demos::demo_static_mode.base.demo_name[2] = acStack_a4[2];
  demo_manager_register_demos::demo_static_mode.base.demo_name[3] = acStack_a4[3];
  demo_manager_register_demos::demo_static_mode.base.demo_name[4] = acStack_a0[0];
  demo_manager_register_demos::demo_static_mode.base.demo_name[5] = acStack_a0[1];
  demo_manager_register_demos::demo_static_mode.base.demo_name[6] = acStack_a0[2];
  demo_manager_register_demos::demo_static_mode.base.demo_name[7] = acStack_a0[3];
  demo_manager_register_demos::demo_static_mode.base.demo_name[8] = acStack_9c[0];
  demo_manager_register_demos::demo_static_mode.base.demo_name[9] = acStack_9c[1];
  demo_manager_register_demos::demo_static_mode.base.demo_name[10] = acStack_9c[2];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0xb] = acStack_9c[3];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0xc] = local_98[0];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0xd] = local_98[1];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0xe] = local_98[2];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0xf] = local_98[3];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x10] = acStack_94[0];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x11] = acStack_94[1];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x12] = acStack_94[2];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x13] = acStack_94[3];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x14] = acStack_90[0];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x15] = acStack_90[1];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x16] = acStack_90[2];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x17] = acStack_90[3];
  demo_manager_register_demos::demo_static_mode.base.demo_name[0x18] = acStack_90[4];
  demo_manager_register_demos::demo_static_mode.base.demo_id = acStack_90[5];
  demo_manager_register_demos::demo_static_mode.base._30_1_ = acStack_90[6];
  demo_manager_register_demos::demo_static_mode.base._31_1_ = acStack_90[7];
  demo_manager_register_demos::demo_static_mode.running = (_Bool)acStack_90[8];
  demo_manager_register_demos::demo_static_mode._33_1_ = acStack_90[9];
  demo_manager_register_demos::demo_static_mode._34_1_ = acStack_90[10];
  demo_manager_register_demos::demo_static_mode._35_1_ = acStack_90[0xb];
  demo_manager_register_demos::demo_static_mode.configuration_mode.base.vtable = pcStack_84;
  demo_manager_register_demos::demo_static_mode.configuration_mode.base.size = sStack_80;
  demo_manager_register_demos::demo_static_mode.configuration_mode.val = sStack_7c;
  demo_manager_register_demos::demo_static_mode.configuration_mode._9_3_ = uStack_7b;
  demo_manager_register_demos::demo_static_mode.radio_mode = local_78;
  demo_manager_register_demos::demo_static_mode._49_3_ = uStack_77;
  demo_tx_cw_get_instance();
  demo_manager_register_demos::demo_tx_cw.base.vtable = local_a8;
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0] = acStack_a4[0];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[1] = acStack_a4[1];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[2] = acStack_a4[2];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[3] = acStack_a4[3];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[4] = acStack_a0[0];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[5] = acStack_a0[1];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[6] = acStack_a0[2];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[7] = acStack_a0[3];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[8] = acStack_9c[0];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[9] = acStack_9c[1];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[10] = acStack_9c[2];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0xb] = acStack_9c[3];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0xc] = local_98[0];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0xd] = local_98[1];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0xe] = local_98[2];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0xf] = local_98[3];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x10] = acStack_94[0];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x11] = acStack_94[1];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x12] = acStack_94[2];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x13] = acStack_94[3];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x14] = acStack_90[0];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x15] = acStack_90[1];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x16] = acStack_90[2];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x17] = acStack_90[3];
  demo_manager_register_demos::demo_tx_cw.base.demo_name[0x18] = acStack_90[4];
  demo_manager_register_demos::demo_tx_cw.base.demo_id = acStack_90[5];
  demo_manager_register_demos::demo_tx_cw.base._30_1_ = acStack_90[6];
  demo_manager_register_demos::demo_tx_cw.base._31_1_ = acStack_90[7];
  demo_ping_pong_get_instance();
  memcpy(&demo_manager_register_demos::demo_ping_pong,&local_a8,0x60);
  demo_register_configurations_to_manager
            (&demo_manager_register_demos::demo_example.base,manager_local);
  demo_register_configurations_to_manager(&demo_manager_register_demos::demo_per.base,manager_local)
  ;
  demo_register_configurations_to_manager
            (&demo_manager_register_demos::demo_static_mode.base,manager_local);
  demo_register_configurations_to_manager
            (&demo_manager_register_demos::demo_tx_cw.base,manager_local);
  demo_register_configurations_to_manager
            (&demo_manager_register_demos::demo_ping_pong.base,manager_local);
  demo_manager_register_demo(DEMO_EXAMPLE,&demo_manager_register_demos::demo_example.base);
  demo_manager_register_demo(DEMO_PER,&demo_manager_register_demos::demo_per.base);
  demo_manager_register_demo(DEMO_STATIC_MODE,&demo_manager_register_demos::demo_static_mode.base);
  demo_manager_register_demo(DEMO_TX_CW,&demo_manager_register_demos::demo_tx_cw.base);
  demo_manager_register_demo(DEMO_PING_PONG,&demo_manager_register_demos::demo_ping_pong.base);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_manager_print_registered_demos(void)
{
  demo_manager_demo_registry_item_t local_item;
  uint8_t index_registry;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Demo(s) available to run :");
  for (index_registry = '\0'; index_registry < n_demo_registry; index_registry += '\x01')
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "\t- %s",(DEMO_REGISTRY[index_registry].demo)->demo_name);
  }
  return;
}



void demo_manager_interpret_command(command_t *command)
{
  command_type_t cVar1;
  demo_t *demo_00;
  command_t *command_local;
  demo_t *demo;
  command_demo_t demo_to_start;
  
  cVar1 = command->type;
  if (cVar1 == COMMAND_TYPE_PUSH_BUTTON)
  {
    emulate_button_press();
  }
  else if (cVar1 < (COMMAND_TYPE_PUSH_BUTTON|COMMAND_TYPE_STOP_DEMO))
  {
    if (cVar1 == COMMAND_TYPE_START_DEMO)
    {
      if (running_demo == (demo_t *)0x0)
      {
        demo_00 = demo_manager_get_demo_from_registry
                            ((command->argument).set_configuration.buffer[0]);
        demo_manager_start_demo(demo_00);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"Demo already running, stop it before start running another one");
      }
    }
    else if (cVar1 == COMMAND_TYPE_STOP_DEMO)
    {
      demo_manager_stop_running_demo();
    }
  }
  return;
}



// WARNING: Unknown calling convention

uint8_t demo_manager_get_last_run_demo_id(void)
{
  return last_running_demo->demo_id;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_manager_runtime_demo(void)
{
  _Bool _Var1;
  
  _Var1 = is_running_mode_connected();
  if (!_Var1)
  {
    demo_manager_runtime_demo::state = DEMO_MANAGER_RUNTIME_BUTTON_CTRL;
  }
  if (demo_manager_runtime_demo::state == DEMO_MANAGER_RUNTIME_BUTTON_CTRL)
  {
    _Var1 = get_and_clear_button_pressed();
    if (_Var1)
    {
      if (running_demo == (demo_t *)0x0)
      {
        if (demo_config_load_from_nvm != false)
        {
          demo_manager_start_demo(last_running_demo);
        }
      }
      else
      {
        demo_manager_stop_running_demo();
        dynamic_log_message_back_up();
      }
    }
    demo_manager_check_demo_status();
    _Var1 = is_running_mode_connected();
    if (_Var1)
    {
      demo_manager_runtime_demo::state = DEMO_MANAGER_RUNTIME_HOST_CTRL;
      demo_manager_stop_running_demo();
    }
  }
  else if (demo_manager_runtime_demo::state == DEMO_MANAGER_RUNTIME_HOST_CTRL)
  {
    demo_manager_check_demo_status();
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_manager_check_demo_status(void)
{
  demo_status_t dVar1;
  _Bool _Var2;
  demo_status_t demo_status;
  
  if (running_demo != (demo_t *)0x0)
  {
    dVar1 = demo_runtime(running_demo);
    if ((dVar1 == DEMO_STATUS_FINISHED) || (dVar1 == DEMO_STATUS_ERROR))
    {
      running_demo = (demo_t *)0x0;
      _Var2 = is_running_mode_connected();
      if (!_Var2)
      {
        dynamic_log_message_back_up();
      }
    }
  }
  return;
}



void demo_manager_load_demo_to_start_from_nvm(configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  uint8_t demo_id;
  config_manager_nvm_status_type_t status;
  demo_t *demo;
  
  status = config_manager_nvm_retrieve_demo_to_start(&demo_id);
  if (status == CONFIG_MANAGER_NVM_OK)
  {
    demo = demo_manager_get_demo_from_registry(demo_id);
  }
  else
  {
    if (status == CONFIG_MANAGER_NVM_NOT_FOUND)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          true,
                          "Demo to run at startup not found in NVM, will run PER transmitter as default"
                         );
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,
                          "Error while ready NVM to find demo to run at start up, running PER as default"
                         );
    }
    demo_id = '\x01';
    demo = demo_manager_get_demo_from_registry(DEMO_PER);
    demo_per_set_as_transmitter(demo);
  }
  last_running_demo = demo;
  demo_config_load_from_nvm = true;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_manager_stop_running_demo(void)
{
  if (running_demo == (demo_t *)0x0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Demo stopped");
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Stopping Demo %s",running_demo->demo_name);
    demo_stop(running_demo);
    running_demo = (demo_t *)0x0;
  }
  return;
}



void demo_manager_start_demo(demo_t *demo)
{
  demo_t *pdVar1;
  demo_t *pdVar2;
  demo_status_t dVar3;
  char *pcVar4;
  demo_t *demo_local;
  
  if (demo == (demo_t *)0x0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Demo not registered hence not available to start");
    pdVar1 = running_demo;
    pdVar2 = last_running_demo;
  }
  else
  {
    pcVar4 = demo->demo_name;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Starting Demo %s",pcVar4);
    dVar3 = demo_start(demo);
    pdVar1 = demo;
    pdVar2 = demo;
    if (dVar3 != DEMO_STATUS_OK)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,"Demo could not be started",pcVar4);
      pdVar1 = running_demo;
      pdVar2 = last_running_demo;
    }
  }
  last_running_demo = pdVar2;
  running_demo = pdVar1;
  return;
}



void demo_manager_register_demo(command_demo_t cmd_demo,demo_t *demo)
{
  uint uVar1;
  demo_t *demo_local;
  command_demo_t cmd_demo_local;
  
  if (n_demo_registry < 5)
  {
    uVar1 = (uint)n_demo_registry;
    DEMO_REGISTRY[uVar1].cmd_demo = cmd_demo;
    DEMO_REGISTRY[uVar1].demo = demo;
    n_demo_registry += '\x01';
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Trying to register more demo than memory space allows");
  }
  return;
}



demo_t * demo_manager_get_demo_from_registry(command_demo_t cmd_demo)
{
  command_demo_t cmd_demo_local;
  demo_manager_demo_registry_item_t local_item;
  uint8_t index_registry;
  
  index_registry = '\0';
  while( true )
  {
    if (n_demo_registry <= index_registry)
    {
      return (demo_t *)0x0;
    }
    if ((uint)cmd_demo == (*(uint *)(DEMO_REGISTRY + index_registry) & 0xff)) break;
    index_registry += '\x01';
  }
  return DEMO_REGISTRY[index_registry].demo;
}



ral_status_t ral_reset(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).reset)(radio->context);
  return rVar1;
}



ral_status_t ral_set_rx_tx_fallback_mode(ral_t *radio,ral_fallback_modes_t fallback_mode)
{
  ral_status_t rVar1;
  ral_fallback_modes_t fallback_mode_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_rx_tx_fallback_mode)(radio->context,fallback_mode);
  return rVar1;
}



ral_status_t
ral_get_pkt_payload(ral_t *radio,uint16_t max_size_in_bytes,uint8_t *buffer,uint16_t *size_in_bytes)
{
  ral_status_t rVar1;
  uint16_t *size_in_bytes_local;
  uint8_t *buffer_local;
  uint16_t max_size_in_bytes_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).get_pkt_payload)(radio->context,max_size_in_bytes,buffer,size_in_bytes);
  return rVar1;
}



ral_status_t ral_clear_irq_status(ral_t *radio,ral_irq_t irq)
{
  ral_status_t rVar1;
  ral_irq_t irq_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).clear_irq_status)(radio->context,irq);
  return rVar1;
}



ral_status_t ral_get_and_clear_irq_status(ral_t *radio,ral_irq_t *irq)
{
  ral_status_t rVar1;
  ral_irq_t *irq_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).get_and_clear_irq_status)(radio->context,irq);
  return rVar1;
}



ral_status_t ral_set_rf_freq(ral_t *radio,uint32_t freq_in_hz)
{
  ral_status_t rVar1;
  uint32_t freq_in_hz_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_rf_freq)(radio->context,freq_in_hz);
  return rVar1;
}



ral_status_t ral_set_gfsk_mod_params(ral_t *radio,ral_gfsk_mod_params_t *params)
{
  ral_status_t rVar1;
  ral_gfsk_mod_params_t *params_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_gfsk_mod_params)(radio->context,params);
  return rVar1;
}



ral_status_t ral_set_gfsk_pkt_params(ral_t *radio,ral_gfsk_pkt_params_t *params)
{
  ral_status_t rVar1;
  ral_gfsk_pkt_params_t *params_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_gfsk_pkt_params)(radio->context,params);
  return rVar1;
}



ral_status_t ral_set_gfsk_pkt_address(ral_t *radio,uint8_t node_address,uint8_t broadcast_address)
{
  ral_status_t rVar1;
  uint8_t broadcast_address_local;
  uint8_t node_address_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_gfsk_pkt_address)(radio->context,node_address,broadcast_address);
  return rVar1;
}



ral_status_t ral_set_lora_mod_params(ral_t *radio,ral_lora_mod_params_t *params)
{
  ral_status_t rVar1;
  ral_lora_mod_params_t *params_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_lora_mod_params)(radio->context,params);
  return rVar1;
}



ral_status_t ral_set_lora_pkt_params(ral_t *radio,ral_lora_pkt_params_t *params)
{
  ral_status_t rVar1;
  ral_lora_pkt_params_t *params_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_lora_pkt_params)(radio->context,params);
  return rVar1;
}



ral_status_t ral_get_gfsk_rx_pkt_status(ral_t *radio,ral_gfsk_rx_pkt_status_t *rx_pkt_status)
{
  ral_status_t rVar1;
  ral_gfsk_rx_pkt_status_t *rx_pkt_status_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).get_gfsk_rx_pkt_status)(radio->context,rx_pkt_status);
  return rVar1;
}



ral_status_t ral_get_lora_rx_pkt_status(ral_t *radio,ral_lora_rx_pkt_status_t *rx_pkt_status)
{
  ral_status_t rVar1;
  ral_lora_rx_pkt_status_t *rx_pkt_status_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).get_lora_rx_pkt_status)(radio->context,rx_pkt_status);
  return rVar1;
}



uint32_t ral_get_lora_time_on_air_in_ms
                   (ral_t *radio,ral_lora_pkt_params_t *pkt_p,ral_lora_mod_params_t *mod_p)
{
  uint32_t uVar1;
  ral_lora_mod_params_t *mod_p_local;
  ral_lora_pkt_params_t *pkt_p_local;
  ral_t *radio_local;
  
  uVar1 = (*(radio->driver).get_lora_time_on_air_in_ms)(pkt_p,mod_p);
  return uVar1;
}



uint32_t ral_get_gfsk_time_on_air_in_ms
                   (ral_t *radio,ral_gfsk_pkt_params_t *pkt_p,ral_gfsk_mod_params_t *mod_p)
{
  uint32_t uVar1;
  ral_gfsk_mod_params_t *mod_p_local;
  ral_gfsk_pkt_params_t *pkt_p_local;
  ral_t *radio_local;
  
  uVar1 = (*(radio->driver).get_gfsk_time_on_air_in_ms)(pkt_p,mod_p);
  return uVar1;
}



ral_status_t ral_set_gfsk_sync_word(ral_t *radio,uint8_t *sync_word,uint8_t sync_word_len)
{
  ral_status_t rVar1;
  uint8_t sync_word_len_local;
  uint8_t *sync_word_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_gfsk_sync_word)(radio->context,sync_word,sync_word_len);
  return rVar1;
}



ral_status_t ral_set_lora_sync_word(ral_t *radio,uint8_t sync_word)
{
  ral_status_t rVar1;
  uint8_t sync_word_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_lora_sync_word)(radio->context,sync_word);
  return rVar1;
}



ral_status_t ral_set_gfsk_crc_params(ral_t *radio,uint32_t seed,uint32_t polynomial)
{
  ral_status_t rVar1;
  uint32_t polynomial_local;
  uint32_t seed_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_gfsk_crc_params)(radio->context,seed,polynomial);
  return rVar1;
}



ral_status_t ral_set_gfsk_whitening_seed(ral_t *radio,uint16_t seed)
{
  ral_status_t rVar1;
  uint16_t seed_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_gfsk_whitening_seed)(radio->context,seed);
  return rVar1;
}



uint8_t apps_common_compute_lora_ldro(ral_lora_sf_t sf,ral_lora_bw_t bw)
{
  uint8_t uVar1;
  ral_lora_bw_t bw_local;
  ral_lora_sf_t sf_local;
  
  switch(bw)
  {
  case RAL_LORA_BW_010_KHZ:
  case RAL_LORA_BW_015_KHZ:
  case RAL_LORA_BW_020_KHZ:
  case RAL_LORA_BW_031_KHZ:
    uVar1 = '\x01';
    break;
  case RAL_LORA_BW_041_KHZ:
    if (((sf == RAL_LORA_SF12) || (sf == RAL_LORA_SF11)) ||
       ((sf == RAL_LORA_SF10 || (sf == RAL_LORA_SF9))))
    {
      uVar1 = '\x01';
    }
    else
    {
      uVar1 = '\0';
    }
    break;
  case RAL_LORA_BW_062_KHZ:
    if (((sf == RAL_LORA_SF12) || (sf == RAL_LORA_SF11)) || (sf == RAL_LORA_SF10))
    {
      uVar1 = '\x01';
    }
    else
    {
      uVar1 = '\0';
    }
    break;
  case RAL_LORA_BW_125_KHZ:
  case RAL_LORA_BW_200_KHZ:
  case RAL_LORA_BW_400_KHZ:
  case RAL_LORA_BW_800_KHZ:
    if ((sf == RAL_LORA_SF12) || (sf == RAL_LORA_SF11))
    {
      uVar1 = '\x01';
    }
    else
    {
      uVar1 = '\0';
    }
    break;
  case RAL_LORA_BW_250_KHZ:
    if (sf == RAL_LORA_SF12)
    {
      uVar1 = '\x01';
    }
    else
    {
      uVar1 = '\0';
    }
    break;
  case RAL_LORA_BW_500_KHZ:
    uVar1 = '\0';
    break;
  default:
    uVar1 = '\0';
  }
  return uVar1;
}



void apps_common_shield_init(shield_t *shield)
{
  shield_t *shield_local;
  
  shield_init(shield,(_func_void_void_ptr *)0x80070ed);
  return;
}



void apps_common_shield_deinit(shield_t *shield)
{
  shield_t *shield_local;
  
  shield_deinit(shield);
  return;
}



apps_common_status_t apps_common_system_init(shield_t *shield)
{
  ral_status_t rVar1;
  shield_status_t sVar2;
  ral_t *radio_00;
  radio_parameters_t *prVar3;
  apps_common_status_t aVar4;
  shield_t *shield_local;
  ral_status_t status_1;
  ral_status_t status;
  radio_parameters_t *radio_parameters;
  ral_t *radio;
  
  radio_00 = shield_get_ral_instance(shield);
  prVar3 = common_radio_get_parameters();
  rVar1 = ral_reset(radio_00);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a4c,0x86,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a4c,0x86,(uint)rVar1);
    }
  }
  shield_set_reg_mode(shield,(prVar3->regulator_mode).val);
  sVar2 = shield_system_init(shield);
  if (sVar2 == SHIELD_STATUS_OK)
  {
    rVar1 = ral_clear_irq_status(radio_00,0xf7ffe);
    if (rVar1 != RAL_STATUS_OK)
    {
      if (rVar1 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a4c,0x93,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a4c,0x93,(uint)rVar1);
      }
    }
    aVar4 = APPS_COMMON_STATUS_OK;
  }
  else
  {
    aVar4 = APPS_COMMON_STATUS_ERROR;
  }
  return aVar4;
}



void apps_common_radio_init(shield_t *shield)
{
  shield_status_t sVar1;
  ral_status_t rVar2;
  ral_t *radio_00;
  radio_parameters_t *prVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  shield_t *shield_local;
  uint32_t ook_crc_polynomial;
  uint32_t ook_crc_seed;
  uint32_t broadcast_address;
  uint32_t node_address;
  shield_ook_syncword_bit_order_t ook_sync_word_bit_order;
  uint8_t sync_len_bits;
  uint8_t ook_syncword [4];
  shield_ook_rx_detector_t ook_rx_detector;
  shield_ook_whitening_params_t ook_whitening_params;
  shield_ook_pkt_params_t ook_pkt_params;
  shield_ook_mod_params_t ook_mod_params;
  uint8_t flrc_syncword_3 [4];
  uint8_t flrc_syncword_2 [4];
  uint8_t flrc_syncword_1 [4];
  shield_flrc_mod_params_t flrc_mod_params;
  shield_flrc_pkt_params_t flrc_pkt_params;
  uint8_t fsk_syncword_table [8];
  ral_gfsk_pkt_params_t gfsk_pkt_params;
  ral_gfsk_mod_params_t gfsk_mod_params;
  ral_lora_pkt_params_t lora_pkt_params;
  ral_lora_mod_params_t lora_mod_params;
  ral_status_t status_14;
  ral_status_t status_13;
  ral_status_t status_12;
  ral_status_t status_11;
  uint64_t fsk_syncword;
  ral_status_t status_10;
  ral_status_t status_9;
  ral_status_t status_8;
  ral_status_t status_7;
  ral_status_t status_6;
  ral_status_t status_5;
  ral_status_t status_4;
  ral_status_t status_3;
  ral_status_t status_2;
  ral_status_t status_1;
  ral_status_t status;
  radio_parameters_t *radio_parameters;
  ral_t *radio;
  
  common_radio_print_common_configuration();
  radio_00 = shield_get_ral_instance(shield);
  prVar3 = common_radio_get_parameters();
  sVar1 = shield_set_pkt_type(shield,radio_00,(prVar3->packet_type).val);
  if (sVar1 != SHIELD_STATUS_OK)
  {
    if (sVar1 == 3)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xa2,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xa2,(uint)sVar1);
    }
  }
  rVar2 = ral_set_rf_freq(radio_00,(prVar3->rf_freq_in_hz).val);
  if (rVar2 != RAL_STATUS_OK)
  {
    if (rVar2 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xa3,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xa3,(uint)rVar2);
    }
  }
  sVar1 = shield_set_tx_cfg(shield,(prVar3->tx_output_pwr_in_half_dbm).val,
                            (prVar3->rf_freq_in_hz).val);
  if (sVar1 != SHIELD_STATUS_OK)
  {
    if (sVar1 == 3)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xa4,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xa4,(uint)sVar1);
    }
  }
  rVar2 = ral_set_rx_tx_fallback_mode(radio_00,(prVar3->fallback_mode).val);
  if (rVar2 != RAL_STATUS_OK)
  {
    if (rVar2 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xa6,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xa6,(uint)rVar2);
    }
  }
  sVar1 = shield_set_rx_boost_mode
                    (shield,(prVar3->enable_rx_boost_mode).val,(prVar3->rf_freq_in_hz).val);
  if (sVar1 != SHIELD_STATUS_OK)
  {
    if (sVar1 == 3)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xa7,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xa7,(uint)sVar1);
    }
  }
  sVar1 = shield_set_reg_mode(shield,(prVar3->regulator_mode).val);
  if (sVar1 != SHIELD_STATUS_OK)
  {
    if (sVar1 == 3)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xa9,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xa9,(uint)sVar1);
    }
  }
  switch((prVar3->packet_type).val)
  {
  case SHIELD_PKT_TYPE_GFSK:
    common_radio_get_gfsk_parameters(&gfsk_mod_params,&gfsk_pkt_params);
    rVar2 = ral_set_gfsk_mod_params(radio_00,&gfsk_mod_params);
    if (rVar2 != RAL_STATUS_OK)
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xc1,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xc1,(uint)rVar2);
      }
    }
    rVar2 = ral_set_gfsk_pkt_params(radio_00,&gfsk_pkt_params);
    if (rVar2 != RAL_STATUS_OK)
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xc2,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xc2,(uint)rVar2);
      }
    }
    uVar4 = (undefined4)(prVar3->gfsk_parameters).fsk_sync_word.val;
    uVar5 = *(undefined4 *)((int)&(prVar3->gfsk_parameters).fsk_sync_word.val + 4);
    fsk_syncword_table[0] = (uint8_t)((uint)uVar5 >> 0x18);
    fsk_syncword_table[1] = (uint8_t)((uint)uVar5 >> 0x10);
    fsk_syncword_table[2] = (uint8_t)((uint)uVar5 >> 8);
    fsk_syncword_table[3] = (uint8_t)uVar5;
    fsk_syncword_table[4] = (uint8_t)((uint)uVar4 >> 0x18);
    fsk_syncword_table[5] = (uint8_t)((uint)uVar4 >> 0x10);
    fsk_syncword_table[6] = (uint8_t)((uint)uVar4 >> 8);
    fsk_syncword._0_1_ = (uint8_t)uVar4;
    fsk_syncword_table[7] = (uint8_t)fsk_syncword;
    rVar2 = ral_set_gfsk_sync_word(radio_00,fsk_syncword_table,'\b');
    if (rVar2 != RAL_STATUS_OK)
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xcf,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xcf,(uint)rVar2);
      }
    }
    if (((prVar3->gfsk_parameters).fsk_dc_free.val != RAL_GFSK_DC_FREE_OFF) &&
       (rVar2 = ral_set_gfsk_whitening_seed
                          (radio_00,(uint16_t)(prVar3->gfsk_parameters).fsk_whitening_seed.val),
       rVar2 != RAL_STATUS_OK))
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xd3,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xd3,(uint)rVar2);
      }
    }
    if (((prVar3->gfsk_parameters).fsk_crc_type.val != RAL_GFSK_CRC_OFF) &&
       (rVar2 = ral_set_gfsk_crc_params
                          (radio_00,(prVar3->gfsk_parameters).fsk_crc_seed.val,
                           (prVar3->gfsk_parameters).fsk_crc_polynomial.val), rVar2 != RAL_STATUS_OK
       ))
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xd8,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xd8,(uint)rVar2);
      }
    }
    if (((prVar3->gfsk_parameters).fsk_address_filtering.val != RAL_GFSK_ADDRESS_FILTERING_DISABLE)
       && (rVar2 = ral_set_gfsk_pkt_address
                             (radio_00,(uint8_t)(prVar3->gfsk_parameters).fsk_node_address.val,
                              (uint8_t)(prVar3->gfsk_parameters).fsk_broadcast_address.val),
          rVar2 != RAL_STATUS_OK))
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xde,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xde,(uint)rVar2);
      }
    }
    common_radio_print_gfsk_configuration();
    break;
  case SHIELD_PKT_TYPE_LORA:
    common_radio_get_lora_parameters(&lora_mod_params,&lora_pkt_params);
    if (lora_mod_params.ldro == '\x02')
    {
      lora_mod_params.ldro = apps_common_compute_lora_ldro(lora_mod_params.sf,lora_mod_params.bw);
    }
    rVar2 = ral_set_lora_mod_params(radio_00,&lora_mod_params);
    if (rVar2 != RAL_STATUS_OK)
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xb5,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xb5,(uint)rVar2);
      }
    }
    rVar2 = ral_set_lora_pkt_params(radio_00,&lora_pkt_params);
    if (rVar2 != RAL_STATUS_OK)
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xb6,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xb6,(uint)rVar2);
      }
    }
    rVar2 = ral_set_lora_sync_word(radio_00,(uint8_t)(prVar3->lora_parameters).lora_sync_word.val);
    if (rVar2 != RAL_STATUS_OK)
    {
      if (rVar2 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a64,0xb7,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a64,0xb7,(uint)rVar2);
      }
    }
    common_radio_print_lora_configuration();
    break;
  case SHIELD_PKT_TYPE_FLRC:
    common_radio_get_flrc_parameters(&flrc_mod_params,&flrc_pkt_params);
    shield_set_flrc_pkt_params(shield,&flrc_pkt_params);
    shield_set_flrc_mod_params(shield,&flrc_mod_params);
    common_radio_get_flrc_syncwords(flrc_syncword_1,flrc_syncword_2,flrc_syncword_3);
    shield_set_flrc_syncword(shield,flrc_syncword_1,'\x01','\x04');
    shield_set_flrc_syncword(shield,flrc_syncword_2,'\x02','\x04');
    shield_set_flrc_syncword(shield,flrc_syncword_3,'\x03','\x04');
    break;
  case SHIELD_PKT_TYPE_OOK:
    ook_mod_params.br = 0;
    ook_mod_params.pulse_shape.filter = SHIELD_OOK_PULSE_SHAPE_NO_FILTER;
    ook_mod_params.pulse_shape.bt = SHIELD_OOK_PULSE_SHAPE_BT_0_3;
    ook_mod_params._6_2_ = 0;
    ook_mod_params.bw = 0;
    ook_mod_params.mag_depth = SHIELD_OOK_MAG_DEPTH_FULL;
    ook_mod_params._13_3_ = 0;
    ook_pkt_params.pbl_length_in_bit = 0;
    ook_pkt_params.address_filtering = SHIELD_OOK_ADDRESS_FILTERING_DISABLED;
    ook_pkt_params.header_mode = SHIELD_OOK_HEADER_IMPLICIT;
    ook_pkt_params.payload_length = 0;
    ook_pkt_params.crc = SHIELD_OOK_CRC_OFF;
    ook_pkt_params.encoding = SHIELD_OOK_ENCODING_OFF;
    ook_whitening_params.bit_index = '\0';
    ook_whitening_params._1_1_ = 0;
    ook_whitening_params.polynomial = 0;
    ook_whitening_params.seed = 0;
    ook_rx_detector.pattern = 0;
    ook_rx_detector.pattern_length_in_bit = '\0';
    ook_rx_detector.pattern_repeat_nb = '\0';
    ook_rx_detector.sfd_type = SHIELD_OOK_RX_DETECTOR_SFD_TYPE_FALLING_EDGE;
    ook_rx_detector.sfd_length_in_bit = '\0';
    ook_rx_detector.is_syncword_encoded = false;
    ook_rx_detector._7_1_ = 0;
    ook_syncword[0] = '\0';
    ook_syncword[1] = '\0';
    ook_syncword[2] = '\0';
    ook_syncword[3] = '\0';
    sync_len_bits = '\0';
    ook_sync_word_bit_order = SHIELD_OOK_SYNCWORD_LSBF;
    common_radio_get_ook_parameters(&ook_mod_params,&ook_pkt_params);
    common_radio_get_ook_rx_detector(&ook_rx_detector);
    common_radio_get_ook_whitening_params(&ook_whitening_params);
    common_radio_get_ook_syncword_params(ook_syncword,&sync_len_bits,&ook_sync_word_bit_order);
    shield_set_ook_pkt_params(shield,&ook_pkt_params,false);
    shield_set_ook_mod_params(shield,&ook_mod_params);
    shield_set_ook_set_whitening_params(shield,&ook_whitening_params);
    shield_set_ook_syncword(shield,ook_syncword,'\x04',sync_len_bits,ook_sync_word_bit_order);
    shield_set_ook_rx_detector(shield,&ook_rx_detector);
    if (ook_pkt_params.address_filtering != SHIELD_OOK_ADDRESS_FILTERING_DISABLED)
    {
      node_address = 0;
      broadcast_address = 0;
      common_radio_get_ook_addresses(&node_address,&broadcast_address);
      shield_set_ook_set_addresses(shield,node_address,broadcast_address);
    }
    if (ook_pkt_params.crc != SHIELD_OOK_CRC_OFF)
    {
      ook_crc_seed = 0;
      ook_crc_polynomial = 0;
      common_radio_get_ook_crc_params(&ook_crc_polynomial,&ook_crc_seed);
    }
    common_radio_print_ook_configuration();
  }
  return;
}



void apps_common_receive(void *context,uint8_t *buffer,uint8_t buffer_length,uint16_t *size)
{
  shield_packet_type_t sVar1;
  ral_status_t rVar2;
  radio_parameters_t *prVar3;
  uint16_t *size_local;
  uint8_t buffer_length_local;
  uint8_t *buffer_local;
  void *context_local;
  char str [2048];
  ral_gfsk_rx_pkt_status_t pkt_status_gfsk;
  ral_lora_rx_pkt_status_t pkt_status_lora;
  ral_pkt_type_t pkt_type;
  radio_parameters_t *radio_params;
  ral_status_t status;
  
  rVar2 = ral_get_pkt_payload((ral_t *)context,(ushort)buffer_length,buffer,size);
  if (rVar2 != RAL_STATUS_OK)
  {
    if (rVar2 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8029cec,0x8033a7c,0x124,0x8029cd8);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8029cec,0x8033a7c,0x124,(uint)rVar2);
    }
  }
  prVar3 = common_radio_get_parameters();
  sVar1 = (prVar3->packet_type).val;
  if (sVar1 == SHIELD_PKT_TYPE_GFSK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "FSK packet status:");
    ral_get_gfsk_rx_pkt_status((ral_t *)context,&pkt_status_gfsk);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "  - RSSI average = %i dBm",(int)pkt_status_gfsk.rssi_avg_in_dbm);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "  - RSSI sync = %i dBm",(int)pkt_status_gfsk.rssi_sync_in_dbm);
  }
  else if (sVar1 == SHIELD_PKT_TYPE_LORA)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "LoRa packet status:");
    ral_get_lora_rx_pkt_status((ral_t *)context,&pkt_status_lora);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "  - RSSI packet = %i dBm",(int)pkt_status_lora.rssi_pkt_in_dbm);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "  - Signal RSSI packet = %i dBm",
                        (int)pkt_status_lora.signal_rssi_pkt_in_dbm);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "  - SNR packet = %i dB",(int)pkt_status_lora.snr_pkt_in_db);
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "  - Packet length = %u bytes",(uint)*size);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "  - Packet content: ");
  str[0] = '\0';
  str[1] = '\0';
  str[2] = '\0';
  str[3] = '\0';
  memset(str + 4,0,0x7fc);
  array_to_string(buffer,*size,str);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,"%s\n",str);
  return;
}



void apps_common_update_callbacks(apps_common_interrupts_callbacks_t *callbacks)
{
  apps_common_interrupts_callbacks_t *callbacks_local;
  
  if (callbacks != (apps_common_interrupts_callbacks_t *)0x0)
  {
    if (callbacks->on_tx_done != (_func_void *)0x0)
    {
      apps_common_callbacks.on_tx_done = callbacks->on_tx_done;
    }
    if (callbacks->on_rx_done != (_func_void *)0x0)
    {
      apps_common_callbacks.on_rx_done = callbacks->on_rx_done;
    }
    if (callbacks->on_rx_timeout != (_func_void *)0x0)
    {
      apps_common_callbacks.on_rx_timeout = callbacks->on_rx_timeout;
    }
    if (callbacks->on_preamble_detected != (_func_void *)0x0)
    {
      apps_common_callbacks.on_preamble_detected = callbacks->on_preamble_detected;
    }
    if (callbacks->on_syncword_header_valid != (_func_void *)0x0)
    {
      apps_common_callbacks.on_syncword_header_valid = callbacks->on_syncword_header_valid;
    }
    if (callbacks->on_header_error != (_func_void *)0x0)
    {
      apps_common_callbacks.on_header_error = callbacks->on_header_error;
    }
    if (callbacks->on_fsk_len_error != (_func_void *)0x0)
    {
      apps_common_callbacks.on_fsk_len_error = callbacks->on_fsk_len_error;
    }
    if (callbacks->on_rx_crc_error != (_func_void *)0x0)
    {
      apps_common_callbacks.on_rx_crc_error = callbacks->on_rx_crc_error;
    }
    if (callbacks->on_cad_done_undetected != (_func_void *)0x0)
    {
      apps_common_callbacks.on_cad_done_undetected = callbacks->on_cad_done_undetected;
    }
    if (callbacks->on_cad_done_detected != (_func_void *)0x0)
    {
      apps_common_callbacks.on_cad_done_detected = callbacks->on_cad_done_detected;
    }
    if (callbacks->on_lora_rx_timestamp != (_func_void *)0x0)
    {
      apps_common_callbacks.on_lora_rx_timestamp = callbacks->on_lora_rx_timestamp;
    }
    if (callbacks->on_wifi_scan_done != (_func_void *)0x0)
    {
      apps_common_callbacks.on_wifi_scan_done = callbacks->on_wifi_scan_done;
    }
    if (callbacks->on_gnss_scan_done != (_func_void *)0x0)
    {
      apps_common_callbacks.on_gnss_scan_done = callbacks->on_gnss_scan_done;
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void apps_common_reset_callbacks(void)
{
  apps_common_callbacks.on_tx_done = (_func_void *)0x800710d;
  apps_common_callbacks.on_rx_done = (_func_void *)0x8007125;
  apps_common_callbacks.on_rx_timeout = (_func_void *)0x800713d;
  apps_common_callbacks.on_preamble_detected = (_func_void *)0x8007155;
  apps_common_callbacks.on_syncword_header_valid = (_func_void *)0x800716d;
  apps_common_callbacks.on_header_error = (_func_void *)0x8007185;
  apps_common_callbacks.on_fsk_len_error = (_func_void *)0x800719d;
  apps_common_callbacks.on_rx_crc_error = (_func_void *)0x80071b5;
  apps_common_callbacks.on_cad_done_undetected = (_func_void *)0x80071cd;
  apps_common_callbacks.on_cad_done_detected = (_func_void *)0x80071e5;
  apps_common_callbacks.on_lora_rx_timestamp = (_func_void *)0x80071fd;
  apps_common_callbacks.on_wifi_scan_done = (_func_void *)0x8007215;
  apps_common_callbacks.on_gnss_scan_done = (_func_void *)0x800722d;
  return;
}



void apps_common_irq_process(void *context,ral_irq_t irq_filter_mask)
{
  uint uVar1;
  ral_irq_t irq_filter_mask_local;
  void *context_local;
  ral_irq_t irq_regs;
  ral_status_t status;
  
  if (irq_fired)
  {
    irq_fired = false;
    status = ral_get_and_clear_irq_status((ral_t *)context,&irq_regs);
    if (status != RAL_STATUS_OK)
    {
      if (status == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8029cec,0x8033a90,0x198,0x8029cd8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8029cec,0x8033a90,0x198,(uint)status);
      }
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Interrupt flags = 0x%08X",irq_regs);
    uVar1 = irq_filter_mask & irq_regs;
    irq_regs = uVar1;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Interrupt flags (after filtering) = 0x%08X",uVar1);
    if ((irq_regs & 2) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Tx done",uVar1);
      (*apps_common_callbacks.on_tx_done)();
    }
    if ((irq_regs & 0x10) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Preamble detected",uVar1);
      (*apps_common_callbacks.on_preamble_detected)();
    }
    if ((irq_regs & 0x40) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Header error",uVar1);
      (*apps_common_callbacks.on_header_error)();
    }
    if ((irq_regs & 0x20) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Syncword or header valid",uVar1);
      (*apps_common_callbacks.on_syncword_header_valid)();
    }
    if ((irq_regs & 4) != 0)
    {
      if ((irq_regs & 0x80) == 0)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "Rx done");
        (*apps_common_callbacks.on_rx_done)();
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "CRC error");
        (*apps_common_callbacks.on_rx_crc_error)();
      }
    }
    if ((irq_regs & 0x100) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "CAD done");
      if ((irq_regs & 0x200) == 0)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "No channel activity detected");
        (*apps_common_callbacks.on_cad_done_undetected)();
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "Channel activity detected");
        (*apps_common_callbacks.on_cad_done_detected)();
      }
    }
    if ((irq_regs & 8) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Rx timeout");
      (*apps_common_callbacks.on_rx_timeout)();
    }
    if ((irq_regs & 0x800) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Wi-Fi scan done");
      (*apps_common_callbacks.on_wifi_scan_done)();
    }
    if ((irq_regs & 0x1000) != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "GNSS scan done");
      (*apps_common_callbacks.on_gnss_scan_done)();
    }
  }
  return;
}



uint32_t get_time_on_air_in_ms(shield_t *shield)
{
  radio_parameters_t *prVar1;
  ral_t *prVar2;
  uint32_t uVar3;
  shield_t *shield_local;
  ral_gfsk_pkt_params_t gfsk_pkt_params;
  ral_gfsk_mod_params_t gfsk_mod_params;
  ral_lora_pkt_params_t lora_pkt_params;
  ral_lora_mod_params_t lora_mod_params;
  radio_parameters_t *radio_parameters;
  
  prVar1 = common_radio_get_parameters();
  switch((prVar1->packet_type).val)
  {
  case SHIELD_PKT_TYPE_GFSK:
    common_radio_get_gfsk_parameters(&gfsk_mod_params,&gfsk_pkt_params);
    prVar2 = shield_get_ral_instance(shield);
    uVar3 = ral_get_gfsk_time_on_air_in_ms(prVar2,&gfsk_pkt_params,&gfsk_mod_params);
    break;
  case SHIELD_PKT_TYPE_LORA:
    common_radio_get_lora_parameters(&lora_mod_params,&lora_pkt_params);
    prVar2 = shield_get_ral_instance(shield);
    uVar3 = ral_get_lora_time_on_air_in_ms(prVar2,&lora_pkt_params,&lora_mod_params);
    break;
  case SHIELD_PKT_TYPE_FLRC:
    uVar3 = 0;
    break;
  case SHIELD_PKT_TYPE_OOK:
    uVar3 = 0;
    break;
  default:
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Packet type parameter unknown, cannot compute time on air");
    uVar3 = 0;
  }
  return uVar3;
}



void radio_on_dio_irq(void *context)
{
  void *context_local;
  
  irq_fired = true;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_tx_done(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_rx_done(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_rx_timeout(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_preamble_detected(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_syncword_header_valid(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_header_error(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_fsk_len_error(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_rx_crc_error(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_cad_done_undetected(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_cad_done_detected(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_lora_rx_timestamp(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_wifi_scan_done(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void on_gnss_scan_done(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "No IRQ routine defined");
  return;
}



char * ral_fallback_modes_to_str(ral_fallback_modes_t mode)
{
  ral_fallback_modes_t mode_local;
  
  if (mode == RAL_FALLBACK_FS)
  {
    return "RAL_FALLBACK_FS";
  }
  if (mode < (RAL_FALLBACK_FS|RAL_FALLBACK_STDBY_XOSC))
  {
    if (mode == RAL_FALLBACK_STDBY_RC)
    {
      return "RAL_FALLBACK_STDBY_RC";
    }
    if (mode == RAL_FALLBACK_STDBY_XOSC)
    {
      return "RAL_FALLBACK_STDBY_XOSC";
    }
  }
  return "UNKNOWN_RAL_FALLBACK_MODE";
}



char * ral_gfsk_crc_type_to_str(ral_gfsk_crc_type_t type)
{
  char *pcVar1;
  ral_gfsk_crc_type_t type_local;
  
  switch(type)
  {
  case RAL_GFSK_CRC_OFF:
    pcVar1 = "RAL_GFSK_CRC_OFF";
    break;
  case RAL_GFSK_CRC_1_BYTE:
    pcVar1 = "RAL_GFSK_CRC_1_BYTE";
    break;
  case RAL_GFSK_CRC_2_BYTES:
    pcVar1 = "RAL_GFSK_CRC_2_BYTES";
    break;
  case RAL_GFSK_CRC_1_BYTE_INV:
    pcVar1 = "RAL_GFSK_CRC_1_BYTE_INV";
    break;
  case RAL_GFSK_CRC_2_BYTES_INV:
    pcVar1 = "RAL_GFSK_CRC_2_BYTES_INV";
    break;
  case RAL_GFSK_CRC_3_BYTES:
    pcVar1 = "RAL_GFSK_CRC_3_BYTES";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_GFSK_CRC_TYPE";
  }
  return pcVar1;
}



char * ral_gfsk_pulse_shape_to_str(ral_gfsk_pulse_shape_t shape)
{
  char *pcVar1;
  ral_gfsk_pulse_shape_t shape_local;
  
  switch(shape)
  {
  case RAL_GFSK_PULSE_SHAPE_OFF:
    pcVar1 = "RAL_GFSK_PULSE_SHAPE_OFF";
    break;
  case RAL_GFSK_PULSE_SHAPE_BT_03:
    pcVar1 = "RAL_GFSK_PULSE_SHAPE_BT_03";
    break;
  case RAL_GFSK_PULSE_SHAPE_BT_05:
    pcVar1 = "RAL_GFSK_PULSE_SHAPE_BT_05";
    break;
  case RAL_GFSK_PULSE_SHAPE_BT_07:
    pcVar1 = "RAL_GFSK_PULSE_SHAPE_BT_07";
    break;
  case RAL_GFSK_PULSE_SHAPE_BT_1:
    pcVar1 = "RAL_GFSK_PULSE_SHAPE_BT_1";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_GFSK_PULSE_SHAPE";
  }
  return pcVar1;
}



char * ral_lora_sf_to_str(ral_lora_sf_t sf)
{
  char *pcVar1;
  ral_lora_sf_t sf_local;
  
  switch(sf)
  {
  case RAL_LORA_SF5:
    pcVar1 = "RAL_LORA_SF5";
    break;
  case RAL_LORA_SF6:
    pcVar1 = "RAL_LORA_SF6";
    break;
  case RAL_LORA_SF7:
    pcVar1 = "RAL_LORA_SF7";
    break;
  case RAL_LORA_SF8:
    pcVar1 = "RAL_LORA_SF8";
    break;
  case RAL_LORA_SF9:
    pcVar1 = "RAL_LORA_SF9";
    break;
  case RAL_LORA_SF10:
    pcVar1 = "RAL_LORA_SF10";
    break;
  case RAL_LORA_SF11:
    pcVar1 = "RAL_LORA_SF11";
    break;
  case RAL_LORA_SF12:
    pcVar1 = "RAL_LORA_SF12";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_LORA_SF";
  }
  return pcVar1;
}



char * ral_lora_bw_to_str(ral_lora_bw_t bw)
{
  char *pcVar1;
  ral_lora_bw_t bw_local;
  
  switch(bw)
  {
  case RAL_LORA_BW_007_KHZ:
    pcVar1 = "RAL_LORA_BW_007_KHZ";
    break;
  case RAL_LORA_BW_010_KHZ:
    pcVar1 = "RAL_LORA_BW_010_KHZ";
    break;
  case RAL_LORA_BW_015_KHZ:
    pcVar1 = "RAL_LORA_BW_015_KHZ";
    break;
  case RAL_LORA_BW_020_KHZ:
    pcVar1 = "RAL_LORA_BW_020_KHZ";
    break;
  case RAL_LORA_BW_031_KHZ:
    pcVar1 = "RAL_LORA_BW_031_KHZ";
    break;
  case RAL_LORA_BW_041_KHZ:
    pcVar1 = "RAL_LORA_BW_041_KHZ";
    break;
  case RAL_LORA_BW_062_KHZ:
    pcVar1 = "RAL_LORA_BW_062_KHZ";
    break;
  case RAL_LORA_BW_125_KHZ:
    pcVar1 = "RAL_LORA_BW_125_KHZ";
    break;
  case RAL_LORA_BW_200_KHZ:
    pcVar1 = "RAL_LORA_BW_200_KHZ";
    break;
  case RAL_LORA_BW_250_KHZ:
    pcVar1 = "RAL_LORA_BW_250_KHZ";
    break;
  case RAL_LORA_BW_400_KHZ:
    pcVar1 = "RAL_LORA_BW_400_KHZ";
    break;
  case RAL_LORA_BW_500_KHZ:
    pcVar1 = "RAL_LORA_BW_500_KHZ";
    break;
  case RAL_LORA_BW_800_KHZ:
    pcVar1 = "RAL_LORA_BW_800_KHZ";
    break;
  case RAL_LORA_BW_1000_KHZ:
    pcVar1 = "RAL_LORA_BW_1000_KHZ";
    break;
  case RAL_LORA_BW_1600_KHZ:
    pcVar1 = "RAL_LORA_BW_1600_KHZ";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_LORA_BW";
  }
  return pcVar1;
}



char * ral_lora_cr_to_str(ral_lora_cr_t cr)
{
  char *pcVar1;
  ral_lora_cr_t cr_local;
  
  switch(cr)
  {
  case RAL_LORA_CR_4_5:
    pcVar1 = "RAL_LORA_CR_4_5";
    break;
  case RAL_LORA_CR_4_6:
    pcVar1 = "RAL_LORA_CR_4_6";
    break;
  case RAL_LORA_CR_4_7:
    pcVar1 = "RAL_LORA_CR_4_7";
    break;
  case RAL_LORA_CR_4_8:
    pcVar1 = "RAL_LORA_CR_4_8";
    break;
  case RAL_LORA_CR_LI_4_5:
    pcVar1 = "RAL_LORA_CR_LI_4_5";
    break;
  case RAL_LORA_CR_LI_4_6:
    pcVar1 = "RAL_LORA_CR_LI_4_6";
    break;
  case RAL_LORA_CR_LI_4_8:
    pcVar1 = "RAL_LORA_CR_LI_4_8";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_LORA_CR";
  }
  return pcVar1;
}



char * ral_gfsk_preamble_detector_to_str(ral_gfsk_preamble_detector_t detector)
{
  char *pcVar1;
  ral_gfsk_preamble_detector_t detector_local;
  
  if (false)
  {
switchD_08007566_caseD_1:
    pcVar1 = "UNKNOWN_RAL_GFSK_PREAMBLE_DETECTOR";
  }
  else
  {
    switch(detector)
    {
    case RAL_GFSK_PREAMBLE_DETECTOR_OFF:
      pcVar1 = "RAL_GFSK_PREAMBLE_DETECTOR_OFF";
      break;
    default:
      goto switchD_08007566_caseD_1;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_8BITS:
      pcVar1 = "RAL_GFSK_PREAMBLE_DETECTOR_MIN_8BITS";
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS:
      pcVar1 = "RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS";
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_24BITS:
      pcVar1 = "RAL_GFSK_PREAMBLE_DETECTOR_MIN_24BITS";
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_32BITS:
      pcVar1 = "RAL_GFSK_PREAMBLE_DETECTOR_MIN_32BITS";
    }
  }
  return pcVar1;
}



char * ral_lora_pkt_len_modes_to_str(ral_lora_pkt_len_modes_t mode)
{
  char *pcVar1;
  ral_lora_pkt_len_modes_t mode_local;
  
  if (mode == RAL_LORA_PKT_EXPLICIT)
  {
    pcVar1 = "RAL_LORA_PKT_EXPLICIT";
  }
  else if (mode == RAL_LORA_PKT_IMPLICIT)
  {
    pcVar1 = "RAL_LORA_PKT_IMPLICIT";
  }
  else
  {
    pcVar1 = "UNKNOWN_RAL_LORA_PKT_LEN_MODE";
  }
  return pcVar1;
}



char * ral_pkt_type_to_str(ral_pkt_type_t type)
{
  char *pcVar1;
  ral_pkt_type_t type_local;
  
  switch(type)
  {
  case RAL_PKT_TYPE_GFSK:
    pcVar1 = "RAL_PKT_TYPE_GFSK";
    break;
  case RAL_PKT_TYPE_LORA:
    pcVar1 = "RAL_PKT_TYPE_LORA";
    break;
  case RAL_PKT_TYPE_FLRC:
    pcVar1 = "RAL_PKT_TYPE_FLRC";
    break;
  case RAL_PKT_TYPE_RTTOF:
    pcVar1 = "RAL_PKT_TYPE_RTTOF";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_PKT_TYPE";
  }
  return pcVar1;
}



char * ral_gfsk_address_filtering_to_str(ral_gfsk_address_filtering_t filtering)
{
  ral_gfsk_address_filtering_t filtering_local;
  
  if (filtering == RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES)
  {
    return "RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES";
  }
  if (filtering <
      (RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES|
      RAL_GFSK_ADDRESS_FILTERING_NODE_ADDRESS))
  {
    if (filtering == RAL_GFSK_ADDRESS_FILTERING_DISABLE)
    {
      return "RAL_GFSK_ADDRESS_FILTERING_DISABLE";
    }
    if (filtering == RAL_GFSK_ADDRESS_FILTERING_NODE_ADDRESS)
    {
      return "RAL_GFSK_ADDRESS_FILTERING_NODE_ADDRESS";
    }
  }
  return "UNKNOWN_RAL_GFSK_ADDRESS_FILTERING";
}



char * ral_gfsk_dc_free_to_str(ral_gfsk_dc_free_t dc)
{
  ral_gfsk_dc_free_t dc_local;
  
  if (dc == RAL_GFSK_DC_FREE_WHITENING_SX128X_COMP)
  {
    return "RAL_GFSK_DC_FREE_WHITENING_SX128X_COMP";
  }
  if (dc < (RAL_GFSK_DC_FREE_WHITENING_SX128X_COMP|RAL_GFSK_DC_FREE_WHITENING))
  {
    if (dc == RAL_GFSK_DC_FREE_OFF)
    {
      return "RAL_GFSK_DC_FREE_OFF";
    }
    if (dc == RAL_GFSK_DC_FREE_WHITENING)
    {
      return "RAL_GFSK_DC_FREE_WHITENING";
    }
  }
  return "UNKNOWN_RAL_GFSK_DC_FREE";
}



char * ral_gfsk_pkt_len_modes_to_str(ral_gfsk_pkt_len_modes_t mode)
{
  ral_gfsk_pkt_len_modes_t mode_local;
  
  if (mode == RAL_GFSK_PKT_VAR_LEN_SX128X_COMP)
  {
    return "RAL_GFSK_PKT_VAR_LEN_SX128X_COMP";
  }
  if (mode < (RAL_GFSK_PKT_VAR_LEN_SX128X_COMP|RAL_GFSK_PKT_VAR_LEN))
  {
    if (mode == RAL_GFSK_PKT_FIX_LEN)
    {
      return "RAL_GFSK_PKT_FIX_LEN";
    }
    if (mode == RAL_GFSK_PKT_VAR_LEN)
    {
      return "RAL_GFSK_PKT_VAR_LEN";
    }
  }
  return "UNKNOWN_RAL_GFSK_PKT_LEN_MODE";
}



void read_rf_freq_in_hz_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->rf_freq_in_hz);
  return;
}



void write_rf_freq_in_hz_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->rf_freq_in_hz);
  return;
}



void read_tx_output_pwr_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->tx_output_pwr_in_half_dbm);
  return;
}



void write_tx_output_pwr_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->tx_output_pwr_in_half_dbm);
  return;
}



void read_enable_rx_boost_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->enable_rx_boost_mode);
  return;
}



void write_enable_rx_boost_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->enable_rx_boost_mode);
  return;
}



void read_payload_length_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->payload_length);
  return;
}



void write_payload_length_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->payload_length);
  return;
}



void read_regulator_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->regulator_mode);
  return;
}



void write_regulator_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->regulator_mode);
  return;
}



void read_lora_iq_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->lora_parameters->lora_iq);
  return;
}



void write_lora_iq_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->lora_parameters->lora_iq);
  return;
}



void read_lora_crc_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->lora_parameters->lora_crc);
  return;
}



void write_lora_crc_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->lora_parameters->lora_crc);
  return;
}



void read_lora_preamble_len_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->lora_parameters->lora_preamble_len);
  return;
}



void write_lora_preamble_len_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->lora_parameters->lora_preamble_len);
  return;
}



void read_lora_sync_word_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->lora_parameters->lora_sync_word);
  return;
}



void write_lora_sync_word_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->lora_parameters->lora_sync_word);
  return;
}



void read_lora_ldro_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->lora_parameters->lora_ldro);
  return;
}



void write_lora_ldro_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->lora_parameters->lora_ldro);
  return;
}



void read_fsk_dev_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_dev);
  return;
}



void write_fsk_dev_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_dev);
  return;
}



void read_fsk_bitrate_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_bitrate);
  return;
}



void write_fsk_bitrate_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_bitrate);
  return;
}



void read_fsk_bandwidth_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_bandwidth);
  return;
}



void write_fsk_bandwidth_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_bandwidth);
  return;
}



void read_fsk_preamble_len_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_preamble_len);
  return;
}



void write_fsk_preamble_len_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_preamble_len);
  return;
}



void read_fsk_syncword_len_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_syncword_len);
  return;
}



void write_fsk_syncword_len_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_syncword_len);
  return;
}



void read_fsk_sync_word_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_sync_word);
  return;
}



void write_fsk_sync_word_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_sync_word);
  return;
}



void read_fsk_whitening_seed_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_whitening_seed);
  return;
}



void write_fsk_whitening_seed_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_whitening_seed);
  return;
}



void read_fsk_crc_seed_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_crc_seed);
  return;
}



void write_fsk_crc_seed_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_crc_seed);
  return;
}



void read_fsk_crc_polynomial_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_crc_polynomial);
  return;
}



void write_fsk_crc_polynomial_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_crc_polynomial);
  return;
}



void read_fsk_node_address_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_node_address);
  return;
}



void write_fsk_node_address_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_node_address);
  return;
}



void read_fsk_broadcast_address_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->fsk_parameters->fsk_broadcast_address);
  return;
}



void write_fsk_broadcast_address_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->fsk_parameters->fsk_broadcast_address);
  return;
}



void read_flrc_preamble_len_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_preamble_len);
  return;
}



void write_flrc_preamble_len_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_preamble_len);
  return;
}



void read_flrc_sync_word_len_bytes_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_len);
  return;
}



void write_flrc_sync_word_len_bytes_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_len);
  return;
}



void read_flrc_match_sync_word_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_match);
  return;
}



void write_flrc_match_sync_word_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_match);
  return;
}



void read_flrc_crc_type_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_crc_type);
  return;
}



void write_flrc_crc_type_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_crc_type);
  return;
}



void read_flrc_bw_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_bw);
  return;
}



void write_flrc_bw_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_bw);
  return;
}



void read_flrc_cr_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_cr);
  return;
}



void write_flrc_cr_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_cr);
  return;
}



void read_flrc_pulse_shape_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_pulse_shape);
  return;
}



void write_flrc_pulse_shape_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_pulse_shape);
  return;
}



void read_flrc_header_type_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_pck_len_mode);
  return;
}



void write_flrc_header_type_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_pck_len_mode);
  return;
}



void read_flrc_syncword_1_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_1);
  return;
}



void write_flrc_syncword_1_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_1);
  return;
}



void read_flrc_syncword_2_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_2);
  return;
}



void write_flrc_syncword_2_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_2);
  return;
}



void read_flrc_syncword_3_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_3);
  return;
}



void write_flrc_syncword_3_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->flrc_parameters->flrc_syncword_3);
  return;
}



void read_ook_bitrate_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_bitrate);
  return;
}



void write_ook_bitrate_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_bitrate);
  return;
}



void read_ook_bandwidth_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_bandwidth);
  return;
}



void write_ook_bandwidth_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_bandwidth);
  return;
}



void read_ook_preamble_length_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_preamble_length);
  return;
}



void write_ook_preamble_length_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_preamble_length);
  return;
}



void read_ook_pulse_shape_filter_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_pulse_shape_filter);
  return;
}



void write_ook_pulse_shape_filter_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_pulse_shape_filter);
  return;
}



void read_ook_shape_filter_bt_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_shape_filter_bt);
  return;
}



void write_ook_shape_filter_bt_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_shape_filter_bt);
  return;
}



void read_ook_mag_depth_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_mag_depth);
  return;
}



void write_ook_mag_depth_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_mag_depth);
  return;
}



void read_ook_address_filtering_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_address_filtering);
  return;
}



void write_ook_address_filtering_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_address_filtering);
  return;
}



void read_ook_header_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_header_mode);
  return;
}



void write_ook_header_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_header_mode);
  return;
}



void read_ook_encoding_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_encoding);
  return;
}



void write_ook_encoding_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_encoding);
  return;
}



void read_ook_crc_type_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_crc_type);
  return;
}



void write_ook_crc_type_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_crc_type);
  return;
}



void read_ook_crc_polynomial_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_crc_polynomial);
  return;
}



void write_ook_crc_polynomial_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_crc_polynomial);
  return;
}



void read_ook_crc_seed_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_crc_seed);
  return;
}



void write_ook_crc_seed_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_crc_seed);
  return;
}



void read_ook_sync_word_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word);
  return;
}



void write_ook_sync_word_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word);
  return;
}



void read_ook_sync_word_len_bits_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word_len_bits);
  return;
}



void write_ook_sync_word_len_bits_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word_len_bits);
  return;
}



void read_ook_sync_word_bit_order_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word_bit_order);
  return;
}



void write_ook_sync_word_bit_order_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word_bit_order);
  return;
}



void read_ook_sync_word_is_encoded_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word_is_encoded);
  return;
}



void write_ook_sync_word_is_encoded_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_sync_word_is_encoded);
  return;
}



void read_ook_rx_detector_sfd_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_sfd);
  return;
}



void write_ook_rx_detector_sfd_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_sfd);
  return;
}



void read_ook_rx_detector_pattern_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_pattern);
  return;
}



void write_ook_rx_detector_pattern_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_pattern);
  return;
}



void read_ook_rx_detector_pattern_length_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_pattern_length);
  return;
}



void write_ook_rx_detector_pattern_length_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_pattern_length);
  return;
}



void read_ook_rx_detector_pattern_repeat_nb_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_pattern_repeat_nb);
  return;
}



void write_ook_rx_detector_pattern_repeat_nb_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_pattern_repeat_nb);
  return;
}



void read_ook_rx_detector_sfd_length_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_sfd_length);
  return;
}



void write_ook_rx_detector_sfd_length_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_rx_detector_sfd_length);
  return;
}



void read_ook_node_address_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_node_address);
  return;
}



void write_ook_node_address_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_node_address);
  return;
}



void read_ook_broadcast_address_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_broadcast_address);
  return;
}



void write_ook_broadcast_address_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_broadcast_address);
  return;
}



void read_ook_whitening_bit_index_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_whitening_bit_index);
  return;
}



void write_ook_whitening_bit_index_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_whitening_bit_index);
  return;
}



void read_ook_whitening_polynomial_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_whitening_polynomial);
  return;
}



void write_ook_whitening_polynomial_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_whitening_polynomial);
  return;
}



void read_ook_whitening_seed_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->radio_configuration->ook_parameters->ook_whitening_seed);
  return;
}



void write_ook_whitening_seed_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->radio_configuration->ook_parameters->ook_whitening_seed);
  return;
}



void read_packet_type_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  shield_packet_type_t pkt_type;
  
  switch(protobuf->radio_configuration->packet_type)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_LORA:
    pkt_type = SHIELD_PKT_TYPE_LORA;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_GFSK:
    pkt_type = SHIELD_PKT_TYPE_GFSK;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_FLRC:
    pkt_type = SHIELD_PKT_TYPE_FLRC;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_OOK:
    pkt_type = SHIELD_PKT_TYPE_OOK;
    break;
  default:
    pkt_type = SHIELD_PKT_TYPE_LORA;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"No configuration found for PACKET_TYPE, default value %d applied",1);
  }
  read_from(item,&pkt_type);
  return;
}



void write_packet_type_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_shield_packet_type_t *pkt_type_item;
  DeviceMessage__RadioDefs__RadioPktType pkt_type;
  
  switch(*(undefined1 *)&item[1].vtable)
  {
  case 0:
    pkt_type = DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_GFSK;
    break;
  case 1:
    pkt_type = DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_LORA;
    break;
  case 2:
    pkt_type = DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_FLRC;
    break;
  case 3:
    pkt_type = DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_OOK;
    break;
  default:
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for PACKET_TYPE : %d",
                        (uint)*(byte *)&item[1].vtable);
    pkt_type = DEVICE_MESSAGE__RADIO_DEFS__RADIO_PKT_TYPE__PKT_TYPE_LORA;
  }
  protobuf->radio_configuration->packet_type = pkt_type;
  return;
}



void read_fallback_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__RadioDefs__FallbackMode DVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_fallback_modes_t fallback_mode;
  
  DVar1 = protobuf->radio_configuration->fallback_mode;
  if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_FS)
  {
    fallback_mode = RAL_FALLBACK_FS;
    goto LAB_0800881e;
  }
  if (DVar1 < (DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_FS|
              DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_STDBY_XOSC))
  {
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_STDBY_RC)
    {
      fallback_mode = RAL_FALLBACK_STDBY_RC;
      goto LAB_0800881e;
    }
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_STDBY_XOSC)
    {
      fallback_mode = RAL_FALLBACK_STDBY_XOSC;
      goto LAB_0800881e;
    }
  }
  fallback_mode = RAL_FALLBACK_STDBY_RC;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "No configuration found for FALLBACK_MODE, default value %d applied",0);
LAB_0800881e:
  read_from(item,&fallback_mode);
  return;
}



void write_fallback_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  byte bVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_fallback_modes_t *fallback_mode_item;
  DeviceMessage__RadioDefs__FallbackMode fallback_mode;
  
  bVar1 = *(byte *)&item[1].vtable;
  if (bVar1 == 2)
  {
    fallback_mode = DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_FS;
    goto LAB_08008886;
  }
  if (bVar1 < 3)
  {
    if (bVar1 == 0)
    {
      fallback_mode = DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_STDBY_RC;
      goto LAB_08008886;
    }
    if (bVar1 == 1)
    {
      fallback_mode = DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_STDBY_XOSC;
      goto LAB_08008886;
    }
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Unknown configuration found for FALLBACK_MODE : %d",
                      (uint)*(byte *)&item[1].vtable);
  fallback_mode = DEVICE_MESSAGE__RADIO_DEFS__FALLBACK_MODE__FALLBACK_FS;
LAB_08008886:
  protobuf->radio_configuration->fallback_mode = fallback_mode;
  return;
}



void read_lora_sf_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_lora_sf_t lora_sf;
  
  switch(protobuf->radio_configuration->lora_parameters->lora_sf)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF5:
    lora_sf = RAL_LORA_SF5;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF6:
    lora_sf = RAL_LORA_SF6;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF7:
    lora_sf = RAL_LORA_SF7;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF8:
    lora_sf = RAL_LORA_SF8;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF9:
    lora_sf = RAL_LORA_SF9;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF10:
    lora_sf = RAL_LORA_SF10;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF11:
    lora_sf = RAL_LORA_SF11;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF12:
    lora_sf = RAL_LORA_SF12;
    break;
  default:
    lora_sf = RAL_LORA_SF7;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,
                        "No configuration found for LORA_SPREADING_FACTOR, default value %d applied"
                        ,7);
  }
  read_from(item,&lora_sf);
  return;
}



void write_lora_sf_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_lora_sf_t *lora_sf_item;
  DeviceMessage__RadioDefs__LoraSf lora_sf;
  
  switch(*(undefined1 *)&item[1].vtable)
  {
  case 5:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF5;
    break;
  case 6:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF6;
    break;
  case 7:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF7;
    break;
  case 8:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF8;
    break;
  case 9:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF9;
    break;
  case 10:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF10;
    break;
  case 0xb:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF11;
    break;
  case 0xc:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF12;
    break;
  default:
    lora_sf = DEVICE_MESSAGE__RADIO_DEFS__LORA_SF__SF7;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for LORA SF : %d",
                        (uint)*(byte *)&item[1].vtable);
  }
  protobuf->radio_configuration->lora_parameters->lora_sf = lora_sf;
  return;
}



void read_lora_bw_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_lora_bw_t lora_bw;
  
  switch(protobuf->radio_configuration->lora_parameters->lora_bw)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_007_KHZ:
    lora_bw = RAL_LORA_BW_007_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_010_KHZ:
    lora_bw = RAL_LORA_BW_010_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_015_KHZ:
    lora_bw = RAL_LORA_BW_015_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_020_KHZ:
    lora_bw = RAL_LORA_BW_020_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_031_KHZ:
    lora_bw = RAL_LORA_BW_031_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_041_KHZ:
    lora_bw = RAL_LORA_BW_041_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_062_KHZ:
    lora_bw = RAL_LORA_BW_062_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_125_KHZ:
    lora_bw = RAL_LORA_BW_125_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_200_KHZ:
    lora_bw = RAL_LORA_BW_200_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_250_KHZ:
    lora_bw = RAL_LORA_BW_250_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_400_KHZ:
    lora_bw = RAL_LORA_BW_400_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_500_KHZ:
    lora_bw = RAL_LORA_BW_500_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_800_KHZ:
    lora_bw = RAL_LORA_BW_800_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_1600_KHZ:
    lora_bw = RAL_LORA_BW_1600_KHZ;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_1000_KHZ:
    lora_bw = RAL_LORA_BW_1000_KHZ;
    break;
  default:
    lora_bw = RAL_LORA_BW_125_KHZ;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"No configuration found for LORA_BANDWIDTH, default value %d applied",7);
  }
  read_from(item,&lora_bw);
  return;
}



void write_lora_bw_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_lora_bw_t *lora_bw_item;
  DeviceMessage__RadioDefs__LoraBw lora_bw;
  
  switch(*(undefined1 *)&item[1].vtable)
  {
  case 0:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_007_KHZ;
    break;
  case 1:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_010_KHZ;
    break;
  case 2:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_015_KHZ;
    break;
  case 3:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_020_KHZ;
    break;
  case 4:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_031_KHZ;
    break;
  case 5:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_041_KHZ;
    break;
  case 6:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_062_KHZ;
    break;
  case 7:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_125_KHZ;
    break;
  case 8:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_200_KHZ;
    break;
  case 9:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_250_KHZ;
    break;
  case 10:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_400_KHZ;
    break;
  case 0xb:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_500_KHZ;
    break;
  case 0xc:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_800_KHZ;
    break;
  case 0xd:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_1000_KHZ;
    break;
  case 0xe:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_1600_KHZ;
    break;
  default:
    lora_bw = DEVICE_MESSAGE__RADIO_DEFS__LORA_BW__LORA_BW_125_KHZ;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for LORA_BW : %d",
                        (uint)*(byte *)&item[1].vtable);
  }
  protobuf->radio_configuration->lora_parameters->lora_bw = lora_bw;
  return;
}



void read_lora_cr_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_lora_cr_t lora_cr;
  
  switch(protobuf->radio_configuration->lora_parameters->lora_cr)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_5:
    lora_cr = RAL_LORA_CR_4_5;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_6:
    lora_cr = RAL_LORA_CR_4_6;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_7:
    lora_cr = RAL_LORA_CR_4_7;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_8:
    lora_cr = RAL_LORA_CR_4_8;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_LI_4_5:
    lora_cr = RAL_LORA_CR_LI_4_5;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_LI_4_6:
    lora_cr = RAL_LORA_CR_LI_4_6;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_LI_4_8:
    lora_cr = RAL_LORA_CR_LI_4_8;
    break;
  default:
    lora_cr = RAL_LORA_CR_4_5;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"No configuration found for LORA_CODING_RATE, default value %d applied",1);
  }
  read_from(item,&lora_cr);
  return;
}



void write_lora_cr_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_lora_cr_t *lora_cr_item;
  DeviceMessage__RadioDefs__LoraCr lora_cr;
  
  switch(*(undefined1 *)&item[1].vtable)
  {
  case 1:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_5;
    break;
  case 2:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_6;
    break;
  case 3:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_7;
    break;
  case 4:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_8;
    break;
  case 5:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_LI_4_5;
    break;
  case 6:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_LI_4_6;
    break;
  case 7:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_LI_4_8;
    break;
  default:
    lora_cr = DEVICE_MESSAGE__RADIO_DEFS__LORA_CR__LORA_CR_4_5;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for LORA CODING RATE : %d",
                        (uint)*(byte *)&item[1].vtable);
  }
  protobuf->radio_configuration->lora_parameters->lora_cr = lora_cr;
  return;
}



void read_lora_pkt_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__RadioDefs__LoraPktMode DVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_lora_pkt_len_modes_t pkt_mode;
  
  DVar1 = protobuf->radio_configuration->lora_parameters->lora_pkt_mode;
  if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__LORA_PKT_MODE__LORA_PKT_EXPLICIT)
  {
    pkt_mode = RAL_LORA_PKT_EXPLICIT;
  }
  else if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__LORA_PKT_MODE__LORA_PKT_IMPLICIT)
  {
    pkt_mode = RAL_LORA_PKT_IMPLICIT;
  }
  else
  {
    pkt_mode = RAL_LORA_PKT_EXPLICIT;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"No configuration found for LORA_PKT_LEN_MODE, default value %d applied",0)
    ;
  }
  read_from(item,&pkt_mode);
  return;
}



void write_lora_pkt_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_lora_pkt_len_modes_t *lora_pkt_len_mode_item;
  DeviceMessage__RadioDefs__LoraPktMode lora_pkt_len_mode;
  
  if (*(char *)&item[1].vtable == '\0')
  {
    lora_pkt_len_mode = DEVICE_MESSAGE__RADIO_DEFS__LORA_PKT_MODE__LORA_PKT_EXPLICIT;
  }
  else if (*(char *)&item[1].vtable == '\x01')
  {
    lora_pkt_len_mode = DEVICE_MESSAGE__RADIO_DEFS__LORA_PKT_MODE__LORA_PKT_IMPLICIT;
  }
  else
  {
    lora_pkt_len_mode = DEVICE_MESSAGE__RADIO_DEFS__LORA_PKT_MODE__LORA_PKT_EXPLICIT;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for LORA_PACKET_LEN_MODE : %d",
                        (uint)*(byte *)&item[1].vtable);
  }
  protobuf->radio_configuration->lora_parameters->lora_pkt_mode = lora_pkt_len_mode;
  return;
}



void read_fsk_pulse_shape_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_gfsk_pulse_shape_t gfsk_pulse_shape;
  
  switch(protobuf->radio_configuration->fsk_parameters->fsk_pulse_shape)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_OFF:
    gfsk_pulse_shape = RAL_GFSK_PULSE_SHAPE_OFF;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_03:
    gfsk_pulse_shape = RAL_GFSK_PULSE_SHAPE_BT_03;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_05:
    gfsk_pulse_shape = RAL_GFSK_PULSE_SHAPE_BT_05;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_07:
    gfsk_pulse_shape = RAL_GFSK_PULSE_SHAPE_BT_07;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_1:
    gfsk_pulse_shape = RAL_GFSK_PULSE_SHAPE_BT_1;
    break;
  default:
    gfsk_pulse_shape = RAL_GFSK_PULSE_SHAPE_OFF;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"No configuration found for FSK_PULSE_SHAPE, default value %d applied",0);
  }
  read_from(item,&gfsk_pulse_shape);
  return;
}



void write_fsk_pulse_shape_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_gfsk_pulse_shape_t *gfsk_pulse_shape_item;
  DeviceMessage__RadioDefs__FskPulseShape gfsk_pulse_shape;
  
  switch(*(undefined1 *)&item[1].vtable)
  {
  case 0:
    gfsk_pulse_shape = DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_OFF;
    break;
  case 1:
    gfsk_pulse_shape = DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_03;
    break;
  case 2:
    gfsk_pulse_shape = DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_05;
    break;
  case 3:
    gfsk_pulse_shape = DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_07;
    break;
  case 4:
    gfsk_pulse_shape = DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_BT_1;
    break;
  default:
    gfsk_pulse_shape = DEVICE_MESSAGE__RADIO_DEFS__FSK_PULSE_SHAPE__GFSK_PULSE_SHAPE_OFF;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for GFSK_PULSE_SHAPE");
  }
  protobuf->radio_configuration->fsk_parameters->fsk_pulse_shape = gfsk_pulse_shape;
  return;
}



void read_fsk_preamble_detector_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_gfsk_preamble_detector_t gfsk_preamble_detector;
  
  switch(protobuf->radio_configuration->fsk_parameters->fsk_preamble_detector)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_OFF:
    gfsk_preamble_detector = RAL_GFSK_PREAMBLE_DETECTOR_OFF;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_8BITS:
    gfsk_preamble_detector = RAL_GFSK_PREAMBLE_DETECTOR_MIN_8BITS;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_16BITS:
    gfsk_preamble_detector = RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_24BITS:
    gfsk_preamble_detector = RAL_GFSK_PREAMBLE_DETECTOR_MIN_24BITS;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_32BITS:
    gfsk_preamble_detector = RAL_GFSK_PREAMBLE_DETECTOR_MIN_32BITS;
    break;
  default:
    gfsk_preamble_detector = RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,
                        "No configuration found for FSK_PREAMBLE_DETECTOR, default value %d applied"
                        ,0x10);
  }
  read_from(item,&gfsk_preamble_detector);
  return;
}



void write_fsk_preamble_detector_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_gfsk_preamble_detector_t *gfsk_preamble_detector_item;
  DeviceMessage__RadioDefs__FskPreambleDetector gfsk_preamble_detector;
  
  if (false)
  {
switchD_08008ef4_caseD_1:
    gfsk_preamble_detector =
         DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_OFF;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for GFSK_PREAMBLE_DETECTOR : %d",
                        (uint)*(byte *)&item[1].vtable);
  }
  else
  {
    switch(*(undefined1 *)&item[1].vtable)
    {
    case 0:
      gfsk_preamble_detector =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_OFF;
      break;
    default:
      goto switchD_08008ef4_caseD_1;
    case 8:
      gfsk_preamble_detector =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_8BITS;
      break;
    case 0x10:
      gfsk_preamble_detector =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_16BITS;
      break;
    case 0x18:
      gfsk_preamble_detector =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_24BITS;
      break;
    case 0x20:
      gfsk_preamble_detector =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_PREAMBLE_DETECTOR__GFSK_PREAMBLE_DETECTOR_MIN_32BITS;
    }
  }
  protobuf->radio_configuration->fsk_parameters->fsk_preamble_detector = gfsk_preamble_detector;
  return;
}



void read_fsk_address_filtering_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__RadioDefs__FskAddressFiltering DVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_gfsk_address_filtering_t gfsk_address_filtering;
  
  DVar1 = protobuf->radio_configuration->fsk_parameters->fsk_address_filtering;
  if (DVar1 == 
      DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES
     )
  {
    gfsk_address_filtering = RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES;
    goto LAB_08009014;
  }
  if (DVar1 < (
              DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES
              |
              DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_NODE_ADDRESS
              ))
  {
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_DISABLE)
    {
      gfsk_address_filtering = RAL_GFSK_ADDRESS_FILTERING_DISABLE;
      goto LAB_08009014;
    }
    if (DVar1 == 
        DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_NODE_ADDRESS)
    {
      gfsk_address_filtering = RAL_GFSK_ADDRESS_FILTERING_NODE_ADDRESS;
      goto LAB_08009014;
    }
  }
  gfsk_address_filtering = RAL_GFSK_ADDRESS_FILTERING_DISABLE;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "No configuration found for FSK_ADDRESS_FILTERING, default value %d applied",0
                     );
LAB_08009014:
  read_from(item,&gfsk_address_filtering);
  return;
}



void write_fsk_address_filtering_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  byte bVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_gfsk_address_filtering_t *gfsk_address_filtering_item;
  DeviceMessage__RadioDefs__FskAddressFiltering gfsk_address_filtering;
  
  bVar1 = *(byte *)&item[1].vtable;
  if (bVar1 == 2)
  {
    gfsk_address_filtering =
         DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES
    ;
    goto LAB_0800907a;
  }
  if (bVar1 < 3)
  {
    if (bVar1 == 0)
    {
      gfsk_address_filtering =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_DISABLE;
      goto LAB_0800907a;
    }
    if (bVar1 == 1)
    {
      gfsk_address_filtering =
           DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_NODE_ADDRESS;
      goto LAB_0800907a;
    }
  }
  gfsk_address_filtering =
       DEVICE_MESSAGE__RADIO_DEFS__FSK_ADDRESS_FILTERING__GFSK_ADDRESS_FILTERING_DISABLE;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Unknown configuration found for GFSK ADDRESS FILTERING : %d",
                      (uint)*(byte *)&item[1].vtable);
LAB_0800907a:
  protobuf->radio_configuration->fsk_parameters->fsk_address_filtering = gfsk_address_filtering;
  return;
}



void read_fsk_pkt_len_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__RadioDefs__FskHeaderType DVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_gfsk_pkt_len_modes_t gfsk_packet_len_mode;
  
  DVar1 = protobuf->radio_configuration->fsk_parameters->fsk_header_type;
  if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_VAR_LEN_SX128X_COMP)
  {
    gfsk_packet_len_mode = RAL_GFSK_PKT_VAR_LEN_SX128X_COMP;
    goto LAB_080090dc;
  }
  if (DVar1 < (DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_VAR_LEN_SX128X_COMP|
              DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_VAR_LEN))
  {
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_FIX_LEN)
    {
      gfsk_packet_len_mode = RAL_GFSK_PKT_FIX_LEN;
      goto LAB_080090dc;
    }
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_VAR_LEN)
    {
      gfsk_packet_len_mode = RAL_GFSK_PKT_VAR_LEN;
      goto LAB_080090dc;
    }
  }
  gfsk_packet_len_mode = RAL_GFSK_PKT_VAR_LEN;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "No configuration found for FSK_HEADER_TYPE, default value %d applied",1);
LAB_080090dc:
  read_from(item,&gfsk_packet_len_mode);
  return;
}



void write_fsk_pkt_len_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  byte bVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_gfsk_pkt_len_modes_t *gfsk_packet_len_mode_item;
  DeviceMessage__RadioDefs__FskHeaderType gfsk_packet_len_mode;
  
  bVar1 = *(byte *)&item[1].vtable;
  if (bVar1 == 2)
  {
    gfsk_packet_len_mode = DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_VAR_LEN_SX128X_COMP
    ;
    goto LAB_08009142;
  }
  if (bVar1 < 3)
  {
    if (bVar1 == 0)
    {
      gfsk_packet_len_mode = DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_FIX_LEN;
      goto LAB_08009142;
    }
    if (bVar1 == 1)
    {
      gfsk_packet_len_mode = DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_VAR_LEN;
      goto LAB_08009142;
    }
  }
  gfsk_packet_len_mode = DEVICE_MESSAGE__RADIO_DEFS__FSK_HEADER_TYPE__GFSK_PKT_FIX_LEN;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Unknown configuration found for GFSK PKT LEN MODE : %d",
                      (uint)*(byte *)&item[1].vtable);
LAB_08009142:
  protobuf->radio_configuration->fsk_parameters->fsk_header_type = gfsk_packet_len_mode;
  return;
}



void read_fsk_crc_type_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_gfsk_crc_type_t gfsk_crc_type;
  
  switch(protobuf->radio_configuration->fsk_parameters->fsk_crc_type)
  {
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_OFF:
    gfsk_crc_type = RAL_GFSK_CRC_OFF;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_1_BYTE:
    gfsk_crc_type = RAL_GFSK_CRC_1_BYTE;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_2_BYTES:
    gfsk_crc_type = RAL_GFSK_CRC_2_BYTES;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_1_BYTE_INV:
    gfsk_crc_type = RAL_GFSK_CRC_1_BYTE_INV;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_2_BYTES_INV:
    gfsk_crc_type = RAL_GFSK_CRC_2_BYTES_INV;
    break;
  case DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_3_BYTES:
    gfsk_crc_type = RAL_GFSK_CRC_3_BYTES;
    break;
  default:
    gfsk_crc_type = RAL_GFSK_CRC_1_BYTE_INV;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"No configuration found for FSK_CRC_TYPE, default value %d applied",4);
  }
  read_from(item,&gfsk_crc_type);
  return;
}



void write_fsk_crc_type_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_gfsk_crc_type_t *gfsk_crc_type_item;
  DeviceMessage__RadioDefs__FskCrcType gfsk_crc_type;
  
  switch(*(undefined1 *)&item[1].vtable)
  {
  case 1:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_OFF;
    break;
  case 2:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_1_BYTE;
    break;
  case 3:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_2_BYTES;
    break;
  case 4:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_1_BYTE_INV;
    break;
  case 5:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_2_BYTES_INV;
    break;
  case 6:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_3_BYTES;
    break;
  default:
    gfsk_crc_type = DEVICE_MESSAGE__RADIO_DEFS__FSK_CRC_TYPE__GFSK_CRC_OFF;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Unknown configuration found for GFSK_CRC_TYPE : %d",
                        (uint)*(byte *)&item[1].vtable);
  }
  protobuf->radio_configuration->fsk_parameters->fsk_crc_type = gfsk_crc_type;
  return;
}



void read_fsk_dc_free_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__RadioDefs__FskDcFree DVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  ral_gfsk_dc_free_t gfsk_dc_free;
  
  DVar1 = protobuf->radio_configuration->fsk_parameters->fsk_dc_free;
  if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_WHITENING_SX128X_COMP)
  {
    gfsk_dc_free = RAL_GFSK_DC_FREE_WHITENING_SX128X_COMP;
    goto LAB_080092b8;
  }
  if (DVar1 < (DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_WHITENING_SX128X_COMP|
              DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_WHITENING))
  {
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_OFF)
    {
      gfsk_dc_free = RAL_GFSK_DC_FREE_OFF;
      goto LAB_080092b8;
    }
    if (DVar1 == DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_WHITENING)
    {
      gfsk_dc_free = RAL_GFSK_DC_FREE_WHITENING;
      goto LAB_080092b8;
    }
  }
  gfsk_dc_free = RAL_GFSK_DC_FREE_OFF;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "No configuration found for FSK_DC_FREE, default value %d applied",0);
LAB_080092b8:
  read_from(item,&gfsk_dc_free);
  return;
}



void write_fsk_dc_free_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  byte bVar1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  configuration_item_ral_gfsk_dc_free_t *gfsk_dc_free_item;
  DeviceMessage__RadioDefs__FskDcFree gfsk_dc_free;
  
  bVar1 = *(byte *)&item[1].vtable;
  if (bVar1 == 2)
  {
    gfsk_dc_free = DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_WHITENING_SX128X_COMP;
    goto LAB_0800931e;
  }
  if (bVar1 < 3)
  {
    if (bVar1 == 0)
    {
      gfsk_dc_free = DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_OFF;
      goto LAB_0800931e;
    }
    if (bVar1 == 1)
    {
      gfsk_dc_free = DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_WHITENING;
      goto LAB_0800931e;
    }
  }
  gfsk_dc_free = DEVICE_MESSAGE__RADIO_DEFS__FSK_DC_FREE__GFSK_DC_FREE_OFF;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Unknown configuration found for GFSK DC FREE : %d",
                      (uint)*(byte *)&item[1].vtable);
LAB_0800931e:
  protobuf->radio_configuration->fsk_parameters->fsk_dc_free = gfsk_dc_free;
  return;
}



// WARNING: Unknown calling convention

radio_parameters_t * common_radio_parameters_init(void)
{
  configuration_item__Bool local_338;
  configuration_item_struct_ook_parameters_t local_ook_params;
  configuration_item_struct_gfsk_parameters_t local_gfsk_params;
  configuration_item_struct_flrc_parameters_t local_flrc_params;
  configuration_item_struct_lora_parameters_t local_lora_params;
  
  build_config_item_uint32_t((configuration_item_uint32_t *)&local_338,868000000);
  radio_parameters.rf_freq_in_hz.base.vtable = local_338.base.vtable;
  radio_parameters.rf_freq_in_hz.base.size = local_338.base.size;
  radio_parameters.rf_freq_in_hz.val = local_338._8_4_;
  build_config_item_int32_t((configuration_item_int32_t *)&local_338,0x2c);
  radio_parameters.tx_output_pwr_in_half_dbm.base.vtable = local_338.base.vtable;
  radio_parameters.tx_output_pwr_in_half_dbm.base.size = local_338.base.size;
  radio_parameters.tx_output_pwr_in_half_dbm.val = local_338._8_4_;
  build_config_item__Bool(&local_338,false);
  radio_parameters.enable_rx_boost_mode.base.vtable = local_338.base.vtable;
  radio_parameters.enable_rx_boost_mode.base.size = local_338.base.size;
  radio_parameters.enable_rx_boost_mode.val = local_338.val;
  radio_parameters.enable_rx_boost_mode._9_3_ = local_338._9_3_;
  build_config_item_uint16_t((configuration_item_uint16_t *)&local_338,7);
  radio_parameters.payload_length.base.vtable = local_338.base.vtable;
  radio_parameters.payload_length.base.size = local_338.base.size;
  radio_parameters.payload_length._8_4_ = local_338._8_4_;
  build_config_item_shield_packet_type_t
            ((configuration_item_shield_packet_type_t *)&local_338,SHIELD_PKT_TYPE_LORA);
  radio_parameters.packet_type.base.vtable = local_338.base.vtable;
  radio_parameters.packet_type.base.size = local_338.base.size;
  radio_parameters.packet_type.val = local_338.val;
  radio_parameters.packet_type._9_3_ = local_338._9_3_;
  build_config_item_ral_fallback_modes_t
            ((configuration_item_ral_fallback_modes_t *)&local_338,RAL_FALLBACK_STDBY_RC);
  radio_parameters.fallback_mode.base.vtable = local_338.base.vtable;
  radio_parameters.fallback_mode.base.size = local_338.base.size;
  radio_parameters.fallback_mode.val = local_338.val;
  radio_parameters.fallback_mode._9_3_ = local_338._9_3_;
  build_config_item_shield_reg_mode_t
            ((configuration_item_shield_reg_mode_t *)&local_338,SHIELD_REG_MODE_SIMO_OFF);
  radio_parameters.regulator_mode.base.vtable = local_338.base.vtable;
  radio_parameters.regulator_mode.base.size = local_338.base.size;
  radio_parameters.regulator_mode.val = local_338.val;
  radio_parameters.regulator_mode._9_3_ = local_338._9_3_;
  build_config_item_ral_lora_sf_t(&local_lora_params.lora_sf,RAL_LORA_SF7);
  build_config_item_ral_lora_bw_t(&local_lora_params.lora_bw,RAL_LORA_BW_125_KHZ);
  build_config_item_ral_lora_cr_t(&local_lora_params.lora_cr,RAL_LORA_CR_4_5);
  build_config_item_ral_lora_pkt_len_modes_t(&local_lora_params.lora_pkt_mode,RAL_LORA_PKT_EXPLICIT)
  ;
  build_config_item__Bool(&local_lora_params.lora_iq,true);
  build_config_item__Bool(&local_lora_params.lora_crc,true);
  build_config_item_uint32_t(&local_lora_params.lora_preamble_len,8);
  build_config_item_uint32_t(&local_lora_params.lora_sync_word,0x34);
  build_config_item_uint32_t(&local_lora_params.lora_ldro,2);
  memcpy(&radio_parameters.lora_parameters,&local_lora_params,0x6c);
  build_config_item_shield_flrc_preamble_len_t
            (&local_flrc_params.flrc_preamble_len,SHIELD_FLRC_PREAMBLE_LEN_04_BITS);
  build_config_item_shield_flrc_sync_word_len_t
            (&local_flrc_params.flrc_sync_word_len_bytes,SHIELD_FLRC_SYNCWORD_LENGTH_4_BYTES);
  build_config_item_shield_flrc_rx_match_sync_word_t
            (&local_flrc_params.flrc_match_sync_word,SHIELD_FLRC_RX_MATCH_SYNCWORD_1);
  build_config_item_shield_flrc_tx_sync_word_t
            (&local_flrc_params.flrc_tx_sync_word,SHIELD_FLRC_TX_SYNCWORD_1);
  build_config_item_shield_flrc_pkt_len_modes_t
            (&local_flrc_params.flrc_header_type,SHIELD_FLRC_PKT_VAR_LEN);
  build_config_item_uint16_t(&local_flrc_params.flrc_pld_len_in_bytes,7);
  build_config_item_shield_flrc_crc_types_t
            (&local_flrc_params.flrc_crc_type,SHIELD_FLRC_CRC_2_BYTES);
  build_config_item_shield_flrc_br_bw_t(&local_flrc_params.flrc_bw,SHIELD_FLRC_BR_2_600_BW_2_666);
  build_config_item_shield_flrc_cr_t(&local_flrc_params.flrc_cr,SHIELD_FLRC_CR_NONE);
  build_config_item_shield_flrc_pulse_shape_t
            (&local_flrc_params.flrc_pulse_shape,SHIELD_FLRC_PULSE_SHAPE_BT_05);
  build_config_item_uint32_t(&local_flrc_params.flrc_syncword_1,0x55555555);
  build_config_item_uint32_t(&local_flrc_params.flrc_syncword_2,0xf17d9742);
  build_config_item_uint32_t(&local_flrc_params.flrc_syncword_3,0x42f17d93);
  memcpy(&radio_parameters.flrc_parameters,&local_flrc_params,0x9c);
  build_config_item_uint32_t(&local_gfsk_params.fsk_dev,25000);
  build_config_item_uint32_t(&local_gfsk_params.fsk_bitrate,50000);
  build_config_item_uint32_t(&local_gfsk_params.fsk_bandwidth,0x1ca34);
  build_config_item_ral_gfsk_pulse_shape_t
            (&local_gfsk_params.fsk_pulse_shape,RAL_GFSK_PULSE_SHAPE_OFF);
  build_config_item_uint32_t(&local_gfsk_params.fsk_preamble_len,0x20);
  build_config_item_ral_gfsk_preamble_detector_t
            (&local_gfsk_params.fsk_preamble_detector,RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS);
  build_config_item_uint32_t(&local_gfsk_params.fsk_syncword_len,0x28);
  build_config_item_ral_gfsk_address_filtering_t
            (&local_gfsk_params.fsk_address_filtering,RAL_GFSK_ADDRESS_FILTERING_DISABLE);
  build_config_item_ral_gfsk_pkt_len_modes_t
            (&local_gfsk_params.fsk_pkt_len_mode,RAL_GFSK_PKT_VAR_LEN);
  build_config_item_ral_gfsk_crc_type_t(&local_gfsk_params.fsk_crc_type,RAL_GFSK_CRC_1_BYTE_INV);
  build_config_item_ral_gfsk_dc_free_t(&local_gfsk_params.fsk_dc_free,RAL_GFSK_DC_FREE_OFF);
  build_config_item_uint64_t(&local_gfsk_params.fsk_sync_word,0x123456789abcdef);
  build_config_item_uint32_t(&local_gfsk_params.fsk_whitening_seed,0x123);
  build_config_item_uint32_t(&local_gfsk_params.fsk_crc_seed,0x1234567);
  build_config_item_uint32_t(&local_gfsk_params.fsk_crc_polynomial,0x1234567);
  build_config_item_uint32_t(&local_gfsk_params.fsk_node_address,5);
  build_config_item_uint32_t(&local_gfsk_params.fsk_broadcast_address,0xab);
  memcpy(&radio_parameters.gfsk_parameters,&local_gfsk_params,0xd8);
  build_config_item_uint32_t(&local_ook_params.ook_bitrate,32000);
  build_config_item_uint32_t(&local_ook_params.ook_bandwidth,0x255a8);
  build_config_item_uint32_t(&local_ook_params.ook_preamble_length,0x20);
  build_config_item_shield_ook_pulse_shape_filter_t
            (&local_ook_params.ook_pulse_shape_filter,SHIELD_OOK_PULSE_SHAPE_NO_FILTER);
  build_config_item_shield_ook_pulse_shape_bt_t
            (&local_ook_params.ook_shape_filter_bt,SHIELD_OOK_PULSE_SHAPE_BT_0_5);
  build_config_item_shield_ook_mag_depth_t
            (&local_ook_params.ook_mag_depth,SHIELD_OOK_MAG_DEPTH_FULL);
  build_config_item_shield_ook_address_filtering_t
            (&local_ook_params.ook_address_filtering,SHIELD_OOK_ADDRESS_FILTERING_DISABLED);
  build_config_item_shield_ook_header_mode_t
            (&local_ook_params.ook_header_mode,SHIELD_OOK_HEADER_IMPLICIT);
  build_config_item_shield_ook_crc_t(&local_ook_params.ook_crc_type,SHIELD_OOK_CRC_OFF);
  build_config_item_shield_ook_encoding_t(&local_ook_params.ook_encoding,SHIELD_OOK_ENCODING_OFF);
  build_config_item_uint32_t(&local_ook_params.ook_crc_polynomial,0x1234567);
  build_config_item_uint32_t(&local_ook_params.ook_crc_seed,0x1234567);
  build_config_item_uint32_t(&local_ook_params.ook_sync_word,0x7f536564);
  build_config_item_uint32_t(&local_ook_params.ook_sync_word_len_bits,0x20);
  build_config_item_shield_ook_syncword_bit_order_t
            (&local_ook_params.ook_sync_word_bit_order,SHIELD_OOK_SYNCWORD_MSBF);
  build_config_item__Bool(&local_ook_params.ook_sync_word_is_encoded,false);
  build_config_item_shield_ook_rx_detector_sfd_type_t
            (&local_ook_params.ook_rx_detector_sfd,SHIELD_OOK_RX_DETECTOR_SFD_TYPE_FALLING_EDGE);
  build_config_item_uint16_t(&local_ook_params.ook_rx_detector_pattern,5);
  build_config_item_uint8_t(&local_ook_params.ook_rx_detector_pattern_length,'\x03');
  build_config_item_uint8_t(&local_ook_params.ook_rx_detector_pattern_repeat_nb,'\b');
  build_config_item_uint8_t(&local_ook_params.ook_rx_detector_sfd_length,'\0');
  build_config_item_uint8_t(&local_ook_params.ook_node_address,'\x05');
  build_config_item_uint8_t(&local_ook_params.ook_broadcast_address,0xab);
  build_config_item_uint8_t(&local_ook_params.ook_whitening_bit_index,'\x01');
  build_config_item_uint16_t(&local_ook_params.ook_whitening_polynomial,0);
  build_config_item_uint16_t(&local_ook_params.ook_whitening_seed,0x123);
  memcpy(&radio_parameters.ook_parameters,&local_ook_params,0x138);
  return &radio_parameters;
}



// WARNING: Unknown calling convention

radio_parameters_t * common_radio_get_parameters(void)
{
  return &radio_parameters;
}



void common_radio_get_lora_parameters
               (ral_lora_mod_params_t *lora_mod_params,ral_lora_pkt_params_t *lora_pkt_params)
{
  ral_lora_pkt_params_t *lora_pkt_params_local;
  ral_lora_mod_params_t *lora_mod_params_local;
  
  lora_mod_params->bw = radio_parameters.lora_parameters.lora_bw.val;
  lora_mod_params->cr = radio_parameters.lora_parameters.lora_cr.val;
  lora_mod_params->sf = radio_parameters.lora_parameters.lora_sf.val;
  lora_mod_params->ldro = (uint8_t)radio_parameters.lora_parameters.lora_ldro.val;
  lora_pkt_params->crc_is_on = radio_parameters.lora_parameters.lora_crc.val;
  lora_pkt_params->header_type = radio_parameters.lora_parameters.lora_pkt_mode.val;
  lora_pkt_params->invert_iq_is_on = radio_parameters.lora_parameters.lora_iq.val;
  lora_pkt_params->pld_len_in_bytes = (uint8_t)radio_parameters.payload_length.val;
  lora_pkt_params->preamble_len_in_symb =
       (uint16_t)radio_parameters.lora_parameters.lora_preamble_len.val;
  return;
}



void common_radio_get_gfsk_parameters
               (ral_gfsk_mod_params_t *gfsk_mod_params,ral_gfsk_pkt_params_t *gfsk_pkt_params)
{
  ral_gfsk_pkt_params_t *gfsk_pkt_params_local;
  ral_gfsk_mod_params_t *gfsk_mod_params_local;
  
  gfsk_mod_params->br_in_bps = radio_parameters.gfsk_parameters.fsk_bitrate.val;
  gfsk_mod_params->bw_dsb_in_hz = radio_parameters.gfsk_parameters.fsk_bandwidth.val;
  gfsk_mod_params->fdev_in_hz = radio_parameters.gfsk_parameters.fsk_dev.val;
  gfsk_mod_params->pulse_shape = radio_parameters.gfsk_parameters.fsk_pulse_shape.val;
  gfsk_pkt_params->address_filtering = radio_parameters.gfsk_parameters.fsk_address_filtering.val;
  gfsk_pkt_params->crc_type = radio_parameters.gfsk_parameters.fsk_crc_type.val;
  gfsk_pkt_params->dc_free = radio_parameters.gfsk_parameters.fsk_dc_free.val;
  gfsk_pkt_params->header_type = radio_parameters.gfsk_parameters.fsk_pkt_len_mode.val;
  gfsk_pkt_params->pld_len_in_bytes = radio_parameters.payload_length.val;
  gfsk_pkt_params->preamble_detector = radio_parameters.gfsk_parameters.fsk_preamble_detector.val;
  gfsk_pkt_params->preamble_len_in_bits =
       (uint16_t)radio_parameters.gfsk_parameters.fsk_preamble_len.val;
  gfsk_pkt_params->sync_word_len_in_bits =
       (uint8_t)radio_parameters.gfsk_parameters.fsk_syncword_len.val;
  return;
}



void common_radio_get_flrc_parameters
               (shield_flrc_mod_params_t *flrc_mod_params,shield_flrc_pkt_params_t *flrc_pkt_params)
{
  shield_flrc_pkt_params_t *flrc_pkt_params_local;
  shield_flrc_mod_params_t *flrc_mod_params_local;
  
  flrc_mod_params->br_bw = radio_parameters.flrc_parameters.flrc_bw.val;
  flrc_mod_params->cr = radio_parameters.flrc_parameters.flrc_cr.val;
  flrc_mod_params->shape = radio_parameters.flrc_parameters.flrc_pulse_shape.val;
  flrc_pkt_params->crc_type = radio_parameters.flrc_parameters.flrc_crc_type.val;
  flrc_pkt_params->header_type = radio_parameters.flrc_parameters.flrc_header_type.val;
  flrc_pkt_params->match_sync_word = radio_parameters.flrc_parameters.flrc_match_sync_word.val;
  flrc_pkt_params->tx_sync_word = radio_parameters.flrc_parameters.flrc_tx_sync_word.val;
  flrc_pkt_params->pld_len_in_bytes = radio_parameters.payload_length.val;
  flrc_pkt_params->preamble_len = radio_parameters.flrc_parameters.flrc_preamble_len.val;
  flrc_pkt_params->sync_word_len_bytes =
       radio_parameters.flrc_parameters.flrc_sync_word_len_bytes.val;
  return;
}



void common_radio_get_ook_parameters
               (shield_ook_mod_params_t *ook_mod_params,shield_ook_pkt_params_t *ook_pkt_params)
{
  shield_ook_pkt_params_t *ook_pkt_params_local;
  shield_ook_mod_params_t *ook_mod_params_local;
  
  ook_mod_params->br = radio_parameters.ook_parameters.ook_bitrate.val;
  ook_mod_params->bw = radio_parameters.ook_parameters.ook_bandwidth.val;
  ook_mod_params->mag_depth = radio_parameters.ook_parameters.ook_mag_depth.val;
  (ook_mod_params->pulse_shape).filter = radio_parameters.ook_parameters.ook_pulse_shape_filter.val;
  (ook_mod_params->pulse_shape).bt = radio_parameters.ook_parameters.ook_shape_filter_bt.val;
  ook_pkt_params->address_filtering = radio_parameters.ook_parameters.ook_address_filtering.val;
  ook_pkt_params->crc = radio_parameters.ook_parameters.ook_crc_type.val;
  ook_pkt_params->encoding = radio_parameters.ook_parameters.ook_encoding.val;
  ook_pkt_params->header_mode = radio_parameters.ook_parameters.ook_header_mode.val;
  ook_pkt_params->payload_length = radio_parameters.payload_length.val;
  ook_pkt_params->pbl_length_in_bit =
       (uint16_t)radio_parameters.ook_parameters.ook_preamble_length.val;
  return;
}



void common_radio_get_ook_rx_detector(shield_ook_rx_detector_t *ook_rx_detector_params)
{
  shield_ook_rx_detector_t *ook_rx_detector_params_local;
  
  ook_rx_detector_params->is_syncword_encoded =
       radio_parameters.ook_parameters.ook_sync_word_is_encoded.val;
  ook_rx_detector_params->pattern = radio_parameters.ook_parameters.ook_rx_detector_pattern.val;
  ook_rx_detector_params->pattern_length_in_bit =
       radio_parameters.ook_parameters.ook_rx_detector_pattern_length.val;
  ook_rx_detector_params->pattern_repeat_nb =
       radio_parameters.ook_parameters.ook_rx_detector_pattern_repeat_nb.val;
  ook_rx_detector_params->sfd_length_in_bit =
       radio_parameters.ook_parameters.ook_rx_detector_sfd_length.val;
  ook_rx_detector_params->sfd_type = radio_parameters.ook_parameters.ook_rx_detector_sfd.val;
  return;
}



void common_radio_get_ook_whitening_params(shield_ook_whitening_params_t *ook_whitening_params)
{
  shield_ook_whitening_params_t *ook_whitening_params_local;
  
  ook_whitening_params->bit_index = radio_parameters.ook_parameters.ook_whitening_bit_index.val;
  ook_whitening_params->polynomial = radio_parameters.ook_parameters.ook_whitening_polynomial.val;
  ook_whitening_params->seed = radio_parameters.ook_parameters.ook_whitening_seed.val;
  return;
}



void common_radio_get_ook_addresses(uint32_t *node_address,uint32_t *broadcast_address)
{
  uint32_t *broadcast_address_local;
  uint32_t *node_address_local;
  
  *node_address = (uint)radio_parameters.ook_parameters.ook_node_address.val;
  *broadcast_address = (uint)radio_parameters.ook_parameters.ook_broadcast_address.val;
  return;
}



void common_radio_get_ook_crc_params(uint32_t *crc_polynomial,uint32_t *crc_seed)
{
  uint32_t *crc_seed_local;
  uint32_t *crc_polynomial_local;
  
  *crc_polynomial = radio_parameters.ook_parameters.ook_crc_polynomial.val;
  *crc_seed = radio_parameters.ook_parameters.ook_crc_seed.val;
  return;
}



void common_radio_get_ook_syncword_params
               (uint8_t *syncword,uint8_t *sync_len_bits,shield_ook_syncword_bit_order_t *bit_order)
{
  shield_ook_syncword_bit_order_t *bit_order_local;
  uint8_t *sync_len_bits_local;
  uint8_t *syncword_local;
  
  *syncword = (uint8_t)radio_parameters.ook_parameters.ook_sync_word.val;
  syncword[1] = (uint8_t)(radio_parameters.ook_parameters.ook_sync_word.val >> 8);
  syncword[2] = (uint8_t)(radio_parameters.ook_parameters.ook_sync_word.val >> 0x10);
  syncword[3] = (uint8_t)(radio_parameters.ook_parameters.ook_sync_word.val >> 0x18);
  *sync_len_bits = (uint8_t)radio_parameters.ook_parameters.ook_sync_word_len_bits.val;
  *bit_order = radio_parameters.ook_parameters.ook_sync_word_bit_order.val;
  return;
}



void common_radio_get_flrc_syncwords
               (uint8_t *flrc_syncword_1,uint8_t *flrc_syncword_2,uint8_t *flrc_syncword_3)
{
  uint8_t *flrc_syncword_3_local;
  uint8_t *flrc_syncword_2_local;
  uint8_t *flrc_syncword_1_local;
  
  apps_utilities_uint_to_buf
            ('\x04',flrc_syncword_1,(ulonglong)radio_parameters.flrc_parameters.flrc_syncword_1.val)
  ;
  apps_utilities_uint_to_buf
            ('\x04',flrc_syncword_2,(ulonglong)radio_parameters.flrc_parameters.flrc_syncword_2.val)
  ;
  apps_utilities_uint_to_buf
            ('\x04',flrc_syncword_3,(ulonglong)radio_parameters.flrc_parameters.flrc_syncword_3.val)
  ;
  return;
}



void common_radio_register_configuration_to_manager(configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  
  append_storage_with_protobuf
            (manager,(configuration_item_t *)&radio_parameters,(read_from_protobuf_f)0x8007799,
             (write_to_protobuf_f)0x80077b9);
  append_storage_with_protobuf
            (manager,&radio_parameters.tx_output_pwr_in_half_dbm.base,
             (read_from_protobuf_f)0x80077d9,(write_to_protobuf_f)0x80077f9);
  append_storage_with_protobuf
            (manager,&radio_parameters.enable_rx_boost_mode.base,(read_from_protobuf_f)0x8007819,
             (write_to_protobuf_f)0x8007839);
  append_storage_with_protobuf
            (manager,&radio_parameters.payload_length.base,(read_from_protobuf_f)0x8007859,
             (write_to_protobuf_f)0x8007879);
  append_storage_with_protobuf
            (manager,&radio_parameters.packet_type.base,(read_from_protobuf_f)0x80086ed,
             (write_to_protobuf_f)0x8008765);
  append_storage_with_protobuf
            (manager,&radio_parameters.fallback_mode.base,(read_from_protobuf_f)0x80087d5,
             (write_to_protobuf_f)0x8008839);
  append_storage_with_protobuf
            (manager,&radio_parameters.regulator_mode.base,(read_from_protobuf_f)0x8007899,
             (write_to_protobuf_f)0x80078b9);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)&radio_parameters.lora_parameters,
             (read_from_protobuf_f)0x800889d,(write_to_protobuf_f)0x8008939);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_bw.base,(read_from_protobuf_f)0x80089d9,
             (write_to_protobuf_f)0x8008ab9);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_cr.base,(read_from_protobuf_f)0x8008b99,
             (write_to_protobuf_f)0x8008c29);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_pkt_mode.base,
             (read_from_protobuf_f)0x8008cbd,(write_to_protobuf_f)0x8008d15);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_iq.base,(read_from_protobuf_f)0x80078d9,
             (write_to_protobuf_f)0x80078fb);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_crc.base,(read_from_protobuf_f)0x800791d
             ,(write_to_protobuf_f)0x800793f);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_ldro.base,
             (read_from_protobuf_f)0x80079e9,(write_to_protobuf_f)0x8007a0b);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_preamble_len.base,
             (read_from_protobuf_f)0x8007961,(write_to_protobuf_f)0x8007983);
  append_storage_with_protobuf
            (manager,&radio_parameters.lora_parameters.lora_sync_word.base,
             (read_from_protobuf_f)0x80079a5,(write_to_protobuf_f)0x80079c7);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)&radio_parameters.gfsk_parameters,
             (read_from_protobuf_f)0x8007a2d,(write_to_protobuf_f)0x8007a4f);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_bitrate.base,
             (read_from_protobuf_f)0x8007a71,(write_to_protobuf_f)0x8007a93);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_bandwidth.base,
             (read_from_protobuf_f)0x8007ab5,(write_to_protobuf_f)0x8007ad7);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_pulse_shape.base,
             (read_from_protobuf_f)0x8008d6d,(write_to_protobuf_f)0x8008de9);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_preamble_len.base,
             (read_from_protobuf_f)0x8007af9,(write_to_protobuf_f)0x8007b1b);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_preamble_detector.base,
             (read_from_protobuf_f)0x8008e61,(write_to_protobuf_f)0x8008edd);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_syncword_len.base,
             (read_from_protobuf_f)0x8007b3d,(write_to_protobuf_f)0x8007b5f);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_address_filtering.base,
             (read_from_protobuf_f)0x8008fc9,(write_to_protobuf_f)0x800902d);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_pkt_len_mode.base,
             (read_from_protobuf_f)0x8009091,(write_to_protobuf_f)0x80090f5);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_crc_type.base,
             (read_from_protobuf_f)0x8009159,(write_to_protobuf_f)0x80091e1);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_dc_free.base,
             (read_from_protobuf_f)0x800926d,(write_to_protobuf_f)0x80092d1);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_sync_word.base,
             (read_from_protobuf_f)0x8007b81,(write_to_protobuf_f)0x8007ba3);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_whitening_seed.base,
             (read_from_protobuf_f)0x8007bc5,(write_to_protobuf_f)0x8007be7);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_crc_seed.base,
             (read_from_protobuf_f)0x8007c09,(write_to_protobuf_f)0x8007c2b);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_crc_polynomial.base,
             (read_from_protobuf_f)0x8007c4d,(write_to_protobuf_f)0x8007c6f);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_node_address.base,
             (read_from_protobuf_f)0x8007c91,(write_to_protobuf_f)0x8007cb3);
  append_storage_with_protobuf
            (manager,&radio_parameters.gfsk_parameters.fsk_broadcast_address.base,
             (read_from_protobuf_f)0x8007cd5,(write_to_protobuf_f)0x8007cf7);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)&radio_parameters.flrc_parameters,
             (read_from_protobuf_f)0x8007d19,(write_to_protobuf_f)0x8007d3b);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_sync_word_len_bytes.base,
             (read_from_protobuf_f)0x8007d5d,(write_to_protobuf_f)0x8007d7f);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_match_sync_word.base,
             (read_from_protobuf_f)0x8007da1,(write_to_protobuf_f)0x8007dc3);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_crc_type.base,
             (read_from_protobuf_f)0x8007de5,(write_to_protobuf_f)0x8007e07);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_bw.base,(read_from_protobuf_f)0x8007e29,
             (write_to_protobuf_f)0x8007e4b);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_cr.base,(read_from_protobuf_f)0x8007e6d,
             (write_to_protobuf_f)0x8007e8f);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_pulse_shape.base,
             (read_from_protobuf_f)0x8007eb1,(write_to_protobuf_f)0x8007ed3);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_header_type.base,
             (read_from_protobuf_f)0x8007ef5,(write_to_protobuf_f)0x8007f17);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_syncword_1.base,
             (read_from_protobuf_f)0x8007f39,(write_to_protobuf_f)0x8007f5b);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_syncword_2.base,
             (read_from_protobuf_f)0x8007f7d,(write_to_protobuf_f)0x8007f9f);
  append_storage_with_protobuf
            (manager,&radio_parameters.flrc_parameters.flrc_syncword_3.base,
             (read_from_protobuf_f)0x8007fc1,(write_to_protobuf_f)0x8007fe3);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)&radio_parameters.ook_parameters,
             (read_from_protobuf_f)0x8008005,(write_to_protobuf_f)0x8008027);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_bandwidth.base,
             (read_from_protobuf_f)0x8008049,(write_to_protobuf_f)0x800806b);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_preamble_length.base,
             (read_from_protobuf_f)0x800808d,(write_to_protobuf_f)0x80080af);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_pulse_shape_filter.base,
             (read_from_protobuf_f)0x80080d1,(write_to_protobuf_f)0x80080f3);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_shape_filter_bt.base,
             (read_from_protobuf_f)0x8008115,(write_to_protobuf_f)0x8008137);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_mag_depth.base,
             (read_from_protobuf_f)0x8008159,(write_to_protobuf_f)0x800817b);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_address_filtering.base,
             (read_from_protobuf_f)0x800819d,(write_to_protobuf_f)0x80081bf);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_header_mode.base,
             (read_from_protobuf_f)0x80081e1,(write_to_protobuf_f)0x8008203);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_encoding.base,
             (read_from_protobuf_f)0x8008225,(write_to_protobuf_f)0x8008247);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_crc_type.base,
             (read_from_protobuf_f)0x8008269,(write_to_protobuf_f)0x800828b);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_crc_polynomial.base,
             (read_from_protobuf_f)0x80082ad,(write_to_protobuf_f)0x80082cf);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_crc_seed.base,
             (read_from_protobuf_f)0x80082f1,(write_to_protobuf_f)0x8008313);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_sync_word.base,
             (read_from_protobuf_f)0x8008335,(write_to_protobuf_f)0x8008357);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_sync_word_len_bits.base,
             (read_from_protobuf_f)0x8008379,(write_to_protobuf_f)0x800839b);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_sync_word_bit_order.base,
             (read_from_protobuf_f)0x80083bd,(write_to_protobuf_f)0x80083df);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_rx_detector_sfd.base,
             (read_from_protobuf_f)0x8008445,(write_to_protobuf_f)0x8008467);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_sync_word_is_encoded.base,
             (read_from_protobuf_f)0x8008401,(write_to_protobuf_f)0x8008423);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_rx_detector_pattern.base,
             (read_from_protobuf_f)0x8008489,(write_to_protobuf_f)0x80084ab);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_rx_detector_pattern_length.base,
             (read_from_protobuf_f)0x80084cd,(write_to_protobuf_f)0x80084ef);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_rx_detector_pattern_repeat_nb.base,
             (read_from_protobuf_f)0x8008511,(write_to_protobuf_f)0x8008533);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_rx_detector_sfd_length.base,
             (read_from_protobuf_f)0x8008555,(write_to_protobuf_f)0x8008577);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_node_address.base,
             (read_from_protobuf_f)0x8008599,(write_to_protobuf_f)0x80085bb);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_broadcast_address.base,
             (read_from_protobuf_f)0x80085dd,(write_to_protobuf_f)0x80085ff);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_whitening_bit_index.base,
             (read_from_protobuf_f)0x8008621,(write_to_protobuf_f)0x8008643);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_whitening_polynomial.base,
             (read_from_protobuf_f)0x8008665,(write_to_protobuf_f)0x8008687);
  append_storage_with_protobuf
            (manager,&radio_parameters.ook_parameters.ook_whitening_seed.base,
             (read_from_protobuf_f)0x80086a9,(write_to_protobuf_f)0x80086cb);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void common_radio_print_common_configuration(void)
{
  char *pcVar1;
  char *fmt;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "Common parameters:");
  if (radio_parameters.packet_type.val == SHIELD_PKT_TYPE_OOK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Packet type   = OOK");
  }
  else
  {
    pcVar1 = ral_pkt_type_to_str(radio_parameters.packet_type.val);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Packet type   = %s",pcVar1 + 0xd);
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   RF frequency  = %u Hz",radio_parameters.rf_freq_in_hz.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Output power  = %i dBm",radio_parameters.tx_output_pwr_in_half_dbm.val);
  pcVar1 = ral_fallback_modes_to_str(radio_parameters.fallback_mode.val);
  pcVar1 = pcVar1 + 0xd;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Fallback mode = %s",pcVar1);
  if (radio_parameters.enable_rx_boost_mode.val == false)
  {
    fmt = "   Rx boost deactivated";
  }
  else
  {
    fmt = "   Rx boost activated";
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,fmt,pcVar1);
  if (radio_parameters.regulator_mode.val == SHIELD_REG_MODE_SIMO_OFF)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Regulator mode = no SIMO available, always use LDO for VDCC and VPAX",
                        pcVar1);
  }
  else if (radio_parameters.regulator_mode.val == SHIELD_REG_MODE_SIMO_NORMAL)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Regulator mode = use SIMO for VDCC and VPAX during TX mode, but not for VPAX ramping"
                        ,pcVar1);
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Regulator mode = incorrect or RFU value selected",pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void common_radio_print_lora_configuration(void)
{
  char *pcVar1;
  undefined4 uVar2;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "LoRa modulation parameters:");
  pcVar1 = ral_lora_sf_to_str(radio_parameters.lora_parameters.lora_sf.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Spreading factor = %s",pcVar1 + 9);
  pcVar1 = ral_lora_bw_to_str(radio_parameters.lora_parameters.lora_bw.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Bandwidth        = %s",pcVar1 + 0xc);
  pcVar1 = ral_lora_cr_to_str(radio_parameters.lora_parameters.lora_cr.val);
  pcVar1 = pcVar1 + 0xc;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Coding rate      = %s",pcVar1);
  if (radio_parameters.lora_parameters.lora_ldro.val == 2)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   LDRO             = Auto",pcVar1);
  }
  else if (radio_parameters.lora_parameters.lora_ldro.val < 3)
  {
    if (radio_parameters.lora_parameters.lora_ldro.val == 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "   LDRO             = Disabled",pcVar1);
    }
    else if (radio_parameters.lora_parameters.lora_ldro.val == 1)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "   LDRO             = Enabled",pcVar1);
    }
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "LoRa packet parameters:",pcVar1);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Preamble length = %d symbol(s)",
                      radio_parameters.lora_parameters.lora_preamble_len.val);
  pcVar1 = ral_lora_pkt_len_modes_to_str(radio_parameters.lora_parameters.lora_pkt_mode.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Header mode     = %s",pcVar1 + 0xd);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Payload length  = %d byte(s)",(uint)radio_parameters.payload_length.val);
  if (radio_parameters.lora_parameters.lora_crc.val == false)
  {
    uVar2 = 0x802af98;
  }
  else
  {
    uVar2 = 0x802af90;
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   CRC mode        = %s",uVar2);
  if (radio_parameters.lora_parameters.lora_iq.val == false)
  {
    uVar2 = 0x802afc8;
  }
  else
  {
    uVar2 = 0x802afbc;
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   IQ              = %s",uVar2);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "LoRa syncword = 0x%02X",radio_parameters.lora_parameters.lora_sync_word.val);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void common_radio_print_ook_configuration(void)
{
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "OOK modulation parameters:\n");
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Bitrate             = %u bps\n",
                      radio_parameters.ook_parameters.ook_bitrate.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Pulse shape filter type        = %u\n",
                      (uint)radio_parameters.ook_parameters.ook_pulse_shape_filter.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Pulse shape BT         = %u\n",
                      (uint)radio_parameters.ook_parameters.ook_shape_filter_bt.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Bandwidth           = %u\n",
                      radio_parameters.ook_parameters.ook_bandwidth.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "OOK packet parameters:\n");
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Preamble length   = %u bit(s)\n",
                      radio_parameters.ook_parameters.ook_preamble_length.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Address filtering = %u\n",
                      (uint)radio_parameters.ook_parameters.ook_address_filtering.val);
  if (radio_parameters.ook_parameters.ook_address_filtering.val !=
      SHIELD_OOK_ADDRESS_FILTERING_DISABLED)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (Node address      = 0x%02X)\n",
                        (uint)radio_parameters.ook_parameters.ook_node_address.val);
    if (radio_parameters.ook_parameters.ook_address_filtering.val ==
        SHIELD_OOK_ADDRESS_FILTERING_NODE_BROADCAST)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "     (Broadcast address = 0x%02X)\n",
                          (uint)radio_parameters.ook_parameters.ook_broadcast_address.val);
    }
  }
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Header mode       = %u\n",
                      (uint)radio_parameters.ook_parameters.ook_header_mode.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Payload length    = %u byte(s)\n",
                      (uint)radio_parameters.payload_length.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   CRC mode          = %u\n",
                      (uint)radio_parameters.ook_parameters.ook_crc_type.val);
  if (radio_parameters.ook_parameters.ook_whitening_polynomial.val != 0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Whitening polynomial       = %u\n",
                        (uint)radio_parameters.ook_parameters.ook_whitening_polynomial.val);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "   Whitening seed             = %u\n",
                        (uint)radio_parameters.ook_parameters.ook_whitening_seed.val);
  }
  if (radio_parameters.ook_parameters.ook_crc_type.val != SHIELD_OOK_CRC_OFF)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (CRC seed       = 0x%08X)\n",
                        radio_parameters.ook_parameters.ook_crc_seed.val);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (CRC polynomial = 0x%08X)\n",
                        radio_parameters.ook_parameters.ook_crc_polynomial.val);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void common_radio_print_gfsk_configuration(void)
{
  char *pcVar1;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "GFSK modulation parameters:");
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Bitrate             = %u bps",
                      radio_parameters.gfsk_parameters.fsk_bitrate.val);
  pcVar1 = ral_gfsk_pulse_shape_to_str(radio_parameters.gfsk_parameters.fsk_pulse_shape.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Pulse shape         = %s",pcVar1 + 0x15);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Bandwidth           = %d",
                      radio_parameters.gfsk_parameters.fsk_bandwidth.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Frequency deviation = %u Hz",radio_parameters.gfsk_parameters.fsk_dev.val)
  ;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "GFSK packet parameters:");
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Preamble length   = %d bit(s)",
                      radio_parameters.gfsk_parameters.fsk_preamble_len.val);
  pcVar1 = ral_gfsk_preamble_detector_to_str
                     (radio_parameters.gfsk_parameters.fsk_preamble_detector.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Preamble detector = %s",pcVar1 + 0x1b);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Syncword length   = %d bit(s)",
                      radio_parameters.gfsk_parameters.fsk_syncword_len.val);
  pcVar1 = ral_gfsk_address_filtering_to_str
                     (radio_parameters.gfsk_parameters.fsk_address_filtering.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Address filtering = %s",pcVar1 + 0x1b);
  if (radio_parameters.gfsk_parameters.fsk_address_filtering.val !=
      RAL_GFSK_ADDRESS_FILTERING_DISABLE)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (Node address      = 0x%02X)",
                        radio_parameters.gfsk_parameters.fsk_node_address.val);
    if (radio_parameters.gfsk_parameters.fsk_address_filtering.val ==
        RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "     (Broadcast address = 0x%02X)",
                          radio_parameters.gfsk_parameters.fsk_broadcast_address.val);
    }
  }
  pcVar1 = ral_gfsk_pkt_len_modes_to_str(radio_parameters.gfsk_parameters.fsk_pkt_len_mode.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Header mode       = %s",pcVar1 + 0xd);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   Payload length    = %d byte(s)",(uint)radio_parameters.payload_length.val)
  ;
  pcVar1 = ral_gfsk_crc_type_to_str(radio_parameters.gfsk_parameters.fsk_crc_type.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   CRC mode          = %s",pcVar1 + 0xd);
  if (radio_parameters.gfsk_parameters.fsk_crc_type.val != RAL_GFSK_CRC_OFF)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (CRC seed       = 0x%08X)",
                        radio_parameters.gfsk_parameters.fsk_crc_seed.val);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (CRC polynomial = 0x%08X)",
                        radio_parameters.gfsk_parameters.fsk_crc_polynomial.val);
  }
  pcVar1 = ral_gfsk_dc_free_to_str(radio_parameters.gfsk_parameters.fsk_dc_free.val);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "   DC free           = %s",pcVar1 + 0x11);
  if (radio_parameters.gfsk_parameters.fsk_dc_free.val != RAL_GFSK_DC_FREE_OFF)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "     (Whitening seed = 0x%04X)",
                        radio_parameters.gfsk_parameters.fsk_whitening_seed.val);
  }
  return;
}



void apps_utilities_uint_to_buf(uint8_t uint_size,uint8_t *out_buf,uint64_t uint_in)
{
  uint uVar1;
  int iVar2;
  uint64_t uint_in_local;
  uint8_t *out_buf_local;
  uint8_t uint_size_local;
  uint8_t index;
  
  out_buf_local = out_buf;
  for (index = '\0'; index < uint_size; index += '\x01')
  {
    iVar2 = ((uint)uint_size - (uint)index) + -1;
    uVar1 = iVar2 * 8;
    uint_in_local._0_4_ = (uint)uint_in;
    uint_in_local._4_4_ = (uint)(uint_in >> 0x20);
    *out_buf_local =
         (byte)((uint)uint_in_local >> (uVar1 & 0xff)) |
         (byte)(uint_in_local._4_4_ << (iVar2 * -8 + 0x20U & 0xff)) |
         (byte)(uint_in_local._4_4_ >> (uVar1 - 0x20 & 0xff));
    out_buf_local = out_buf_local + 1;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void user_button_init(void)
{
  smtc_hal_button_init_user_btn((_func_void_void_ptr *)0x800a9dd,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

_Bool get_and_clear_button_pressed(void)
{
  _Bool _Var1;
  
  _Var1 = button_pressed;
  if (button_pressed)
  {
    button_pressed = false;
  }
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void emulate_button_press(void)
{
  button_pressed = true;
  return;
}



void on_button_press(void *context)
{
  void *context_local;
  
  button_pressed = true;
  return;
}



demo_status_t demo_example_start(demo_t *self)
{
  demo_t *self_local;
  demo_example_t *myself;
  
  self[1].demo_name[8] = '\x01';
  return DEMO_STATUS_OK;
}



demo_status_t demo_example_stop(demo_t *self)
{
  demo_t *self_local;
  demo_example_t *myself;
  
  self[1].demo_name[8] = '\0';
  return DEMO_STATUS_OK;
}



demo_status_t demo_example_runtime(demo_t *self)
{
  uint32_t uVar1;
  int iVar2;
  demo_t *self_local;
  uint32_t now_ms;
  demo_example_t *myself;
  
  if (self[1].demo_name[8] != '\0')
  {
    uVar1 = support_timing_get_time();
    if (*(uint *)(self[1].demo_name + 4) <
        uVar1 - demo_example_runtime::lexical_block_2::last_trig_ms)
    {
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      demo_example_runtime::lexical_block_2::last_trig_ms = uVar1;
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
      iVar2 = *(int *)(self[1].demo_name + 0xc);
      *(int *)(self[1].demo_name + 0xc) = iVar2 + 1;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Example trig! ((((((((%d)))))))) at info level",iVar2);
    }
  }
  return DEMO_STATUS_OK;
}



void read_delay_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->example->delay);
  return;
}



void write_delay_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->example->delay);
  return;
}



void demo_example_register_configurations_to_manager(demo_t *self,configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  demo_t *self_local;
  demo_example_t *myself;
  
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self + 1),(read_from_protobuf_f)0x800ab45,
             (write_to_protobuf_f)0x800ab67);
  return;
}



// WARNING: Unknown calling convention

demo_example_t * demo_example_get_instance(void)
{
  demo_example_t *in_r0;
  demo_example_t demo_example;
  
  demo_example.base.vtable = &demo_example_get_instance::vtable;
  builtin_strncpy(demo_example.base.demo_name,"DEMO_EXAMPLE",0xd);
  demo_example.base.demo_name[0xd] = '\0';
  demo_example.base.demo_name[0xe] = '\0';
  demo_example.base.demo_name[0xf] = '\0';
  demo_example.base.demo_name[0x10] = '\0';
  demo_example.base.demo_name[0x11] = '\0';
  demo_example.base.demo_name[0x12] = '\0';
  demo_example.base.demo_name[0x13] = '\0';
  demo_example.base.demo_name[0x14] = '\0';
  demo_example.base.demo_name[0x15] = '\0';
  demo_example.base.demo_name[0x16] = '\0';
  demo_example.base.demo_name[0x17] = '\0';
  demo_example.base.demo_name[0x18] = '\0';
  demo_example.base.demo_id = '\x02';
  demo_example.base._30_2_ = 0;
  build_config_item_uint32_t(&demo_example.delay_ms,200);
  demo_example._44_4_ &= 0xffffff00;
  (in_r0->base).vtable = demo_example.base.vtable;
  *(undefined4 *)(in_r0->base).demo_name = demo_example.base.demo_name._0_4_;
  *(undefined4 *)((in_r0->base).demo_name + 4) = demo_example.base.demo_name._4_4_;
  *(undefined4 *)((in_r0->base).demo_name + 8) = demo_example.base.demo_name._8_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0xc) = demo_example.base.demo_name._12_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0x10) = demo_example.base.demo_name._16_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0x14) = demo_example.base.demo_name._20_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0x18) = demo_example.base._28_4_;
  (in_r0->delay_ms).base.vtable = demo_example.delay_ms.base.vtable;
  (in_r0->delay_ms).base.size = demo_example.delay_ms.base.size;
  (in_r0->delay_ms).val = demo_example.delay_ms.val;
  in_r0->running = demo_example.running;
  *(undefined3 *)&in_r0->field_0x2d = demo_example._45_3_;
  in_r0->iteration = 0;
  return in_r0;
}



char * ral_lora_sf_to_str(ral_lora_sf_t sf)
{
  char *pcVar1;
  ral_lora_sf_t sf_local;
  
  switch(sf)
  {
  case RAL_LORA_SF5:
    pcVar1 = "RAL_LORA_SF5";
    break;
  case RAL_LORA_SF6:
    pcVar1 = "RAL_LORA_SF6";
    break;
  case RAL_LORA_SF7:
    pcVar1 = "RAL_LORA_SF7";
    break;
  case RAL_LORA_SF8:
    pcVar1 = "RAL_LORA_SF8";
    break;
  case RAL_LORA_SF9:
    pcVar1 = "RAL_LORA_SF9";
    break;
  case RAL_LORA_SF10:
    pcVar1 = "RAL_LORA_SF10";
    break;
  case RAL_LORA_SF11:
    pcVar1 = "RAL_LORA_SF11";
    break;
  case RAL_LORA_SF12:
    pcVar1 = "RAL_LORA_SF12";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_LORA_SF";
  }
  return pcVar1;
}



char * ral_lora_bw_to_str(ral_lora_bw_t bw)
{
  char *pcVar1;
  ral_lora_bw_t bw_local;
  
  switch(bw)
  {
  case RAL_LORA_BW_007_KHZ:
    pcVar1 = "RAL_LORA_BW_007_KHZ";
    break;
  case RAL_LORA_BW_010_KHZ:
    pcVar1 = "RAL_LORA_BW_010_KHZ";
    break;
  case RAL_LORA_BW_015_KHZ:
    pcVar1 = "RAL_LORA_BW_015_KHZ";
    break;
  case RAL_LORA_BW_020_KHZ:
    pcVar1 = "RAL_LORA_BW_020_KHZ";
    break;
  case RAL_LORA_BW_031_KHZ:
    pcVar1 = "RAL_LORA_BW_031_KHZ";
    break;
  case RAL_LORA_BW_041_KHZ:
    pcVar1 = "RAL_LORA_BW_041_KHZ";
    break;
  case RAL_LORA_BW_062_KHZ:
    pcVar1 = "RAL_LORA_BW_062_KHZ";
    break;
  case RAL_LORA_BW_125_KHZ:
    pcVar1 = "RAL_LORA_BW_125_KHZ";
    break;
  case RAL_LORA_BW_200_KHZ:
    pcVar1 = "RAL_LORA_BW_200_KHZ";
    break;
  case RAL_LORA_BW_250_KHZ:
    pcVar1 = "RAL_LORA_BW_250_KHZ";
    break;
  case RAL_LORA_BW_400_KHZ:
    pcVar1 = "RAL_LORA_BW_400_KHZ";
    break;
  case RAL_LORA_BW_500_KHZ:
    pcVar1 = "RAL_LORA_BW_500_KHZ";
    break;
  case RAL_LORA_BW_800_KHZ:
    pcVar1 = "RAL_LORA_BW_800_KHZ";
    break;
  case RAL_LORA_BW_1000_KHZ:
    pcVar1 = "RAL_LORA_BW_1000_KHZ";
    break;
  case RAL_LORA_BW_1600_KHZ:
    pcVar1 = "RAL_LORA_BW_1600_KHZ";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_LORA_BW";
  }
  return pcVar1;
}



char * ral_pkt_type_to_str(ral_pkt_type_t type)
{
  char *pcVar1;
  ral_pkt_type_t type_local;
  
  switch(type)
  {
  case RAL_PKT_TYPE_GFSK:
    pcVar1 = "RAL_PKT_TYPE_GFSK";
    break;
  case RAL_PKT_TYPE_LORA:
    pcVar1 = "RAL_PKT_TYPE_LORA";
    break;
  case RAL_PKT_TYPE_FLRC:
    pcVar1 = "RAL_PKT_TYPE_FLRC";
    break;
  case RAL_PKT_TYPE_RTTOF:
    pcVar1 = "RAL_PKT_TYPE_RTTOF";
    break;
  default:
    pcVar1 = "UNKNOWN_RAL_PKT_TYPE";
  }
  return pcVar1;
}



ral_status_t ral_set_standby(ral_t *radio,ral_standby_cfg_t standby_cfg)
{
  ral_status_t rVar1;
  ral_standby_cfg_t standby_cfg_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_standby)(radio->context,standby_cfg);
  return rVar1;
}



ral_status_t ral_set_tx(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_tx)(radio->context);
  return rVar1;
}



ral_status_t ral_set_rx(ral_t *radio,uint32_t timeout_in_ms)
{
  ral_status_t rVar1;
  uint32_t timeout_in_ms_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_rx)(radio->context,timeout_in_ms);
  return rVar1;
}



ral_status_t ral_set_pkt_payload(ral_t *radio,uint8_t *buffer,uint16_t size)
{
  ral_status_t rVar1;
  uint16_t size_local;
  uint8_t *buffer_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_pkt_payload)(radio->context,buffer,size);
  return rVar1;
}



ral_status_t ral_clear_irq_status(ral_t *radio,ral_irq_t irq)
{
  ral_status_t rVar1;
  ral_irq_t irq_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).clear_irq_status)(radio->context,irq);
  return rVar1;
}



ral_status_t ral_set_dio_irq_params(ral_t *radio,ral_irq_t irq)
{
  ral_status_t rVar1;
  ral_irq_t irq_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_dio_irq_params)(radio->context,irq);
  return rVar1;
}



void read_nb_frames_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->per->nb_frames);
  return;
}



void write_nb_frames_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->per->nb_frames);
  return;
}



void read_tx_to_tx_delay_in_ms_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->per->tx_to_tx_delay_in_ms);
  return;
}



void write_tx_to_tx_delay_in_ms_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->per->tx_to_tx_delay_in_ms);
  return;
}



void read_rx_timeout_in_ms_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->per->rx_timeout_in_ms);
  return;
}



void write_rx_timeout_in_ms_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->per->rx_timeout_in_ms);
  return;
}



void read_receiver_from_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->per->receiver);
  return;
}



void write_receiver_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->per->receiver);
  return;
}



demo_status_t demo_per_start(demo_t *self)
{
  shield_packet_type_t sVar1;
  apps_common_status_t aVar2;
  ral_status_t rVar3;
  radio_parameters_t *radio_parameters_00;
  shield_t *psVar4;
  demo_status_t dVar5;
  undefined4 uVar6;
  demo_t *self_local;
  int16_t ook_rx_threshold;
  apps_common_interrupts_callbacks_t callbacks;
  ral_status_t status_2;
  ral_status_t status_4;
  ral_status_t status_3;
  ral_status_t status_1;
  ral_status_t status;
  shield_t *shield;
  shield_packet_type_t packet_type;
  radio_parameters_t *radio_parameters;
  demo_per_t *myself;
  int i;
  
  radio_parameters_00 = common_radio_get_parameters();
  memset(&callbacks,0,0x34);
  callbacks.on_tx_done = (code *)0x800b8e9;
  callbacks.on_rx_done = (code *)0x800ba3d;
  callbacks.on_rx_timeout = (code *)0x800bc05;
  callbacks.on_rx_crc_error = (code *)0x800bc19;
  apps_common_update_callbacks(&callbacks);
  sVar1 = (radio_parameters_00->packet_type).val;
  ook_rx_threshold = 0;
  payload_len = (radio_parameters_00->payload_length).val;
  if (0xff < payload_len)
  {
    payload_len = 0xff;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Payload length to large for this demo, taking default maximum %d bytes",
                        0xff);
  }
  psVar4 = shield_manager_get_current_shield();
  apps_common_shield_init(psVar4);
  context = shield_get_ral_instance(psVar4);
  if (context == (ral_t *)0x0)
  {
    psVar4 = shield_manager_get_current_shield();
    apps_common_shield_deinit(psVar4);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "No radio available - Shield has no RAL or no shield set");
    dVar5 = DEMO_STATUS_ERROR;
  }
  else
  {
    if (self[2].demo_name[0xc] == '\0')
    {
      uVar6 = 0x802b77c;
    }
    else
    {
      uVar6 = 0x802b6f0;
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "===== PER example - %s =====",uVar6);
    aVar2 = apps_common_system_init(psVar4);
    if (aVar2 == APPS_COMMON_STATUS_OK)
    {
      if (sVar1 == SHIELD_PKT_TYPE_OOK)
      {
        shield_configure_and_get_inst_rssi(psVar4,&ook_rx_threshold);
      }
      apps_common_radio_init(psVar4);
      print_configuration_on_display(radio_parameters_00,(demo_per_t *)self);
      rVar3 = ral_set_dio_irq_params(context,0xce);
      if (rVar3 != RAL_STATUS_OK)
      {
        if (rVar3 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x802b7f4,0x8033ad8,0xc1,0x802b7e0);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x802b7f4,0x8033ad8,0xc1,(uint)rVar3);
        }
      }
      rVar3 = ral_clear_irq_status(context,0xf7ffe);
      if (rVar3 != RAL_STATUS_OK)
      {
        if (rVar3 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x802b7f4,0x8033ad8,0xc2,0x802b7e0);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x802b7f4,0x8033ad8,0xc2,(uint)rVar3);
        }
      }
      for (i = 1; i < (int)(uint)payload_len; i += 1)
      {
        buffer[i] = (uint8_t)i;
      }
      if (self[2].demo_name[0xc] == '\0')
      {
        buffer[0] = '\0';
        rVar3 = ral_set_pkt_payload(context,buffer,payload_len);
        if (rVar3 != RAL_STATUS_OK)
        {
          if (rVar3 == RAL_STATUS_ERROR)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                                "In %s - %s (line %d): %s",0x802b7f4,0x8033ad8,0xd7,0x802b7e0);
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true
                                ,"In %s - %s (line %d): %d",0x802b7f4,0x8033ad8,0xd7,(uint)rVar3);
          }
        }
        shield_handle_pre_tx(psVar4);
        rVar3 = ral_set_tx(context);
        if (rVar3 != RAL_STATUS_OK)
        {
          if (rVar3 == RAL_STATUS_ERROR)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                                "In %s - %s (line %d): %s",0x802b7f4,0x8033ad8,0xd9,0x802b7e0);
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true
                                ,"In %s - %s (line %d): %d",0x802b7f4,0x8033ad8,0xd9,(uint)rVar3);
          }
        }
      }
      else
      {
        if (sVar1 == SHIELD_PKT_TYPE_OOK)
        {
          shield_set_ook_detection_level(psVar4,ook_rx_threshold);
        }
        shield_handle_pre_rx(psVar4);
        rVar3 = ral_set_rx(context,*(uint32_t *)self[2].demo_name);
        if (rVar3 != RAL_STATUS_OK)
        {
          if (rVar3 == RAL_STATUS_ERROR)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                                "In %s - %s (line %d): %s",0x802b7f4,0x8033ad8,0xd0,0x802b7e0);
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true
                                ,"In %s - %s (line %d): %d",0x802b7f4,0x8033ad8,0xd0,(uint)rVar3);
          }
        }
        memcpy(per_msg,buffer + 1,payload_len - 1);
        smtc_display_clear();
      }
      demo_per_reset();
      *(undefined1 *)&self[1].vtable = 1;
      dVar5 = DEMO_STATUS_OK;
      demo_per = (demo_per_t *)self;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Radio initialization failed",uVar6);
      demo_per_stop(self);
      dVar5 = DEMO_STATUS_ERROR;
    }
  }
  return dVar5;
}



void print_configuration_on_display(radio_parameters_t *radio_parameters,demo_per_t *myself)
{
  shield_packet_type_t sVar1;
  char *pcVar2;
  char *pcVar3;
  undefined4 uVar4;
  demo_per_t *myself_local;
  radio_parameters_t *radio_parameters_local;
  uint16_t pkt_type;
  
  smtc_display_clear();
  sVar1 = (radio_parameters->packet_type).val;
  smtc_display_print_format_string(0,0,"DEMO: %s, running",0x802b83c);
  if ((myself->receiver).val == false)
  {
    uVar4 = 0x802b858;
  }
  else
  {
    uVar4 = 0x802b854;
  }
  smtc_display_print_format_string(0,8,"Role: %s",uVar4);
  smtc_display_print_format_string(0,0x10,"Freq: %lu",(radio_parameters->rf_freq_in_hz).val);
  smtc_display_print_format_string
            (0,0x18,"Payload length: %d",(uint)(radio_parameters->payload_length).val);
  if ((radio_parameters->packet_type).val == SHIELD_PKT_TYPE_OOK)
  {
    pcVar2 = "OOK";
  }
  else
  {
    pcVar2 = ral_pkt_type_to_str((radio_parameters->packet_type).val);
    pcVar2 = pcVar2 + 0xd;
  }
  smtc_display_print_format_string(0,0x20,"Mod : %s",pcVar2);
  switch(sVar1)
  {
  case SHIELD_PKT_TYPE_GFSK:
    smtc_display_print_format_string
              (0,0x28,"Bitrate: %u",(radio_parameters->gfsk_parameters).fsk_bitrate.val);
    break;
  case SHIELD_PKT_TYPE_LORA:
    pcVar2 = ral_lora_sf_to_str((radio_parameters->lora_parameters).lora_sf.val);
    pcVar3 = ral_lora_bw_to_str((radio_parameters->lora_parameters).lora_bw.val);
    smtc_display_print_format_string(0,0x28,"SF: %s, BW: %s",pcVar2 + 9,pcVar3 + 0xc);
    break;
  case SHIELD_PKT_TYPE_FLRC:
    pcVar2 = ral_lora_bw_to_str((radio_parameters->flrc_parameters).flrc_bw.val);
    smtc_display_print_format_string(0,0x28,"BW: %s",pcVar2 + 9);
    break;
  case SHIELD_PKT_TYPE_OOK:
    smtc_display_print_format_string
              (0,0x28,"Bitrate: %u",(radio_parameters->ook_parameters).ook_bitrate.val);
  }
  smtc_display_render();
  return;
}



demo_status_t demo_per_stop(demo_t *self)
{
  ral_status_t rVar1;
  shield_t *shield_00;
  demo_t *self_local;
  ral_status_t status;
  shield_t *shield;
  demo_per_t *myself;
  
  shield_00 = shield_manager_get_current_shield();
  context = shield_get_ral_instance(shield_00);
  rVar1 = ral_set_standby(context,RAL_STANDBY_CFG_RC);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802b7f4,0x8033ae8,0x111,0x802b7e0);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802b7f4,0x8033ae8,0x111,(uint)rVar1);
    }
  }
  shield_handle_post_tx(shield_00);
  shield_handle_post_rx(shield_00);
  smtc_display_print_format_string(0,0,"DEMO: %s, stopped",0x802b83c);
  smtc_display_render();
  apps_common_shield_deinit(shield_00);
  apps_common_reset_callbacks();
  *(undefined1 *)&self[1].vtable = 0;
  return DEMO_STATUS_OK;
}



// WARNING: Unknown calling convention

demo_per_t * demo_per_get_instance(void)
{
  demo_per_t *in_r0;
  demo_per_t demo_per;
  
  demo_per.base.vtable = &demo_per_get_instance::vtable;
  builtin_strncpy(demo_per.base.demo_name,"DEMO_PER",9);
  demo_per.base.demo_name[9] = '\0';
  demo_per.base.demo_name[10] = '\0';
  demo_per.base.demo_name[0xb] = '\0';
  demo_per.base.demo_name[0xc] = '\0';
  demo_per.base.demo_name[0xd] = '\0';
  demo_per.base.demo_name[0xe] = '\0';
  demo_per.base.demo_name[0xf] = '\0';
  demo_per.base.demo_name[0x10] = '\0';
  demo_per.base.demo_name[0x11] = '\0';
  demo_per.base.demo_name[0x12] = '\0';
  demo_per.base.demo_name[0x13] = '\0';
  demo_per.base.demo_name[0x14] = '\0';
  demo_per.base.demo_name[0x15] = '\0';
  demo_per.base.demo_name[0x16] = '\0';
  demo_per.base.demo_name[0x17] = '\0';
  demo_per.base.demo_name[0x18] = '\0';
  demo_per.base.demo_id = '\x01';
  demo_per.base._30_2_ = 0;
  demo_per.running = false;
  build_config_item_uint16_t(&demo_per.nb_frames,0x14);
  build_config_item_uint16_t(&demo_per.tx_to_tx_delay_in_ms,200);
  build_config_item_uint32_t(&demo_per.rx_timeout_in_ms,1000);
  build_config_item__Bool(&demo_per.receiver,true);
  memcpy(in_r0,&demo_per,0x54);
  return in_r0;
}



void demo_per_set_as_transmitter(demo_t *self)
{
  demo_t *self_local;
  demo_per_t *myself;
  
  self[2].demo_name[0xc] = '\0';
  return;
}



demo_status_t demo_per_runtime(demo_t *self)
{
  demo_status_t dVar1;
  demo_t *self_local;
  demo_per_t *myself;
  
  if (*(char *)&self[1].vtable == '\0')
  {
    dVar1 = DEMO_STATUS_OK;
  }
  else if ((per_index < *(ushort *)(self[1].demo_name + 8)) ||
          (*(short *)(self[1].demo_name + 8) == 0))
  {
    apps_common_irq_process(context,0xce);
    dVar1 = DEMO_STATUS_OK;
  }
  else
  {
    *(undefined1 *)&self[1].vtable = 0;
    demo_per_show_PER(true);
    dVar1 = DEMO_STATUS_FINISHED;
  }
  return dVar1;
}



void demo_per_show_PER(_Bool final)
{
  byte bVar1;
  radio_parameters_t *prVar2;
  char *pcVar3;
  uint uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  uint in_fpscr;
  float fVar7;
  float fVar8;
  uint uVar9;
  _Bool final_local;
  uint32_t integer_per;
  uint8_t decimal_part;
  uint8_t integer_part;
  float per;
  uint16_t nb_frames;
  radio_parameters_t *radio_params;
  
  prVar2 = common_radio_get_parameters();
  fVar8 = (float)VectorUnsignedToFloat((uint)nb_ok,(byte)(in_fpscr >> 0x15) & 3);
  fVar7 = (float)VectorUnsignedToFloat
                           ((uint)(ushort)(nb_ok + nb_rx_timeout +
                                                   nb_rx_crc_error + nb_fsk_len_error),
                            (byte)(in_fpscr >> 0x15) & 3);
  uVar9 = VectorFloatToUnsigned((100.0 - (fVar8 * 100.0) / fVar7) * 100.0,3);
  uVar4 = uVar9 / 100;
  bVar1 = (char)uVar9 + (char)uVar4 * -100;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "PER = %u.%u%%\n",uVar4 & 0xff,(uint)bVar1);
  if (final)
  {
    uVar5 = 0x802b8e0;
  }
  else
  {
    uVar5 = 0x802b8e8;
  }
  smtc_display_print_format_string(0,0,"DEMO: %s, %s",0x802b83c,uVar5);
  if ((demo_per->receiver).val == false)
  {
    uVar6 = 0x802b858;
  }
  else
  {
    uVar6 = 0x802b854;
  }
  smtc_display_print_format_string(0,8,"Role: %s",uVar6,uVar5);
  if ((prVar2->packet_type).val == SHIELD_PKT_TYPE_OOK)
  {
    pcVar3 = "OOK";
  }
  else
  {
    pcVar3 = ral_pkt_type_to_str((prVar2->packet_type).val);
    pcVar3 = pcVar3 + 0xd;
  }
  smtc_display_print_format_string(0,0x10,"Mod : %s",pcVar3,uVar5);
  smtc_display_print_format_string(0,0x18,"Valid RX: %u ",(uint)nb_ok);
  smtc_display_print_format_string(0,0x20,"Timeout RX: %u ",(uint)nb_rx_timeout);
  smtc_display_print_format_string(0,0x28,"Crc err: %u ",(uint)nb_rx_crc_error);
  smtc_display_print_format_string(0,0x30,"PER = %u.%u%%",uVar4 & 0xff,(uint)bVar1);
  if ((prVar2->packet_type).val == SHIELD_PKT_TYPE_GFSK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "FSK Length Error reception amount: %d",(uint)nb_fsk_len_error);
    smtc_display_print_format_string(0,0x30,"FSK len err: %u ",(uint)nb_fsk_len_error);
  }
  if (final)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Final PER index: %d",(uint)per_index);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Valid reception amount: %d",(uint)nb_ok);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Timeout reception amount: %d",(uint)nb_rx_timeout);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "CRC Error reception amount: %d",(uint)nb_rx_crc_error);
  }
  smtc_display_render();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_per_on_tx_done(void)
{
  ral_status_t rVar1;
  shield_t *shield_00;
  byte bVar2;
  ral_status_t status_1;
  ral_status_t status;
  uint8_t counter;
  shield_t *shield;
  
  shield_00 = shield_manager_get_current_shield();
  shield_handle_post_tx(shield_00);
  smtc_hal_mcu_wait_ms((uint)(demo_per->tx_to_tx_delay_in_ms).val);
  bVar2 = buffer[0] + 1;
  buffer[0] = bVar2;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "Counter: %u",(uint)bVar2);
  if (bVar2 == 0)
  {
    smtc_display_draw_filled_rectangle(0,0x38,0x7f,0x3f,0);
  }
  smtc_display_print_format_string(0,0x38,"Counter: %u",(uint)bVar2);
  smtc_display_render();
  rVar1 = ral_set_pkt_payload(context,buffer,payload_len);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802b7f4,0x8033b28,399,0x802b7e0);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802b7f4,0x8033b28,399,(uint)rVar1);
    }
  }
  shield_handle_pre_tx(shield_00);
  rVar1 = ral_set_tx(context);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802b7f4,0x8033b28,0x192,0x802b7e0);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802b7f4,0x8033b28,0x192,(uint)rVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_per_on_rx_done(void)
{
  int iVar1;
  uint16_t size;
  ral_status_t status;
  uint8_t counter;
  uint8_t rolling_counter_gap;
  shield_t *shield;
  
  shield = shield_manager_get_current_shield();
  shield_handle_post_rx(shield);
  apps_common_receive(context,buffer,(uint8_t)payload_len,&size);
  iVar1 = memcmp(buffer + 1,per_msg,payload_len - 1);
  if (iVar1 == 0)
  {
    if (first_pkt_received_flag == false)
    {
      smtc_display_clear();
      first_pkt_received_flag = true;
    }
    else
    {
      rolling_counter_gap = buffer[0] - rolling_counter;
      nb_ok += 1;
      per_index += rolling_counter_gap;
      if (1 < rolling_counter_gap)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "%d packet(s) missed",rolling_counter_gap - 1);
      }
    }
    counter = buffer[0];
    rolling_counter = buffer[0];
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Counter value: %u, PER index: %d",(uint)buffer[0],(uint)per_index);
    if ((counter == '\0') || (per_index == 0))
    {
      smtc_display_draw_filled_rectangle(0,0x38,0x7f,0x3f,0);
    }
    smtc_display_print_format_string(0,0x38,"CNT: %u, IDX: %u",(uint)counter,(uint)per_index);
    smtc_display_render();
  }
  demo_per_show_PER(false);
  if ((per_index < (demo_per->nb_frames).val) || ((demo_per->nb_frames).val == 0))
  {
    shield_handle_pre_rx(shield);
    status = ral_set_rx(context,(demo_per->rx_timeout_in_ms).val);
    if (status != RAL_STATUS_OK)
    {
      if (status == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x802b7f4,0x8033b3c,0x1c4,0x802b7e0);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x802b7f4,0x8033b3c,0x1c4,(uint)status);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_per_on_rx_timeout(void)
{
  per_reception_failure_handling(&nb_rx_timeout);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_per_on_rx_crc_error(void)
{
  per_reception_failure_handling(&nb_rx_crc_error);
  return;
}



void per_reception_failure_handling(uint16_t *failure_counter)
{
  ral_status_t rVar1;
  shield_t *shield_00;
  uint16_t *failure_counter_local;
  ral_status_t status;
  shield_t *shield;
  
  shield_00 = shield_manager_get_current_shield();
  shield_handle_post_rx(shield_00);
  if (first_pkt_received_flag != false)
  {
    *failure_counter = *failure_counter + 1;
  }
  demo_per_show_PER(false);
  shield_handle_pre_rx(shield_00);
  rVar1 = ral_set_rx(context,(demo_per->rx_timeout_in_ms).val);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802b7f4,0x8033b50,0x1df,0x802b7e0);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802b7f4,0x8033b50,0x1df,(uint)rVar1);
    }
  }
  return;
}



void demo_per_register_configurations_to_manager(demo_t *self,configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  demo_t *self_local;
  demo_per_t *myself;
  
  append_storage_with_protobuf
            (manager,(configuration_item_t *)self[1].demo_name,(read_from_protobuf_f)0x800aea7,
             (write_to_protobuf_f)0x800aec9);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[1].demo_name + 0xc),
             (read_from_protobuf_f)0x800aeeb,(write_to_protobuf_f)0x800af0d);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[1].demo_name + 0x18),
             (read_from_protobuf_f)0x800af2f,(write_to_protobuf_f)0x800af51);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[2].demo_name + 4),(read_from_protobuf_f)0x800af73
             ,(write_to_protobuf_f)0x800af95);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_per_reset(void)
{
  nb_ok = 0;
  nb_rx_timeout = 0;
  nb_rx_crc_error = 0;
  nb_fsk_len_error = 0;
  rolling_counter = '\0';
  per_index = 0;
  first_pkt_received_flag = false;
  return;
}



ral_status_t ral_set_tx(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_tx)(radio->context);
  return rVar1;
}



ral_status_t ral_set_rx(ral_t *radio,uint32_t timeout_in_ms)
{
  ral_status_t rVar1;
  uint32_t timeout_in_ms_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_rx)(radio->context,timeout_in_ms);
  return rVar1;
}



ral_status_t ral_set_pkt_payload(ral_t *radio,uint8_t *buffer,uint16_t size)
{
  ral_status_t rVar1;
  uint16_t size_local;
  uint8_t *buffer_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_pkt_payload)(radio->context,buffer,size);
  return rVar1;
}



ral_status_t ral_clear_irq_status(ral_t *radio,ral_irq_t irq)
{
  ral_status_t rVar1;
  ral_irq_t irq_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).clear_irq_status)(radio->context,irq);
  return rVar1;
}



ral_status_t ral_set_dio_irq_params(ral_t *radio,ral_irq_t irq)
{
  ral_status_t rVar1;
  ral_irq_t irq_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_dio_irq_params)(radio->context,irq);
  return rVar1;
}



void read_prefix_size_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->ping_pong->prefix_size);
  return;
}



void write_prefix_size_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->ping_pong->prefix_size);
  return;
}



void read_sync_packet_threshold_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->ping_pong->sync_packet_threshold);
  return;
}



void write_sync_packet_threshold_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->ping_pong->sync_packet_threshold);
  return;
}



void read_delay_before_tx_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->ping_pong->delay_before_tx);
  return;
}



void write_delay_before_tx_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->ping_pong->delay_before_tx);
  return;
}



void read_delay_ping_pong_pace_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->ping_pong->delay_ping_pong_pace);
  return;
}



void write_delay_ping_pong_pace_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->ping_pong->delay_ping_pong_pace);
  return;
}



void read_rx_timeout_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->ping_pong->rx_timeout);
  return;
}



void write_rx_timeout_to_protobuf(configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->ping_pong->rx_timeout);
  return;
}



// WARNING: Unknown calling convention

demo_ping_pong_t * demo_ping_pong_get_instance(void)
{
  demo_ping_pong_t *in_r0;
  demo_ping_pong_t demo_ping_pong;
  
  demo_ping_pong.base.vtable = &demo_ping_pong_get_instance::vtable;
  builtin_strncpy(demo_ping_pong.base.demo_name,"DEMO_PING_PONG",0xf);
  demo_ping_pong.base.demo_name[0xf] = '\0';
  demo_ping_pong.base.demo_name[0x10] = '\0';
  demo_ping_pong.base.demo_name[0x11] = '\0';
  demo_ping_pong.base.demo_name[0x12] = '\0';
  demo_ping_pong.base.demo_name[0x13] = '\0';
  demo_ping_pong.base.demo_name[0x14] = '\0';
  demo_ping_pong.base.demo_name[0x15] = '\0';
  demo_ping_pong.base.demo_name[0x16] = '\0';
  demo_ping_pong.base.demo_name[0x17] = '\0';
  demo_ping_pong.base.demo_name[0x18] = '\0';
  demo_ping_pong.base.demo_id = '\x04';
  demo_ping_pong.base._30_2_ = 0;
  demo_ping_pong.running = false;
  build_config_item_uint32_t(&demo_ping_pong.prefix_size,4);
  build_config_item_uint32_t(&demo_ping_pong.sync_packet_threshold,0x40);
  build_config_item_uint32_t(&demo_ping_pong.delay_before_tx,0x14);
  build_config_item_uint32_t(&demo_ping_pong.delay_ping_pong_pace,200);
  build_config_item_uint32_t(&demo_ping_pong.rx_timeout,600);
  memcpy(in_r0,&demo_ping_pong,0x60);
  return in_r0;
}



demo_status_t demo_ping_pong_start(demo_t *self)
{
  shield_packet_type_t sVar1;
  apps_common_status_t aVar2;
  ral_status_t rVar3;
  radio_parameters_t *prVar4;
  shield_t *psVar5;
  char *pcVar6;
  demo_status_t dVar7;
  demo_t *self_local;
  apps_common_interrupts_callbacks_t callbacks;
  ral_status_t status_3;
  ral_status_t status_2;
  ral_status_t status_1;
  ral_status_t status;
  uint16_t pkt_type;
  shield_t *shield;
  uint16_t packet_type;
  radio_parameters_t *radio_parameters;
  demo_ping_pong_t *myself;
  int i;
  
  prVar4 = common_radio_get_parameters();
  sVar1 = (prVar4->packet_type).val;
  payload_len = (prVar4->payload_length).val;
  memset(&callbacks,0,0x34);
  callbacks.on_tx_done = (code *)0x800c559;
  callbacks.on_rx_done = (code *)0x800c6b9;
  callbacks.on_rx_timeout = (code *)0x800c8c5;
  callbacks.on_rx_crc_error = (code *)0x800c8f9;
  apps_common_update_callbacks(&callbacks);
  if (0xff < payload_len)
  {
    payload_len = 0xff;
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Payload length to large for this demo, taking default maximum %d bytes",
                        0xff);
  }
  psVar5 = shield_manager_get_current_shield();
  apps_common_shield_init(psVar5);
  if (sVar1 == SHIELD_PKT_TYPE_OOK)
  {
    shield_configure_and_get_inst_rssi(psVar5,&ook_rx_threshold);
  }
  context = shield_get_ral_instance(psVar5);
  if (context == (ral_t *)0x0)
  {
    psVar5 = shield_manager_get_current_shield();
    apps_common_shield_deinit(psVar5);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "No radio available - Shield has no RAL or no shield set");
    dVar7 = DEMO_STATUS_ERROR;
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "===== Ping Pong Demo =====");
    aVar2 = apps_common_system_init(psVar5);
    if (aVar2 == APPS_COMMON_STATUS_OK)
    {
      apps_common_radio_init(psVar5);
      smtc_display_clear();
      smtc_display_print_format_string(0,0,"DEMO: %s, running",0x802bafc);
      smtc_display_print_format_string(0,8,"Freq: %lu",(prVar4->rf_freq_in_hz).val);
      pcVar6 = display_printer_get_pkt_type_str((ushort)(prVar4->packet_type).val);
      smtc_display_print_format_string(0,0x10,"Packet type: %s",pcVar6);
      smtc_display_print_format_string
                (0,0x18,"Payload length: %d",(uint)(prVar4->payload_length).val);
      switch((prVar4->packet_type).val)
      {
      case SHIELD_PKT_TYPE_GFSK:
        smtc_display_print_format_string
                  (0,0x20,"BR: %u bps",(prVar4->gfsk_parameters).fsk_bitrate.val);
        break;
      case SHIELD_PKT_TYPE_LORA:
        smtc_display_print_format_string
                  (0,0x20,"SF: %u, BW: %u",(uint)(prVar4->lora_parameters).lora_sf.val,
                   (uint)(prVar4->lora_parameters).lora_bw.val);
        break;
      case SHIELD_PKT_TYPE_FLRC:
        smtc_display_print_format_string
                  (0,0x20,"BW: %u",(uint)(prVar4->flrc_parameters).flrc_bw.val);
        break;
      case SHIELD_PKT_TYPE_OOK:
        smtc_display_print_format_string
                  (0,0x28,"Bitrate: %u",(prVar4->ook_parameters).ook_bitrate.val);
      }
      smtc_display_render();
      rVar3 = ral_set_dio_irq_params(context,0xce);
      if (rVar3 != RAL_STATUS_OK)
      {
        if (rVar3 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x802bba4,0x8033ba8,0xf7,0x802bb90);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x802bba4,0x8033ba8,0xf7,(uint)rVar3);
        }
      }
      rVar3 = ral_clear_irq_status(context,0xf7ffe);
      if (rVar3 != RAL_STATUS_OK)
      {
        if (rVar3 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x802bba4,0x8033ba8,0xf8,0x802bb90);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x802bba4,0x8033ba8,0xf8,(uint)rVar3);
        }
      }
      srand(10);
      builtin_memcpy(buffer_tx,"PING",5);
      buffer_tx[5] = iteration;
      for (i = 6; i < (int)(uint)payload_len; i += 1)
      {
        buffer_tx[i] = (uint8_t)i;
      }
      rVar3 = ral_set_pkt_payload(context,buffer_tx,payload_len);
      if (rVar3 != RAL_STATUS_OK)
      {
        if (rVar3 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x802bba4,0x8033ba8,0x104,0x802bb90);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x802bba4,0x8033ba8,0x104,(uint)rVar3);
        }
      }
      shield_handle_pre_tx(psVar5);
      rVar3 = ral_set_tx(context);
      if (rVar3 != RAL_STATUS_OK)
      {
        if (rVar3 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x802bba4,0x8033ba8,0x106,0x802bb90);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x802bba4,0x8033ba8,0x106,(uint)rVar3);
        }
      }
      *(undefined1 *)&self[1].vtable = 1;
      dVar7 = DEMO_STATUS_OK;
      demo_ping_pong = (demo_ping_pong_t *)self;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Radio initialization failed");
      demo_ping_pong_stop(self);
      dVar7 = DEMO_STATUS_ERROR;
    }
  }
  return dVar7;
}



demo_status_t demo_ping_pong_runtime(demo_t *self)
{
  demo_t *self_local;
  demo_ping_pong_t *myself;
  
  if (*(char *)&self[1].vtable != '\0')
  {
    apps_common_irq_process(context,0xce);
  }
  return DEMO_STATUS_OK;
}



void demo_ping_pong_register_configurations_to_manager
               (demo_t *self,configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  demo_t *self_local;
  demo_ping_pong_t *myself;
  
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[1].demo_name + 0x18),
             (read_from_protobuf_f)0x800bee7,(write_to_protobuf_f)0x800bf09);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[2].demo_name + 4),(read_from_protobuf_f)0x800bf2b
             ,(write_to_protobuf_f)0x800bf4d);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[1].demo_name + 0xc),
             (read_from_protobuf_f)0x800bea3,(write_to_protobuf_f)0x800bec5);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)(self[2].demo_name + 0x10),
             (read_from_protobuf_f)0x800bf6f,(write_to_protobuf_f)0x800bf91);
  append_storage_with_protobuf
            (manager,(configuration_item_t *)self[1].demo_name,(read_from_protobuf_f)0x800be5f,
             (write_to_protobuf_f)0x800be81);
  return;
}



demo_status_t demo_ping_pong_stop(demo_t *self)
{
  bool bVar1;
  demo_t *self_local;
  demo_ping_pong_t *myself;
  
  bVar1 = *(char *)&self[1].vtable != '\0';
  if (bVar1)
  {
    smtc_display_print_format_string(0,0,"DEMO: %s, stopped",0x802bafc);
    smtc_display_render();
    apps_common_reset_callbacks();
    *(undefined1 *)&self[1].vtable = 0;
  }
  return bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_ping_pong_on_tx_done(void)
{
  shield_packet_type_t sVar1;
  ral_status_t rVar2;
  shield_t *shield_00;
  radio_parameters_t *prVar3;
  shield_t *shield_01;
  uint32_t uVar4;
  int iVar5;
  uint32_t uVar6;
  ral_status_t status;
  uint16_t packet_type;
  radio_parameters_t *radio_parameters;
  shield_t *shield;
  uint32_t rx_timeout;
  
  shield_00 = shield_manager_get_current_shield();
  prVar3 = common_radio_get_parameters();
  sVar1 = (prVar3->packet_type).val;
  shield_handle_post_tx(shield_00);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "Sent message %s, iteration %d\n",0x20002e0c,(uint)iteration);
  smtc_display_draw_filled_rectangle(0,0x38,0x7f,0x3f,0);
  smtc_display_print_format_string(0,0x38,"TX iteration: %u",(uint)iteration);
  smtc_display_render();
  smtc_hal_mcu_wait_ms((demo_ping_pong->delay_ping_pong_pace).val);
  shield_handle_pre_rx(shield_00);
  shield_01 = shield_manager_get_current_shield();
  uVar4 = get_time_on_air_in_ms(shield_01);
  uVar6 = (demo_ping_pong->rx_timeout).val;
  iVar5 = rand();
  uVar4 = iVar5 % 500 + uVar4 + uVar6;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__TRACE,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "RX timeout set to %lu ms",uVar4);
  if (sVar1 == SHIELD_PKT_TYPE_OOK)
  {
    shield_configure_and_get_inst_rssi(shield_00,&ook_rx_threshold);
  }
  rVar2 = ral_set_rx(context,uVar4);
  if (rVar2 != RAL_STATUS_OK)
  {
    if (rVar2 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802bba4,0x8033bc0,0x151,0x802bb90);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802bba4,0x8033bc0,0x151,(uint)rVar2);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_ping_pong_on_rx_done(void)
{
  ral_status_t rVar1;
  shield_t *shield_00;
  radio_parameters_t *prVar2;
  int iVar3;
  uint16_t size;
  uint8_t buffer_rx [7];
  ral_status_t status_1;
  ral_status_t status;
  radio_parameters_t *radio_parameters;
  shield_t *shield;
  
  packets_to_sync = 0;
  shield_00 = shield_manager_get_current_shield();
  prVar2 = common_radio_get_parameters();
  shield_handle_post_rx(shield_00);
  payload_len = (prVar2->payload_length).val;
  apps_common_receive(context,buffer_rx,(uint8_t)payload_len,&size);
  iteration = buffer_rx[5] + 1;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "Received message %s, iteration %d\n",buffer_rx,(uint)iteration);
  smtc_display_draw_filled_rectangle(0,0x38,0x7f,0x3f,0);
  smtc_display_print_format_string(0,0x38,"RX iteration: %u",(uint)iteration);
  smtc_display_render();
  if (is_master == false)
  {
    iVar3 = memcmp(buffer_rx,"PING",4);
    if (iVar3 != 0)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Unexpected message\n");
      is_master = true;
      builtin_memcpy(buffer_tx,"PING",4);
    }
  }
  else
  {
    iVar3 = memcmp(buffer_rx,"PING",4);
    if (iVar3 == 0)
    {
      is_master = false;
      builtin_memcpy(buffer_tx,"PONG",4);
    }
    else
    {
      iVar3 = memcmp(buffer_rx,"PONG",4);
      if (iVar3 != 0)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "Unexpected message\n");
      }
    }
  }
  smtc_hal_mcu_wait_ms(0xdc);
  buffer_tx[5] = iteration;
  rVar1 = ral_set_pkt_payload(context,buffer_tx,payload_len);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802bba4,0x8033bdc,0x186,0x802bb90);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802bba4,0x8033bdc,0x186,(uint)rVar1);
    }
  }
  shield_handle_pre_tx(shield_00);
  rVar1 = ral_set_tx(context);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802bba4,0x8033bdc,0x189,0x802bb90);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802bba4,0x8033bdc,0x189,(uint)rVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_ping_pong_on_rx_timeout(void)
{
  packets_to_sync += 1;
  if (0x40 < packets_to_sync)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "It looks like synchronisation is still not done, consider resetting one of the board\n"
                       );
  }
  ping_pong_reception_failure_handling();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void demo_ping_pong_on_rx_crc_error(void)
{
  ping_pong_reception_failure_handling();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ping_pong_reception_failure_handling(void)
{
  ral_status_t rVar1;
  shield_t *psVar2;
  ral_status_t status_1;
  ral_status_t status;
  
  psVar2 = shield_manager_get_current_shield();
  shield_handle_post_rx(psVar2);
  is_master = true;
  iteration = '\0';
  builtin_memcpy(buffer_tx,"PING",4);
  buffer_tx[5] = '\0';
  rVar1 = ral_set_pkt_payload(context,buffer_tx,payload_len);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802bba4,0x8033bf8,0x1a4,0x802bb90);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802bba4,0x8033bf8,0x1a4,(uint)rVar1);
    }
  }
  psVar2 = shield_manager_get_current_shield();
  shield_handle_pre_tx(psVar2);
  rVar1 = ral_set_tx(context);
  if (rVar1 != RAL_STATUS_OK)
  {
    if (rVar1 == RAL_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x802bba4,0x8033bf8,0x1a7,0x802bb90);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x802bba4,0x8033bf8,0x1a7,(uint)rVar1);
    }
  }
  return;
}



ral_status_t ral_wakeup(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).wakeup)(radio->context);
  return rVar1;
}



ral_status_t ral_set_standby(ral_t *radio,ral_standby_cfg_t standby_cfg)
{
  ral_status_t rVar1;
  ral_standby_cfg_t standby_cfg_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_standby)(radio->context,standby_cfg);
  return rVar1;
}



ral_status_t ral_set_fs(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_fs)(radio->context);
  return rVar1;
}



ral_status_t ral_set_rx(ral_t *radio,uint32_t timeout_in_ms)
{
  ral_status_t rVar1;
  uint32_t timeout_in_ms_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_rx)(radio->context,timeout_in_ms);
  return rVar1;
}



ral_status_t ral_set_tx_infinite_preamble(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_tx_infinite_preamble)(radio->context);
  return rVar1;
}



void config_static_mode_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_static_mode_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_static_mode_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_static_mode_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_static_mode_t *
build_config_item_static_mode_t
          (configuration_item_static_mode_t *__return_storage_ptr__,static_mode_t default_value)
{
  static_mode_t default_value_local;
  configuration_item_static_mode_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_static_mode_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



demo_status_t demo_static_mode_start(demo_t *self)
{
  shield_t *psVar1;
  ral_t *prVar2;
  demo_status_t dVar3;
  demo_t *self_local;
  ral_t *radio;
  shield_t *shield;
  demo_static_mode_t *myself;
  
  *(undefined1 *)&self[1].vtable = 1;
  self[1].demo_name[0xc] = '\0';
  psVar1 = shield_manager_get_current_shield();
  prVar2 = shield_get_ral_instance(psVar1);
  if (prVar2 == (ral_t *)0x0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "No radio available - Shield has no RAL or no shield set");
    dVar3 = DEMO_STATUS_ERROR;
  }
  else
  {
    smtc_display_clear();
    smtc_display_print_format_string(0,0,"DEMO: %s, running",0x802bd38);
    smtc_display_render();
    psVar1 = shield_manager_get_current_shield();
    apps_common_shield_init(psVar1);
    dVar3 = DEMO_STATUS_OK;
  }
  return dVar3;
}



demo_status_t demo_static_mode_stop(demo_t *self)
{
  shield_t *psVar1;
  demo_t *self_local;
  demo_static_mode_t *myself;
  
  *(undefined1 *)&self[1].vtable = 0;
  demo_static_mode_handle_configuration_mode((demo_static_mode_t *)self,NOT_CONFIGURED);
  psVar1 = shield_manager_get_current_shield();
  shield_handle_post_rx(psVar1);
  psVar1 = shield_manager_get_current_shield();
  shield_handle_post_tx(psVar1);
  psVar1 = shield_manager_get_current_shield();
  apps_common_shield_deinit(psVar1);
  smtc_display_print_format_string(0,0,"DEMO: %s, stopped",0x802bd38);
  smtc_display_render();
  return DEMO_STATUS_OK;
}



void read_configuration_mode_from_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  read_from(item,&protobuf->appli_configuration->static_mode->static_mode);
  return;
}



void write_configuration_mode_to_protobuf
               (configuration_item_t *item,DeviceMessage__Configuration *protobuf)
{
  DeviceMessage__Configuration *protobuf_local;
  configuration_item_t *item_local;
  
  write_to(item,&protobuf->appli_configuration->static_mode->static_mode);
  return;
}



void demo_static_mode_register_configurations_to_manager
               (demo_t *self,configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  demo_t *self_local;
  demo_static_mode_t *myself;
  
  append_storage_with_protobuf
            (manager,(configuration_item_t *)self[1].demo_name,(read_from_protobuf_f)0x800cc25,
             (write_to_protobuf_f)0x800cc47);
  return;
}



// WARNING: Unknown calling convention

demo_static_mode_t * demo_static_mode_get_instance(void)
{
  demo_static_mode_t *in_r0;
  demo_static_mode_t demo_static_mode;
  
  demo_static_mode.base.vtable = &demo_static_mode_get_instance::vtable;
  builtin_strncpy(demo_static_mode.base.demo_name,"DEMO_STATIC_MODE",0x11);
  demo_static_mode.base.demo_name[0x11] = '\0';
  demo_static_mode.base.demo_name[0x12] = '\0';
  demo_static_mode.base.demo_name[0x13] = '\0';
  demo_static_mode.base.demo_name[0x14] = '\0';
  demo_static_mode.base.demo_name[0x15] = '\0';
  demo_static_mode.base.demo_name[0x16] = '\0';
  demo_static_mode.base.demo_name[0x17] = '\0';
  demo_static_mode.base.demo_name[0x18] = '\0';
  demo_static_mode.base.demo_id = '\x03';
  demo_static_mode.base._30_2_ = 0;
  demo_static_mode._32_4_ &= 0xffffff00;
  build_config_item_static_mode_t(&demo_static_mode.configuration_mode,NOT_CONFIGURED);
  demo_static_mode._48_4_ &= 0xffffff00;
  (in_r0->base).vtable = demo_static_mode.base.vtable;
  *(undefined4 *)(in_r0->base).demo_name = demo_static_mode.base.demo_name._0_4_;
  *(undefined4 *)((in_r0->base).demo_name + 4) = demo_static_mode.base.demo_name._4_4_;
  *(undefined4 *)((in_r0->base).demo_name + 8) = demo_static_mode.base.demo_name._8_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0xc) = demo_static_mode.base.demo_name._12_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0x10) = demo_static_mode.base.demo_name._16_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0x14) = demo_static_mode.base.demo_name._20_4_;
  *(undefined4 *)((in_r0->base).demo_name + 0x18) = demo_static_mode.base._28_4_;
  in_r0->running = demo_static_mode.running;
  *(undefined3 *)&in_r0->field_0x21 = demo_static_mode._33_3_;
  (in_r0->configuration_mode).base.vtable = demo_static_mode.configuration_mode.base.vtable;
  (in_r0->configuration_mode).base.size = demo_static_mode.configuration_mode.base.size;
  (in_r0->configuration_mode).val = demo_static_mode.configuration_mode.val;
  *(undefined3 *)&(in_r0->configuration_mode).field_0x9 = demo_static_mode.configuration_mode._9_3_;
  in_r0->radio_mode = demo_static_mode.radio_mode;
  *(undefined3 *)&in_r0->field_0x31 = demo_static_mode._49_3_;
  return in_r0;
}



demo_status_t demo_static_mode_runtime(demo_t *self)
{
  demo_t *self_local;
  demo_static_mode_t *myself;
  
  if (*(char *)&self[1].vtable != '\0')
  {
    demo_static_mode_handle_configuration_mode((demo_static_mode_t *)self,self[1].demo_name[8]);
  }
  return DEMO_STATUS_OK;
}



void demo_static_mode_handle_configuration_mode(demo_static_mode_t *self,static_mode_t target_mode)
{
  char *pcVar1;
  char *pcVar2;
  shield_t *psVar3;
  undefined4 uVar4;
  static_mode_t target_mode_local;
  demo_static_mode_t *self_local;
  
  if (target_mode != self->radio_mode)
  {
    if (self->radio_mode == RX)
    {
      uVar4 = 0x802bd68;
    }
    else
    {
      uVar4 = 0x802bd6c;
    }
    smtc_display_print_format_string(0,8,"Radio mode: %s",uVar4);
    pcVar1 = demo_static_mode_static_mode_to_str(target_mode,true);
    smtc_display_print_format_string(0,0x10,"Config: %s",pcVar1);
    smtc_display_render();
    pcVar1 = demo_static_mode_static_mode_to_str(target_mode,false);
    pcVar2 = demo_static_mode_static_mode_to_str(self->radio_mode,false);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Switching radio to static configuration: %s (from %s)",pcVar1,pcVar2);
    if (self->radio_mode == RX)
    {
      psVar3 = shield_manager_get_current_shield();
      shield_handle_post_rx(psVar3);
    }
    if (self->radio_mode == TX)
    {
      psVar3 = shield_manager_get_current_shield();
      shield_handle_post_tx(psVar3);
    }
    psVar3 = shield_manager_get_current_shield();
    demo_static_mode_configure_radio(psVar3,target_mode);
    self->radio_mode = target_mode;
  }
  return;
}



char * demo_static_mode_static_mode_to_str(static_mode_t static_mode,_Bool to_small_display)
{
  char *pcVar1;
  _Bool to_small_display_local;
  static_mode_t static_mode_local;
  
  switch(static_mode)
  {
  case NOT_CONFIGURED:
    if (to_small_display)
    {
      pcVar1 = "NOT_CFG";
    }
    else
    {
      pcVar1 = "NOT_CONFIGURED";
    }
    break;
  case SLEEP_WITH_RETENTION:
    if (to_small_display)
    {
      pcVar1 = "SLEEP_RET";
    }
    else
    {
      pcVar1 = "SLEEP_WITH_RETENTION";
    }
    break;
  case SLEEP_WITHOUT_RETENTION:
    if (to_small_display)
    {
      pcVar1 = "SLEEP_NO_RET";
    }
    else
    {
      pcVar1 = "SLEEP_WITHOUT_RETENTION";
    }
    break;
  case SLEEP_WITH_RETENTION_WITH_RTC:
    if (to_small_display)
    {
      pcVar1 = "SLEEP_RET_RTC";
    }
    else
    {
      pcVar1 = "SLEEP_WITH_RETENTION_WITH_RTC";
    }
    break;
  case SLEEP_WITHOUT_RETENTION_WITH_RTC:
    if (to_small_display)
    {
      pcVar1 = "NO_RET_RTC";
    }
    else
    {
      pcVar1 = "SLEEP_WITHOUT_RETENTION_WITH_RTC";
    }
    break;
  case STANDBY_RC:
    pcVar1 = "STANDBY_RC";
    break;
  case STANDBY_XOSC:
    pcVar1 = "STANDBY_XOSC";
    break;
  case RX:
    pcVar1 = "RX";
    break;
  case TX:
    pcVar1 = "TX";
    break;
  case FS:
    pcVar1 = "FS";
    break;
  default:
    if (to_small_display)
    {
      pcVar1 = "unknown";
    }
    else
    {
      pcVar1 = "unknown static mode";
    }
  }
  return pcVar1;
}



void demo_static_mode_configure_radio(shield_t *shield,static_mode_t mode)
{
  apps_common_status_t aVar1;
  ral_t *radio_00;
  static_mode_t mode_local;
  shield_t *shield_local;
  ral_t *radio;
  
  radio_00 = shield_get_ral_instance(shield);
  ral_wakeup(radio_00);
  if (radio_00 == (ral_t *)0x0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "No radio available - Shield has no RAL or no shield set");
  }
  else
  {
    switch(mode)
    {
    case NOT_CONFIGURED:
    case STANDBY_RC:
      ral_set_standby(radio_00,RAL_STANDBY_CFG_RC);
      break;
    case SLEEP_WITH_RETENTION:
      shield_set_sleep(shield,true,false);
      break;
    case SLEEP_WITHOUT_RETENTION:
      shield_set_sleep(shield,false,false);
      break;
    case SLEEP_WITH_RETENTION_WITH_RTC:
      shield_set_sleep(shield,true,true);
      break;
    case SLEEP_WITHOUT_RETENTION_WITH_RTC:
      shield_set_sleep(shield,false,true);
      break;
    case STANDBY_XOSC:
      ral_set_standby(radio_00,RAL_STANDBY_CFG_XOSC);
      break;
    case RX:
      aVar1 = apps_common_system_init(shield);
      if (aVar1 == APPS_COMMON_STATUS_OK)
      {
        apps_common_radio_init(shield);
        shield_handle_pre_rx(shield);
        ral_set_rx(radio_00,0xffffffff);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "Radio initialization failed");
      }
      break;
    case TX:
      aVar1 = apps_common_system_init(shield);
      if (aVar1 == APPS_COMMON_STATUS_OK)
      {
        apps_common_radio_init(shield);
        shield_handle_pre_tx(shield);
        ral_set_tx_infinite_preamble(radio_00);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "Radio initialization failed");
      }
      break;
    case FS:
      ral_set_fs(radio_00);
    }
  }
  return;
}



ral_status_t ral_set_standby(ral_t *radio,ral_standby_cfg_t standby_cfg)
{
  ral_status_t rVar1;
  ral_standby_cfg_t standby_cfg_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_standby)(radio->context,standby_cfg);
  return rVar1;
}



ral_status_t ral_set_tx_cw(ral_t *radio)
{
  ral_status_t rVar1;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_tx_cw)(radio->context);
  return rVar1;
}



demo_status_t demo_tx_cw_start(demo_t *self)
{
  apps_common_status_t aVar1;
  shield_t *psVar2;
  ral_t *radio_00;
  radio_parameters_t *prVar3;
  char *pcVar4;
  demo_status_t dVar5;
  demo_t *self_local;
  radio_parameters_t *radio_parameters;
  ral_t *radio;
  shield_t *shield;
  
  psVar2 = shield_manager_get_current_shield();
  apps_common_shield_init(psVar2);
  radio_00 = shield_get_ral_instance(psVar2);
  if (radio_00 == (ral_t *)0x0)
  {
    psVar2 = shield_manager_get_current_shield();
    apps_common_shield_deinit(psVar2);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "No radio available - Shield has no RAL or no shield set");
    dVar5 = DEMO_STATUS_ERROR;
  }
  else
  {
    aVar1 = apps_common_system_init(psVar2);
    if (aVar1 == APPS_COMMON_STATUS_OK)
    {
      apps_common_radio_init(psVar2);
      prVar3 = common_radio_get_parameters();
      smtc_display_clear();
      smtc_display_print_format_string(0,0,"DEMO: %s, running",0x802bf34);
      smtc_display_print_format_string(0,8,"Freq: %lu",(prVar3->rf_freq_in_hz).val);
      pcVar4 = display_printer_get_pkt_type_str((ushort)(prVar3->packet_type).val);
      smtc_display_print_format_string(0,0x10,"Packet type: %s",pcVar4);
      smtc_display_render();
      shield_handle_pre_tx(psVar2);
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "===== TX_CW example =====");
      ral_set_tx_cw(radio_00);
      dVar5 = DEMO_STATUS_OK;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "Radio initialization failed");
      demo_tx_cw_stop(self);
      dVar5 = DEMO_STATUS_ERROR;
    }
  }
  return dVar5;
}



demo_status_t demo_tx_cw_stop(demo_t *self)
{
  shield_t *psVar1;
  ral_t *radio_00;
  demo_t *self_local;
  ral_t *radio;
  
  psVar1 = shield_manager_get_current_shield();
  radio_00 = shield_get_ral_instance(psVar1);
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                      "Stopping Tx CW...");
  smtc_display_print_format_string(0,0,"DEMO: %s, stopped",0x802bf34);
  smtc_display_render();
  psVar1 = shield_manager_get_current_shield();
  shield_handle_post_tx(psVar1);
  ral_set_standby(radio_00,RAL_STANDBY_CFG_RC);
  psVar1 = shield_manager_get_current_shield();
  apps_common_shield_deinit(psVar1);
  return DEMO_STATUS_OK;
}



// WARNING: Unknown calling convention

demo_tx_cw_t * demo_tx_cw_get_instance(void)
{
  demo_tx_cw_t *in_r0;
  demo_tx_cw_t demo_tx_cw;
  
  (in_r0->base).vtable = &demo_tx_cw_get_instance::vtable;
  (in_r0->base).demo_name[0] = 'D';
  (in_r0->base).demo_name[1] = 'E';
  (in_r0->base).demo_name[2] = 'M';
  (in_r0->base).demo_name[3] = 'O';
  (in_r0->base).demo_name[4] = '_';
  (in_r0->base).demo_name[5] = 'T';
  (in_r0->base).demo_name[6] = 'X';
  (in_r0->base).demo_name[7] = '_';
  (in_r0->base).demo_name[8] = 'C';
  (in_r0->base).demo_name[9] = 'W';
  (in_r0->base).demo_name[10] = '\0';
  (in_r0->base).demo_name[0xb] = '\0';
  (in_r0->base).demo_name[0xc] = '\0';
  (in_r0->base).demo_name[0xd] = '\0';
  (in_r0->base).demo_name[0xe] = '\0';
  (in_r0->base).demo_name[0xf] = '\0';
  (in_r0->base).demo_name[0x10] = '\0';
  (in_r0->base).demo_name[0x11] = '\0';
  (in_r0->base).demo_name[0x12] = '\0';
  (in_r0->base).demo_name[0x13] = '\0';
  (in_r0->base).demo_name[0x14] = '\0';
  (in_r0->base).demo_name[0x15] = '\0';
  (in_r0->base).demo_name[0x16] = '\0';
  (in_r0->base).demo_name[0x17] = '\0';
  *(undefined4 *)((in_r0->base).demo_name + 0x18) = 0;
  return in_r0;
}



demo_status_t demo_tx_cw_runtime(demo_t *self)
{
  demo_t *self_local;
  
  return DEMO_STATUS_OK;
}



void demo_tx_cw_register_configurations_to_manager(demo_t *self,configuration_manager_t *manager)
{
  configuration_manager_t *manager_local;
  demo_t *self_local;
  
  return;
}



void config_uint64_t_write_to(configuration_item_t *self,void *val)
{
  size_t sVar1;
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint64_t *myself;
  
  sVar1 = self[1].size;
  *(configuration_item_interface_t **)val = self[1].vtable;
  *(size_t *)((int)val + 4) = sVar1;
  return;
}



void config_uint64_t_read_from(configuration_item_t *self,void *val)
{
  size_t sVar1;
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint64_t *myself;
  
                    // WARNING: Load size is inaccurate
  sVar1 = *(size_t *)((int)val + 4);
  self[1].vtable = *val;
  self[1].size = sVar1;
  return;
}



configuration_item_uint64_t *
build_config_item_uint64_t
          (configuration_item_uint64_t *__return_storage_ptr__,uint64_t default_value)
{
  uint64_t default_value_local;
  configuration_item_uint64_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_uint64_t::vtable;
  (__return_storage_ptr__->base).size = 8;
  __return_storage_ptr__->val = default_value;
  return __return_storage_ptr__;
}



void config_uint32_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint32_t *myself;
  
  *(configuration_item_interface_t **)val = self[1].vtable;
  return;
}



void config_uint32_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint32_t *myself;
  
                    // WARNING: Load size is inaccurate
  self[1].vtable = *val;
  return;
}



configuration_item_uint32_t *
build_config_item_uint32_t
          (configuration_item_uint32_t *__return_storage_ptr__,uint32_t default_value)
{
  uint32_t default_value_local;
  configuration_item_uint32_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_uint32_t::vtable;
  (__return_storage_ptr__->base).size = 4;
  __return_storage_ptr__->val = default_value;
  return __return_storage_ptr__;
}



void config_int32_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_int32_t *myself;
  
  *(configuration_item_interface_t **)val = self[1].vtable;
  return;
}



void config_int32_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_int32_t *myself;
  
                    // WARNING: Load size is inaccurate
  self[1].vtable = *val;
  return;
}



configuration_item_int32_t *
build_config_item_int32_t(configuration_item_int32_t *__return_storage_ptr__,int32_t default_value)
{
  int32_t default_value_local;
  configuration_item_int32_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_int32_t::vtable;
  (__return_storage_ptr__->base).size = 4;
  __return_storage_ptr__->val = default_value;
  return __return_storage_ptr__;
}



void config_uint16_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint16_t *myself;
  
  *(undefined2 *)val = *(undefined2 *)&self[1].vtable;
  return;
}



void config_uint16_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint16_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined2 *)&self[1].vtable = *val;
  return;
}



configuration_item_uint16_t *
build_config_item_uint16_t
          (configuration_item_uint16_t *__return_storage_ptr__,uint16_t default_value)
{
  uint16_t default_value_local;
  configuration_item_uint16_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_uint16_t::vtable;
  (__return_storage_ptr__->base).size = 2;
  __return_storage_ptr__->val = default_value;
  *(undefined2 *)&__return_storage_ptr__->field_0xa = config_item._10_2_;
  return __return_storage_ptr__;
}



void config_uint8_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint8_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_uint8_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_uint8_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_uint8_t *
build_config_item_uint8_t(configuration_item_uint8_t *__return_storage_ptr__,uint8_t default_value)
{
  uint8_t default_value_local;
  configuration_item_uint8_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_uint8_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_bool_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item__Bool *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_bool_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item__Bool *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item__Bool *
build_config_item__Bool(configuration_item__Bool *__return_storage_ptr__,_Bool default_value)
{
  _Bool default_value_local;
  configuration_item__Bool config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item__Bool::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_fallback_modes_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_fallback_modes_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_fallback_modes_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_fallback_modes_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_fallback_modes_t *
build_config_item_ral_fallback_modes_t
          (configuration_item_ral_fallback_modes_t *__return_storage_ptr__,
          ral_fallback_modes_t default_value)
{
  ral_fallback_modes_t default_value_local;
  configuration_item_ral_fallback_modes_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_fallback_modes_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_lora_sf_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_sf_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_lora_sf_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_sf_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_lora_sf_t *
build_config_item_ral_lora_sf_t
          (configuration_item_ral_lora_sf_t *__return_storage_ptr__,ral_lora_sf_t default_value)
{
  ral_lora_sf_t default_value_local;
  configuration_item_ral_lora_sf_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_lora_sf_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_lora_bw_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_bw_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_lora_bw_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_bw_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_lora_bw_t *
build_config_item_ral_lora_bw_t
          (configuration_item_ral_lora_bw_t *__return_storage_ptr__,ral_lora_bw_t default_value)
{
  ral_lora_bw_t default_value_local;
  configuration_item_ral_lora_bw_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_lora_bw_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_lora_pkt_len_modes_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_pkt_len_modes_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_lora_pkt_len_modes_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_pkt_len_modes_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_lora_pkt_len_modes_t *
build_config_item_ral_lora_pkt_len_modes_t
          (configuration_item_ral_lora_pkt_len_modes_t *__return_storage_ptr__,
          ral_lora_pkt_len_modes_t default_value)
{
  ral_lora_pkt_len_modes_t default_value_local;
  configuration_item_ral_lora_pkt_len_modes_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_lora_pkt_len_modes_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_lora_cr_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_cr_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_lora_cr_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_lora_cr_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_lora_cr_t *
build_config_item_ral_lora_cr_t
          (configuration_item_ral_lora_cr_t *__return_storage_ptr__,ral_lora_cr_t default_value)
{
  ral_lora_cr_t default_value_local;
  configuration_item_ral_lora_cr_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_lora_cr_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_gfsk_crc_type_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_crc_type_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_gfsk_crc_type_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_crc_type_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_gfsk_crc_type_t *
build_config_item_ral_gfsk_crc_type_t
          (configuration_item_ral_gfsk_crc_type_t *__return_storage_ptr__,
          ral_gfsk_crc_type_t default_value)
{
  ral_gfsk_crc_type_t default_value_local;
  configuration_item_ral_gfsk_crc_type_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_gfsk_crc_type_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_gfsk_pkt_len_modes_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_pkt_len_modes_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_gfsk_pkt_len_modes_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_pkt_len_modes_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_gfsk_pkt_len_modes_t *
build_config_item_ral_gfsk_pkt_len_modes_t
          (configuration_item_ral_gfsk_pkt_len_modes_t *__return_storage_ptr__,
          ral_gfsk_pkt_len_modes_t default_value)
{
  ral_gfsk_pkt_len_modes_t default_value_local;
  configuration_item_ral_gfsk_pkt_len_modes_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_gfsk_pkt_len_modes_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_gfsk_preamble_detector_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_preamble_detector_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_gfsk_preamble_detector_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_preamble_detector_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_gfsk_preamble_detector_t *
build_config_item_ral_gfsk_preamble_detector_t
          (configuration_item_ral_gfsk_preamble_detector_t *__return_storage_ptr__,
          ral_gfsk_preamble_detector_t default_value)
{
  ral_gfsk_preamble_detector_t default_value_local;
  configuration_item_ral_gfsk_preamble_detector_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_gfsk_preamble_detector_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_gfsk_pulse_shape_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_pulse_shape_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_gfsk_pulse_shape_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_pulse_shape_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_gfsk_pulse_shape_t *
build_config_item_ral_gfsk_pulse_shape_t
          (configuration_item_ral_gfsk_pulse_shape_t *__return_storage_ptr__,
          ral_gfsk_pulse_shape_t default_value)
{
  ral_gfsk_pulse_shape_t default_value_local;
  configuration_item_ral_gfsk_pulse_shape_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_gfsk_pulse_shape_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_gfsk_address_filtering_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_address_filtering_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_gfsk_address_filtering_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_address_filtering_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_gfsk_address_filtering_t *
build_config_item_ral_gfsk_address_filtering_t
          (configuration_item_ral_gfsk_address_filtering_t *__return_storage_ptr__,
          ral_gfsk_address_filtering_t default_value)
{
  ral_gfsk_address_filtering_t default_value_local;
  configuration_item_ral_gfsk_address_filtering_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_gfsk_address_filtering_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_ral_gfsk_dc_free_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_dc_free_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_ral_gfsk_dc_free_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_ral_gfsk_dc_free_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_ral_gfsk_dc_free_t *
build_config_item_ral_gfsk_dc_free_t
          (configuration_item_ral_gfsk_dc_free_t *__return_storage_ptr__,
          ral_gfsk_dc_free_t default_value)
{
  ral_gfsk_dc_free_t default_value_local;
  configuration_item_ral_gfsk_dc_free_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_ral_gfsk_dc_free_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_reg_mode_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_reg_mode_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_reg_mode_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_reg_mode_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_reg_mode_t *
build_config_item_shield_reg_mode_t
          (configuration_item_shield_reg_mode_t *__return_storage_ptr__,
          shield_reg_mode_t default_value)
{
  shield_reg_mode_t default_value_local;
  configuration_item_shield_reg_mode_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_reg_mode_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_preamble_len_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_preamble_len_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_preamble_len_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_preamble_len_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_preamble_len_t *
build_config_item_shield_flrc_preamble_len_t
          (configuration_item_shield_flrc_preamble_len_t *__return_storage_ptr__,
          shield_flrc_preamble_len_t default_value)
{
  shield_flrc_preamble_len_t default_value_local;
  configuration_item_shield_flrc_preamble_len_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_preamble_len_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_sync_word_len_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_sync_word_len_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_sync_word_len_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_sync_word_len_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_sync_word_len_t *
build_config_item_shield_flrc_sync_word_len_t
          (configuration_item_shield_flrc_sync_word_len_t *__return_storage_ptr__,
          shield_flrc_sync_word_len_t default_value)
{
  shield_flrc_sync_word_len_t default_value_local;
  configuration_item_shield_flrc_sync_word_len_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_sync_word_len_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_pkt_len_modes_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_pkt_len_modes_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_pkt_len_modes_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_pkt_len_modes_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_pkt_len_modes_t *
build_config_item_shield_flrc_pkt_len_modes_t
          (configuration_item_shield_flrc_pkt_len_modes_t *__return_storage_ptr__,
          shield_flrc_pkt_len_modes_t default_value)
{
  shield_flrc_pkt_len_modes_t default_value_local;
  configuration_item_shield_flrc_pkt_len_modes_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_pkt_len_modes_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_rx_match_sync_word_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_rx_match_sync_word_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_rx_match_sync_word_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_rx_match_sync_word_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_rx_match_sync_word_t *
build_config_item_shield_flrc_rx_match_sync_word_t
          (configuration_item_shield_flrc_rx_match_sync_word_t *__return_storage_ptr__,
          shield_flrc_rx_match_sync_word_t default_value)
{
  shield_flrc_rx_match_sync_word_t default_value_local;
  configuration_item_shield_flrc_rx_match_sync_word_t config_item;
  
  (__return_storage_ptr__->base).vtable =
       &build_config_item_shield_flrc_rx_match_sync_word_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_tx_sync_word_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_tx_sync_word_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_tx_sync_word_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_tx_sync_word_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_tx_sync_word_t *
build_config_item_shield_flrc_tx_sync_word_t
          (configuration_item_shield_flrc_tx_sync_word_t *__return_storage_ptr__,
          shield_flrc_tx_sync_word_t default_value)
{
  shield_flrc_tx_sync_word_t default_value_local;
  configuration_item_shield_flrc_tx_sync_word_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_tx_sync_word_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_crc_types_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_crc_types_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_crc_types_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_crc_types_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_crc_types_t *
build_config_item_shield_flrc_crc_types_t
          (configuration_item_shield_flrc_crc_types_t *__return_storage_ptr__,
          shield_flrc_crc_types_t default_value)
{
  shield_flrc_crc_types_t default_value_local;
  configuration_item_shield_flrc_crc_types_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_crc_types_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_br_bw_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_br_bw_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_br_bw_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_br_bw_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_br_bw_t *
build_config_item_shield_flrc_br_bw_t
          (configuration_item_shield_flrc_br_bw_t *__return_storage_ptr__,
          shield_flrc_br_bw_t default_value)
{
  shield_flrc_br_bw_t default_value_local;
  configuration_item_shield_flrc_br_bw_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_br_bw_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_cr_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_cr_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_cr_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_cr_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_cr_t *
build_config_item_shield_flrc_cr_t
          (configuration_item_shield_flrc_cr_t *__return_storage_ptr__,
          shield_flrc_cr_t default_value)
{
  shield_flrc_cr_t default_value_local;
  configuration_item_shield_flrc_cr_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_cr_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_flrc_pulse_shape_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_pulse_shape_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_flrc_pulse_shape_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_flrc_pulse_shape_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_flrc_pulse_shape_t *
build_config_item_shield_flrc_pulse_shape_t
          (configuration_item_shield_flrc_pulse_shape_t *__return_storage_ptr__,
          shield_flrc_pulse_shape_t default_value)
{
  shield_flrc_pulse_shape_t default_value_local;
  configuration_item_shield_flrc_pulse_shape_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_flrc_pulse_shape_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_packet_type_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_packet_type_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_packet_type_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_packet_type_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_packet_type_t *
build_config_item_shield_packet_type_t
          (configuration_item_shield_packet_type_t *__return_storage_ptr__,
          shield_packet_type_t default_value)
{
  shield_packet_type_t default_value_local;
  configuration_item_shield_packet_type_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_packet_type_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_pulse_shape_filter_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_pulse_shape_filter_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_pulse_shape_filter_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_pulse_shape_filter_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_pulse_shape_filter_t *
build_config_item_shield_ook_pulse_shape_filter_t
          (configuration_item_shield_ook_pulse_shape_filter_t *__return_storage_ptr__,
          shield_ook_pulse_shape_filter_t default_value)
{
  shield_ook_pulse_shape_filter_t default_value_local;
  configuration_item_shield_ook_pulse_shape_filter_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_pulse_shape_filter_t::vtable
  ;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_pulse_shape_bt_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_pulse_shape_bt_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_pulse_shape_bt_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_pulse_shape_bt_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_pulse_shape_bt_t *
build_config_item_shield_ook_pulse_shape_bt_t
          (configuration_item_shield_ook_pulse_shape_bt_t *__return_storage_ptr__,
          shield_ook_pulse_shape_bt_t default_value)
{
  shield_ook_pulse_shape_bt_t default_value_local;
  configuration_item_shield_ook_pulse_shape_bt_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_pulse_shape_bt_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_mag_depth_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_mag_depth_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_mag_depth_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_mag_depth_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_mag_depth_t *
build_config_item_shield_ook_mag_depth_t
          (configuration_item_shield_ook_mag_depth_t *__return_storage_ptr__,
          shield_ook_mag_depth_t default_value)
{
  shield_ook_mag_depth_t default_value_local;
  configuration_item_shield_ook_mag_depth_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_mag_depth_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_address_filtering_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_address_filtering_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_address_filtering_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_address_filtering_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_address_filtering_t *
build_config_item_shield_ook_address_filtering_t
          (configuration_item_shield_ook_address_filtering_t *__return_storage_ptr__,
          shield_ook_address_filtering_t default_value)
{
  shield_ook_address_filtering_t default_value_local;
  configuration_item_shield_ook_address_filtering_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_address_filtering_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_header_mode_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_header_mode_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_header_mode_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_header_mode_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_header_mode_t *
build_config_item_shield_ook_header_mode_t
          (configuration_item_shield_ook_header_mode_t *__return_storage_ptr__,
          shield_ook_header_mode_t default_value)
{
  shield_ook_header_mode_t default_value_local;
  configuration_item_shield_ook_header_mode_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_header_mode_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_crc_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_crc_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_crc_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_crc_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_crc_t *
build_config_item_shield_ook_crc_t
          (configuration_item_shield_ook_crc_t *__return_storage_ptr__,
          shield_ook_crc_t default_value)
{
  shield_ook_crc_t default_value_local;
  configuration_item_shield_ook_crc_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_crc_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_encoding_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_encoding_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_encoding_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_encoding_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_encoding_t *
build_config_item_shield_ook_encoding_t
          (configuration_item_shield_ook_encoding_t *__return_storage_ptr__,
          shield_ook_encoding_t default_value)
{
  shield_ook_encoding_t default_value_local;
  configuration_item_shield_ook_encoding_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_encoding_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_syncword_bit_order_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_syncword_bit_order_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_syncword_bit_order_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_syncword_bit_order_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_syncword_bit_order_t *
build_config_item_shield_ook_syncword_bit_order_t
          (configuration_item_shield_ook_syncword_bit_order_t *__return_storage_ptr__,
          shield_ook_syncword_bit_order_t default_value)
{
  shield_ook_syncword_bit_order_t default_value_local;
  configuration_item_shield_ook_syncword_bit_order_t config_item;
  
  (__return_storage_ptr__->base).vtable = &build_config_item_shield_ook_syncword_bit_order_t::vtable
  ;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void config_shield_ook_rx_detector_sfd_type_t_write_to(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_rx_detector_sfd_type_t *myself;
  
  *(undefined1 *)val = *(undefined1 *)&self[1].vtable;
  return;
}



void config_shield_ook_rx_detector_sfd_type_t_read_from(configuration_item_t *self,void *val)
{
  void *val_local;
  configuration_item_t *self_local;
  configuration_item_shield_ook_rx_detector_sfd_type_t *myself;
  
                    // WARNING: Load size is inaccurate
  *(undefined1 *)&self[1].vtable = *val;
  return;
}



configuration_item_shield_ook_rx_detector_sfd_type_t *
build_config_item_shield_ook_rx_detector_sfd_type_t
          (configuration_item_shield_ook_rx_detector_sfd_type_t *__return_storage_ptr__,
          shield_ook_rx_detector_sfd_type_t default_value)
{
  shield_ook_rx_detector_sfd_type_t default_value_local;
  configuration_item_shield_ook_rx_detector_sfd_type_t config_item;
  
  (__return_storage_ptr__->base).vtable =
       &build_config_item_shield_ook_rx_detector_sfd_type_t::vtable;
  (__return_storage_ptr__->base).size = 1;
  __return_storage_ptr__->val = default_value;
  *(undefined3 *)&__return_storage_ptr__->field_0x9 = config_item._9_3_;
  return __return_storage_ptr__;
}



void write_to(configuration_item_t *item,void *val)
{
  void *val_local;
  configuration_item_t *item_local;
  
  (*item->vtable->write_to)(item,val);
  return;
}



void read_from(configuration_item_t *item,void *val)
{
  void *val_local;
  configuration_item_t *item_local;
  
  (*item->vtable->read_from)(item,val);
  return;
}



void configuration_manager_init(configuration_manager_t *manager,hci_t *hci)
{
  hci_t *hci_local;
  configuration_manager_t *manager_local;
  
  manager->hci = hci;
  manager->n_items = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void configuration_manager_init_nvm_manager(void)
{
  config_manager_nvm_status_type_t cVar1;
  config_manager_nvm_status_type_t status;
  
  cVar1 = config_manager_nvm_init();
  if (cVar1 != CONFIG_MANAGER_NVM_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Failed to init NVM configuration manager");
  }
  return;
}



void configuration_manager_restore_from_nvm(configuration_manager_t *manager)
{
  config_manager_nvm_status_type_t cVar1;
  DeviceMessage__Configuration *protobuf;
  configuration_manager_t *manager_local;
  uint16_t proto_buff_len;
  uint8_t proto_buffer [255];
  DeviceMessage__Configuration *configuration;
  config_manager_nvm_status_type_t status;
  
  proto_buff_len = 0;
  cVar1 = config_manager_nvm_retrieve_configuration(proto_buffer,&proto_buff_len);
  if (cVar1 == CONFIG_MANAGER_NVM_NOT_FOUND)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"Configuration not found in NVM");
  }
  else if (cVar1 == CONFIG_MANAGER_NVM_OK)
  {
    protobuf = device_message__configuration__unpack
                         ((ProtobufCAllocator *)0x0,(uint)proto_buff_len,proto_buffer);
    read_from_protobuf(manager,protobuf);
    device_message__configuration__free_unpacked(protobuf,(ProtobufCAllocator *)0x0);
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Successfully load configuration from NVM");
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Failed to load configuration from NVM");
  }
  return;
}



void configuration_manager_interpret_command(configuration_manager_t *manager,command_t *command)
{
  _Bool _Var1;
  undefined4 uVar2;
  command_t *command_local;
  configuration_manager_t *manager_local;
  hci_datagram_t datagram;
  uint16_t config_len;
  DeviceMessage__Configuration *configuration;
  config_manager_nvm_status_type_t status;
  shield_name_t shield_to_save;
  command_demo_t demo_to_start;
  config_manager_nvm_status_type_t status_1;
  config_manager_nvm_status_type_t status_2;
  command_running_mode_t received_running_mode;
  
  if (true)
  {
    switch(command->type)
    {
    case COMMAND_TYPE_GET_CONFIGURATION:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Received GET CONFIGURATION");
      memset(&datagram,0,0x804);
      datagram.tag = '\v';
      configuration_manager_prepare_configuration(manager,datagram.data,&datagram.length,0x800);
      hci_send_datagram(manager->hci,&datagram);
      break;
    case COMMAND_TYPE_SET_CONFIGURATION:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Received SET CONFIGURATION");
      configuration =
           device_message__configuration__unpack
                     ((ProtobufCAllocator *)0x0,
                      (uint)(command->argument).set_configuration.buffer_length,
                      &(command->argument).start_demo.demo_to_start);
      read_from_protobuf(manager,configuration);
      device_message__configuration__free_unpacked(configuration,(ProtobufCAllocator *)0x0);
      break;
    case COMMAND_TYPE_STORE_CURRENT_CONFIGURATION_IN_NVM:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Received STORE CONFIGURATION");
      demo_to_start = (command->argument).store_in_nvm.demo_to_save;
      shield_to_save = (command->argument).store_in_nvm.shield_to_save;
      configuration_manager_prepare_configuration(manager,&datagram.tag,&config_len,0xff);
      status = config_manager_nvm_store_configuration(&datagram.tag,config_len);
      if (status == CONFIG_MANAGER_NVM_OK)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s successfully stored in NVM",0x802c0c8);
      }
      else if (status == CONFIG_MANAGER_NVM_FOUND)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s already present in NVM, nothing done",0x802c0c8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s store into NVM failed",0x802c0c8);
      }
      status = config_manager_nvm_store_demo_to_run(demo_to_start);
      if (status == CONFIG_MANAGER_NVM_OK)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s successfully stored in NVM",0x802c11c);
      }
      else if (status == CONFIG_MANAGER_NVM_FOUND)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s already present in NVM, nothing done",0x802c11c);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s store into NVM failed",0x802c11c);
      }
      status = config_manager_nvm_store_shield(shield_to_save);
      if (status == CONFIG_MANAGER_NVM_OK)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s successfully stored in NVM",0x802c134);
      }
      else if (status == CONFIG_MANAGER_NVM_FOUND)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s already present in NVM, nothing done",0x802c134);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s store into NVM failed",0x802c134);
      }
      break;
    case COMMAND_TYPE_FACTORY_RESET_NVM:
      status_1 = config_manager_nvm_factory_reset();
      if (status_1 == CONFIG_MANAGER_NVM_OK)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            false,"%s successfully removed from NVM",0x802c0c8);
      }
      else if (status_1 == CONFIG_MANAGER_NVM_NOT_FOUND)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            false,"%s not found in NVM, nothing done",0x802c0c8);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            false,"ERROR : Remove %s from NVM failed",0x802c0c8);
      }
      dynamic_log_message_nvm_factory_reset();
      break;
    case COMMAND_TYPE_LOAD_CONFIGURATION_FROM_NVM:
      configuration_manager_restore_from_nvm(manager);
      break;
    case COMMAND_TYPE_GET_RUNNING_MODE:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Received GET RUNNING_MODE");
      memset(&datagram,0,0x804);
      datagram.tag = '\x0f';
      _Var1 = is_running_mode_connected();
      if (_Var1)
      {
        uVar2 = 0x802c1d0;
      }
      else
      {
        uVar2 = 0x802c1dc;
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Running mode is %s",uVar2);
      running_mode_prepare_get_mode(datagram.data,&datagram.length,0x800);
      hci_send_datagram(manager->hci,&datagram);
      break;
    case COMMAND_TYPE_SET_RUNNING_MODE:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Received SET RUNNING MODE");
      received_running_mode = (command->argument).set_configuration.buffer[0];
      if (received_running_mode == RUNNING_MODE_CONNECTED)
      {
        running_mode_set_connected();
      }
      else
      {
        running_mode_set_standalone();
      }
      _Var1 = is_running_mode_connected();
      status_2 = config_manager_nvm_store_running_mode(_Var1);
      if (status_2 == CONFIG_MANAGER_NVM_OK)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s successfully stored in NVM",0x802c218);
      }
      else if (status_2 == CONFIG_MANAGER_NVM_FOUND)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s already present in NVM, nothing done",0x802c218);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"%s store into NVM failed",0x802c218);
      }
      break;
    case COMMAND_TYPE_GET_NVM_LOGS_SIZE:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Received GET NVM LOGS SIZE");
      memset(&datagram,0,0x804);
      datagram.tag = '\x10';
      dynamic_log_message_prepare_get_logs_size(datagram.data,&datagram.length,0x800);
      hci_send_datagram(manager->hci,&datagram);
      break;
    case COMMAND_TYPE_DUMP_NVM_LOGS:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Received DUMP NVM LOGS");
      memset(&datagram,0,0x804);
      datagram.tag = '\x11';
      dynamic_log_message_prepare_get_logs_size(datagram.data,&datagram.length,0x800);
      hci_send_datagram(manager->hci,&datagram);
      dynamic_log_message_nvm_dump();
    }
  }
  return;
}



_Bool append_storage_with_protobuf
                (configuration_manager_t *manager,configuration_item_t *item,
                read_from_protobuf_f read_from_protobuf,write_to_protobuf_f write_to_protobuf)
{
  size_t sVar1;
  write_to_protobuf_f write_to_protobuf_local;
  read_from_protobuf_f read_from_protobuf_local;
  configuration_item_t *item_local;
  configuration_manager_t *manager_local;
  
  sVar1 = manager->n_items;
  manager->n_items = sVar1 + 1;
  manager->storage[sVar1].item = item;
  manager->storage[sVar1].read_from_protobuf = read_from_protobuf;
  manager->storage[sVar1].write_to_protobuf = write_to_protobuf;
  return true;
}



void read_from_protobuf(configuration_manager_t *manager,DeviceMessage__Configuration *protobuf)
{
  read_from_protobuf_f p_Var1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_manager_t *manager_local;
  read_from_protobuf_f local_read_from_protobuf;
  configuration_item_t *item;
  size_t index_item;
  
  for (index_item = 0; index_item < manager->n_items; index_item += 1)
  {
    p_Var1 = manager->storage[index_item].read_from_protobuf;
    if (p_Var1 != (read_from_protobuf_f)0x0)
    {
      (*p_Var1)(manager->storage[index_item].item,protobuf);
    }
  }
  return;
}



void write_to_protobuf(configuration_manager_t *manager,DeviceMessage__Configuration *protobuf)
{
  write_to_protobuf_f p_Var1;
  DeviceMessage__Configuration *protobuf_local;
  configuration_manager_t *manager_local;
  write_to_protobuf_f local_write_to_protobuf;
  configuration_item_t *item;
  size_t index_item;
  
  for (index_item = 0; index_item < manager->n_items; index_item += 1)
  {
    p_Var1 = manager->storage[index_item].write_to_protobuf;
    if (p_Var1 != (write_to_protobuf_f)0x0)
    {
      (*p_Var1)(manager->storage[index_item].item,protobuf);
    }
  }
  return;
}



_Bool configuration_manager_prepare_configuration
                (configuration_manager_t *configuration_manager,uint8_t *buffer,
                uint16_t *packed_buffer_length,uint16_t max_length)
{
  ushort uVar1;
  size_t sVar2;
  uint16_t max_length_local;
  uint16_t *packed_buffer_length_local;
  uint8_t *buffer_local;
  configuration_manager_t *configuration_manager_local;
  DeviceMessage__RadioDefsOok__OokParameters config_radio_ook;
  DeviceMessage__RadioDefs__FlrcParameters config_radio_flrc;
  DeviceMessage__RadioDefs__FskParameters config_radio_fsk;
  DeviceMessage__RadioDefs__LoraParameters config_radio_lora_params;
  DeviceMessage__ConfigureRadio config_radio;
  DeviceMessage__ConfigurePingPong config_ping_pong;
  DeviceMessage__ConfigurePer config_per;
  DeviceMessage__ConfigureStaticMode config_static_mode;
  DeviceMessage__ConfigureExample config_example;
  DeviceMessage__ConfigureApplication config_app;
  DeviceMessage__Configuration config;
  
  config.base.descriptor = &device_message__configuration__descriptor;
  config.base.n_unknown_fields = 0;
  config.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  config.appli_configuration = (DeviceMessage__ConfigureApplication *)0x0;
  config.radio_configuration = (DeviceMessage__ConfigureRadio *)0x0;
  config_app.base.descriptor = &device_message__configure_application__descriptor;
  config_app.base.n_unknown_fields = 0;
  config_app.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  config_app.example = (DeviceMessage__ConfigureExample *)0x0;
  config_app.per = (DeviceMessage__ConfigurePer *)0x0;
  config_app.static_mode = (DeviceMessage__ConfigureStaticMode *)0x0;
  config_app.ping_pong = (DeviceMessage__ConfigurePingPong *)0x0;
  config_example.base.descriptor = &device_message__configure_example__descriptor;
  config_example.base.n_unknown_fields = 0;
  config_example.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  config_example.delay = 0;
  config_static_mode.base.descriptor = &device_message__configure_static_mode__descriptor;
  config_static_mode.base.n_unknown_fields = 0;
  config_static_mode.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  config_static_mode.static_mode = DEVICE_MESSAGE__STATIC_MODE__NOT_CONFIGURED;
  config_per.base.descriptor = &device_message__configure_per__descriptor;
  config_per.base.n_unknown_fields = 0;
  config_per.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  config_per.nb_frames = 0;
  config_per.tx_to_tx_delay_in_ms = 0;
  config_per.rx_timeout_in_ms = 0;
  config_per.receiver = 0;
  memset(&config_ping_pong,0,0x20);
  config_ping_pong.base.descriptor = &device_message__configure_ping_pong__descriptor;
  memset(&config_radio,0,0x38);
  config_radio.base.descriptor = &device_message__configure_radio__descriptor;
  memset(&config_radio_lora_params,0,0x30);
  config_radio_lora_params.base.descriptor =
       &device_message__radio_defs__lora_parameters__descriptor;
  memset(&config_radio_fsk,0,0x58);
  config_radio_fsk.base.descriptor = &device_message__radio_defs__fsk_parameters__descriptor;
  memset(&config_radio_flrc,0,0x3c);
  config_radio_flrc.base.descriptor = &device_message__radio_defs__flrc_parameters__descriptor;
  memset(&config_radio_ook,0,0x74);
  config_radio_ook.base.descriptor = &device_message__radio_defs_ook__ook_parameters__descriptor;
  config_app.example = &config_example;
  config_app.per = &config_per;
  config_app.ping_pong = &config_ping_pong;
  config_app.static_mode = &config_static_mode;
  config.appli_configuration = &config_app;
  config_radio.lora_parameters = &config_radio_lora_params;
  config_radio.fsk_parameters = &config_radio_fsk;
  config_radio.flrc_parameters = &config_radio_flrc;
  config_radio.ook_parameters = &config_radio_ook;
  config.radio_configuration = &config_radio;
  write_to_protobuf(configuration_manager,&config);
  sVar2 = device_message__configuration__get_packed_size(&config);
  *packed_buffer_length = (uint16_t)sVar2;
  uVar1 = *packed_buffer_length;
  if (uVar1 <= max_length)
  {
    device_message__configuration__pack(&config,buffer);
  }
  return uVar1 <= max_length;
}



// WARNING: Unknown calling convention

config_manager_nvm_status_type_t config_manager_nvm_init(void)
{
  nvm_manager_status_type_t nVar1;
  config_manager_nvm_status_type_t cVar2;
  nvm_manager_status_type_t nvm_manager_status;
  
  nVar1 = nvm_manager_nvm_init(&nvm_instance,0x80f0000,0x80f0800);
  if (nVar1 == NVM_MANAGER_OK)
  {
    cVar2 = CONFIG_MANAGER_NVM_OK;
  }
  else
  {
    cVar2 = CONFIG_MANAGER_NVM_ERROR;
  }
  return cVar2;
}



config_manager_nvm_status_type_t
config_manager_nvm_store_configuration(uint8_t *buffer,uint16_t len)
{
  config_manager_nvm_status_type_t cVar1;
  uint16_t len_local;
  uint8_t *buffer_local;
  
  if (len < 0x100)
  {
    cVar1 = config_manager_nvm_store(buffer,len,1);
  }
  else
  {
    cVar1 = CONFIG_MANAGER_NVM_ERROR;
  }
  return cVar1;
}



config_manager_nvm_status_type_t config_manager_nvm_store_demo_to_run(uint8_t demo_id)
{
  config_manager_nvm_status_type_t cVar1;
  uint8_t demo_id_local;
  
  demo_id_local = demo_id;
  if (demo_id == 0xff)
  {
    demo_id_local = demo_manager_get_last_run_demo_id();
  }
  cVar1 = config_manager_nvm_store(&demo_id_local,1,2);
  return cVar1;
}



config_manager_nvm_status_type_t config_manager_nvm_store_running_mode(_Bool is_connected_mode)
{
  config_manager_nvm_status_type_t cVar1;
  _Bool is_connected_mode_local;
  
  is_connected_mode_local = is_connected_mode;
  cVar1 = config_manager_nvm_store(&is_connected_mode_local,1,4);
  return cVar1;
}



config_manager_nvm_status_type_t config_manager_nvm_store_shield(shield_name_t shield_name)
{
  config_manager_nvm_status_type_t cVar1;
  shield_name_t shield_name_local;
  
  shield_name_local = shield_name;
  if (shield_name == shield_RADIOLESS)
  {
    shield_name_local = shield_manager_get_current_shield_name();
    if (shield_name_local == shield_RADIOLESS)
    {
      shield_name_local = shield_LR2021_ARDUINO_LEGACY;
    }
  }
  cVar1 = config_manager_nvm_store(&shield_name_local,1,3);
  return cVar1;
}



config_manager_nvm_status_type_t
config_manager_nvm_store_logs_status(uint8_t *buffer,uint16_t length)
{
  config_manager_nvm_status_type_t cVar1;
  uint16_t length_local;
  uint8_t *buffer_local;
  
  cVar1 = config_manager_nvm_store(buffer,length,5);
  return cVar1;
}



config_manager_nvm_status_type_t
config_manager_nvm_retrieve_logs_status(uint8_t *buffer,uint16_t *length)
{
  config_manager_nvm_status_type_t cVar1;
  uint16_t *length_local;
  uint8_t *buffer_local;
  
  cVar1 = config_manager_nvm_retrieve(buffer,length,5);
  return cVar1;
}



config_manager_nvm_status_type_t
config_manager_nvm_retrieve_configuration(uint8_t *buffer,uint16_t *length)
{
  config_manager_nvm_status_type_t cVar1;
  uint16_t *length_local;
  uint8_t *buffer_local;
  
  cVar1 = config_manager_nvm_retrieve(buffer,length,1);
  return cVar1;
}



config_manager_nvm_status_type_t config_manager_nvm_retrieve_demo_to_start(uint8_t *demo_id)
{
  config_manager_nvm_status_type_t cVar1;
  uint8_t *demo_id_local;
  uint16_t len;
  
  len = 0;
  cVar1 = config_manager_nvm_retrieve(demo_id,&len,2);
  return cVar1;
}



config_manager_nvm_status_type_t config_manager_nvm_retrieve_shield(shield_name_t *shield_name)
{
  config_manager_nvm_status_type_t cVar1;
  shield_name_t *shield_name_local;
  uint16_t len;
  
  len = 0;
  cVar1 = config_manager_nvm_retrieve(shield_name,&len,3);
  return cVar1;
}



config_manager_nvm_status_type_t
config_manager_nvm_retrieve_running_mode(uint8_t *is_connected_mode)
{
  config_manager_nvm_status_type_t cVar1;
  uint8_t *is_connected_mode_local;
  uint16_t len;
  
  len = 0;
  cVar1 = config_manager_nvm_retrieve(is_connected_mode,&len,4);
  return cVar1;
}



// WARNING: Unknown calling convention

config_manager_nvm_status_type_t config_manager_nvm_factory_reset(void)
{
  nvm_manager_status_type_t nVar1;
  config_manager_nvm_status_type_t cVar2;
  nvm_manager_status_type_t nvm_manager_status;
  
  nVar1 = nvm_manager_nvm_factory_reset(nvm_instance);
  if (nVar1 == NVM_MANAGER_OK)
  {
    cVar2 = CONFIG_MANAGER_NVM_OK;
  }
  else
  {
    cVar2 = CONFIG_MANAGER_NVM_ERROR;
  }
  return cVar2;
}



config_manager_nvm_status_type_t
config_manager_nvm_store(uint8_t *buffer,uint16_t len,uint16_t file_id)
{
  nvm_manager_status_type_t nVar1;
  config_manager_nvm_status_type_t cVar2;
  uint16_t file_id_local;
  uint16_t len_local;
  uint8_t *buffer_local;
  nvm_manager_status_type_t nvm_manager_status;
  
  nVar1 = nvm_manager_nvm_write(nvm_instance,file_id,buffer,len);
  if (nVar1 == NVM_MANAGER_OK)
  {
    cVar2 = CONFIG_MANAGER_NVM_OK;
  }
  else if (nVar1 == NVM_MANAGER_ALREADY_PRESENT_INFO)
  {
    cVar2 = CONFIG_MANAGER_NVM_FOUND;
  }
  else
  {
    cVar2 = CONFIG_MANAGER_NVM_ERROR;
  }
  return cVar2;
}



config_manager_nvm_status_type_t
config_manager_nvm_retrieve(uint8_t *buffer,uint16_t *len,uint16_t file_id)
{
  nvm_manager_status_type_t nVar1;
  config_manager_nvm_status_type_t cVar2;
  uint16_t file_id_local;
  uint16_t *len_local;
  uint8_t *buffer_local;
  nvm_manager_status_type_t nvm_manager_status;
  
  nVar1 = nvm_manager_nvm_read(nvm_instance,file_id,buffer,len);
  if (nVar1 == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
  {
    cVar2 = CONFIG_MANAGER_NVM_NOT_FOUND;
  }
  else if (nVar1 == NVM_MANAGER_OK)
  {
    cVar2 = CONFIG_MANAGER_NVM_OK;
  }
  else
  {
    cVar2 = CONFIG_MANAGER_NVM_ERROR;
  }
  return cVar2;
}



void version_information_command_interpret(command_t *command,hci_t *hci)
{
  size_t sVar1;
  hci_t *hci_local;
  command_t *command_local;
  hci_datagram_t version_information_datagram;
  DeviceMessage__VersionInformation version_information_message;
  size_t version_information_message_size;
  
  if (command->type == COMMAND_TYPE_GET_VERSION_INFORMATION)
  {
    version_information_message.base.descriptor = &device_message__version_information__descriptor;
    version_information_message.base.n_unknown_fields = 0;
    version_information_message.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
    version_information_message.build_date = "2025-10-16T20:31:04+00:00";
    version_information_message.code_version_date = "2025-10-16T20:27:44+00:00";
    version_information_message.code_version_tag = "v1.0.0";
    version_information_message.is_official = 1;
    sVar1 = device_message__version_information__get_packed_size(&version_information_message);
    if (sVar1 < 0x801)
    {
      memset(&version_information_datagram,0,0x804);
      version_information_datagram.tag = '\x0e';
      device_message__version_information__pack
                (&version_information_message,version_information_datagram.data);
      version_information_datagram.length = (uint16_t)sVar1;
      hci_send_datagram(hci,&version_information_datagram);
    }
  }
  return;
}



char * display_printer_get_pkt_type_str(uint16_t pkt_type)
{
  char *pcVar1;
  uint16_t pkt_type_local;
  
  switch(pkt_type)
  {
  case 0:
    pcVar1 = "GFSK";
    break;
  case 1:
    pcVar1 = "LORA";
    break;
  case 2:
    pcVar1 = "FLRC";
    break;
  case 3:
    pcVar1 = "OOK";
    break;
  default:
    pcVar1 = "Unknown";
  }
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void display_init(void)
{
  smtc_hal_mcu_wait_ms(0x32);
  support_i2c_init(&i2c_instance);
  smtc_display_init();
  smtc_display_clear();
  smtc_display_set_font("\x05",'\x05','\b',&print_mode);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void display_show_logo(void)
{
  smtc_display_draw_bitmap("",0x80,'@',&print_mode);
  smtc_display_render();
  return;
}



void smtc_display_write(uint16_t address,uint8_t *tx_buf,uint16_t length)
{
  smtc_hal_mcu_status_t sVar1;
  uint8_t *tx_buf_local;
  uint16_t length_local;
  uint16_t address_local;
  smtc_hal_mcu_status_t status;
  
  if (((display_found) && (i2c_instance != (smtc_hal_mcu_i2c_inst_t)0x0)) &&
     (sVar1 = smtc_hal_mcu_i2c_write_buffer
                        (i2c_instance,SMTC_HAL_MCU_I2C_ADDRESS_FORMAT_7_BITS,address,tx_buf,length),
     sVar1 == SMTC_HAL_MCU_STATUS_ERROR))
  {
    support_i2c_deinit(&i2c_instance);
    display_found = false;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void diagnostics_init(void)
{
  diagnostics_index = 0;
  diagnostics_previous_index = 0;
  memset(diagnostics,0,0x800);
  return;
}



void diagnostics_save_event(uint8_t event)
{
  uint8_t event_local;
  
  diagnostics_save_event_with_data(event,(uint8_t *)0x0,0);
  return;
}



void diagnostics_save_event_with_data(uint8_t event,uint8_t *buf,uint16_t len)
{
  ushort uVar1;
  uint uVar2;
  uint8_t *buf_local;
  uint16_t len_local;
  uint8_t event_local;
  uint8_t nb_occurences;
  int i;
  
  if ((event == diagnostics[diagnostics_previous_index]) &&
     (diagnostics[diagnostics_previous_index + 1] != 0xff))
  {
    diagnostics[diagnostics_previous_index + 1] =
         diagnostics[diagnostics_previous_index + 1] + '\x01';
  }
  else
  {
    diagnostics_previous_index = diagnostics_index;
    uVar2 = (uint)diagnostics_index;
    diagnostics_index += 1;
    diagnostics[uVar2] = event;
    uVar1 = (ushort)(((uint)diagnostics_index << 0x15) >> 0x15);
    diagnostics_index = uVar1 + 1;
    diagnostics[uVar1] = '\x01';
    diagnostics_index = (uint16_t)(((uint)diagnostics_index << 0x15) >> 0x15);
  }
  if ((len != 0) && (buf != (uint8_t *)0x0))
  {
    uVar2 = (uint)diagnostics_index;
    diagnostics_index += 1;
    diagnostics[uVar2] = (uint8_t)len;
    uVar1 = (ushort)(((uint)diagnostics_index << 0x15) >> 0x10);
    for (i = 0; diagnostics_index = uVar1 >> 5, i < (int)(uint)len; i += 1)
    {
      uVar2 = (uint)diagnostics_index;
      diagnostics_index += 1;
      diagnostics[uVar2] = buf[i];
      uVar1 = (ushort)(((uint)diagnostics_index << 0x15) >> 0x10);
    }
  }
  return;
}



uint32_t LL_SPI_IsEnabled(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  return (uint)((SPIx->CR1 & 0x40) == 0x40);
}



void LL_SPI_SetRxFIFOThreshold(SPI_TypeDef *SPIx,uint32_t Threshold)
{
  uint32_t Threshold_local;
  SPI_TypeDef *SPIx_local;
  
  SPIx->CR2 = SPIx->CR2 & 0xffffefff | Threshold;
  return;
}



void LL_SPI_SetCRCPolynomial(SPI_TypeDef *SPIx,uint32_t CRCPoly)
{
  uint32_t CRCPoly_local;
  SPI_TypeDef *SPIx_local;
  
  SPIx->CRCPR = CRCPoly & 0xffff;
  return;
}



void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.APB1RSTR1;
  RCC.APB1RSTR1 = Periphs | uVar1;
  return;
}



void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.APB1RSTR1;
  RCC.APB1RSTR1 = ~Periphs & uVar1;
  return;
}



void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.APB2RSTR;
  RCC.APB2RSTR = Periphs | uVar1;
  return;
}



void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.APB2RSTR;
  RCC.APB2RSTR = ~Periphs & uVar1;
  return;
}



ErrorStatus LL_SPI_DeInit(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  ErrorStatus status;
  
  if (SPIx == (SPI_TypeDef *)&SPI1)
  {
    LL_APB2_GRP1_ForceReset(0x1000);
    LL_APB2_GRP1_ReleaseReset(0x1000);
  }
  status = SPIx != (SPI_TypeDef *)&SPI1;
  if (SPIx == (SPI_TypeDef *)&SPI2)
  {
    LL_APB1_GRP1_ForceReset(0x4000);
    LL_APB1_GRP1_ReleaseReset(0x4000);
    status = SUCCESS;
  }
  if (SPIx == (SPI_TypeDef *)&SPI3)
  {
    LL_APB1_GRP1_ForceReset(0x8000);
    LL_APB1_GRP1_ReleaseReset(0x8000);
    status = SUCCESS;
  }
  return status;
}



ErrorStatus LL_SPI_Init(SPI_TypeDef *SPIx,LL_SPI_InitTypeDef *SPI_InitStruct)
{
  uint32_t uVar1;
  LL_SPI_InitTypeDef *SPI_InitStruct_local;
  SPI_TypeDef *SPIx_local;
  ErrorStatus status;
  
  status = ERROR;
  uVar1 = LL_SPI_IsEnabled(SPIx);
  if (uVar1 == 0)
  {
    SPIx->CR1 = SPI_InitStruct->CRCCalculation |
                SPI_InitStruct->TransferDirection | SPI_InitStruct->Mode |
                SPI_InitStruct->ClockPolarity | SPI_InitStruct->ClockPhase | SPI_InitStruct->NSS |
                SPI_InitStruct->BaudRate | SPI_InitStruct->BitOrder | SPIx->CR1 & 0xffff0040;
    SPIx->CR2 = SPI_InitStruct->NSS >> 0x10 | SPI_InitStruct->DataWidth | SPIx->CR2 & 0xfffff0fb;
    if (SPI_InitStruct->DataWidth < 0x800)
    {
      LL_SPI_SetRxFIFOThreshold(SPIx,0x1000);
    }
    if (SPI_InitStruct->CRCCalculation == 0x2000)
    {
      LL_SPI_SetCRCPolynomial(SPIx,SPI_InitStruct->CRCPoly);
    }
    status = SUCCESS;
  }
  return status;
}



void LL_I2C_Enable(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->CR1 = I2Cx->CR1 | 1;
  return;
}



void LL_I2C_Disable(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->CR1 = I2Cx->CR1 & 0xfffffffe;
  return;
}



void LL_I2C_ConfigFilters(I2C_TypeDef *I2Cx,uint32_t AnalogFilter,uint32_t DigitalFilter)
{
  uint32_t DigitalFilter_local;
  uint32_t AnalogFilter_local;
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->CR1 = I2Cx->CR1 & 0xffffe0ff | AnalogFilter | DigitalFilter << 8;
  return;
}



void LL_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx,uint32_t OwnAddress1,uint32_t OwnAddrSize)
{
  uint32_t OwnAddrSize_local;
  uint32_t OwnAddress1_local;
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->OAR1 = OwnAddrSize | OwnAddress1 | I2Cx->OAR1 & 0xfffff800;
  return;
}



void LL_I2C_EnableOwnAddress1(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->OAR1 = I2Cx->OAR1 | 0x8000;
  return;
}



void LL_I2C_DisableOwnAddress1(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->OAR1 = I2Cx->OAR1 & 0xffff7fff;
  return;
}



void LL_I2C_SetTiming(I2C_TypeDef *I2Cx,uint32_t Timing)
{
  uint32_t Timing_local;
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->TIMINGR = Timing;
  return;
}



void LL_I2C_SetMode(I2C_TypeDef *I2Cx,uint32_t PeripheralMode)
{
  uint32_t PeripheralMode_local;
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->CR1 = I2Cx->CR1 & 0xffcfffff | PeripheralMode;
  return;
}



void LL_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx,uint32_t TypeAcknowledge)
{
  uint32_t TypeAcknowledge_local;
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->CR2 = I2Cx->CR2 & 0xffff7fff | TypeAcknowledge;
  return;
}



void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.APB1RSTR1;
  RCC.APB1RSTR1 = Periphs | uVar1;
  return;
}



void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.APB1RSTR1;
  RCC.APB1RSTR1 = ~Periphs & uVar1;
  return;
}



ErrorStatus LL_I2C_DeInit(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  ErrorStatus status;
  
  status = SUCCESS;
  if (I2Cx == (I2C_TypeDef *)&I2C1)
  {
    LL_APB1_GRP1_ForceReset(0x200000);
    LL_APB1_GRP1_ReleaseReset(0x200000);
  }
  else if (I2Cx == (I2C_TypeDef *)&I2C2)
  {
    LL_APB1_GRP1_ForceReset(0x400000);
    LL_APB1_GRP1_ReleaseReset(0x400000);
  }
  else if (I2Cx == (I2C_TypeDef *)&I2C3)
  {
    LL_APB1_GRP1_ForceReset(0x800000);
    LL_APB1_GRP1_ReleaseReset(0x800000);
  }
  else
  {
    status = ERROR;
  }
  return status;
}



ErrorStatus LL_I2C_Init(I2C_TypeDef *I2Cx,LL_I2C_InitTypeDef *I2C_InitStruct)
{
  LL_I2C_InitTypeDef *I2C_InitStruct_local;
  I2C_TypeDef *I2Cx_local;
  
  LL_I2C_Disable(I2Cx);
  LL_I2C_ConfigFilters(I2Cx,I2C_InitStruct->AnalogFilter,I2C_InitStruct->DigitalFilter);
  LL_I2C_SetTiming(I2Cx,I2C_InitStruct->Timing);
  LL_I2C_Enable(I2Cx);
  LL_I2C_DisableOwnAddress1(I2Cx);
  LL_I2C_SetOwnAddress1(I2Cx,I2C_InitStruct->OwnAddress1,I2C_InitStruct->OwnAddrSize);
  if (I2C_InitStruct->OwnAddress1 != 0)
  {
    LL_I2C_EnableOwnAddress1(I2Cx);
  }
  LL_I2C_SetMode(I2Cx,I2C_InitStruct->PeripheralMode);
  LL_I2C_AcknowledgeNextData(I2Cx,I2C_InitStruct->TypeAcknowledge);
  return SUCCESS;
}



uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  return (uint)((USARTx->CR1 & 1) == 1);
}



void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx,uint32_t StopBits)
{
  uint32_t StopBits_local;
  USART_TypeDef *USARTx_local;
  
  USARTx->CR2 = USARTx->CR2 & 0xffffcfff | StopBits;
  return;
}



void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx,uint32_t HardwareFlowControl)
{
  uint32_t HardwareFlowControl_local;
  USART_TypeDef *USARTx_local;
  
  USARTx->CR3 = USARTx->CR3 & 0xfffffcff | HardwareFlowControl;
  return;
}



void LL_USART_SetBaudRate
               (USART_TypeDef *USARTx,uint32_t PeriphClk,uint32_t OverSampling,uint32_t BaudRate)
{
  uint uVar1;
  uint32_t BaudRate_local;
  uint32_t OverSampling_local;
  uint32_t PeriphClk_local;
  USART_TypeDef *USARTx_local;
  uint32_t brrtemp;
  uint32_t usartdiv;
  
  if (OverSampling == 0x8000)
  {
    uVar1 = (PeriphClk * 2 + (BaudRate >> 1)) / BaudRate;
    USARTx->BRR = (uVar1 & 0xffff) >> 1 & 7 | uVar1 & 0xfff0;
  }
  else
  {
    USARTx->BRR = ((BaudRate >> 1) + PeriphClk) / BaudRate & 0xffff;
  }
  return;
}



ErrorStatus LL_USART_Init(USART_TypeDef *USARTx,LL_USART_InitTypeDef *USART_InitStruct)
{
  uint32_t uVar1;
  LL_USART_InitTypeDef *USART_InitStruct_local;
  USART_TypeDef *USARTx_local;
  uint32_t periphclk;
  ErrorStatus status;
  
  status = ERROR;
  periphclk = 0;
  uVar1 = LL_USART_IsEnabled(USARTx);
  if (uVar1 == 0)
  {
    USARTx->CR1 = USART_InitStruct->OverSampling |
                  USART_InitStruct->DataWidth | USART_InitStruct->Parity |
                  USART_InitStruct->TransferDirection | USARTx->CR1 & 0xefff69f3;
    LL_USART_SetStopBitsLength(USARTx,USART_InitStruct->StopBits);
    LL_USART_SetHWFlowCtrl(USARTx,USART_InitStruct->HardwareFlowControl);
    if (USARTx == (USART_TypeDef *)&USART1)
    {
      periphclk = LL_RCC_GetUSARTClockFreq(3);
    }
    else if (USARTx == (USART_TypeDef *)&USART2)
    {
      periphclk = LL_RCC_GetUSARTClockFreq(0xc);
    }
    else if (USARTx == (USART_TypeDef *)&USART3)
    {
      periphclk = LL_RCC_GetUSARTClockFreq(0x30);
    }
    else if (USARTx == (USART_TypeDef *)&UART4)
    {
      periphclk = LL_RCC_GetUARTClockFreq(0xc0);
    }
    else if (USARTx == (USART_TypeDef *)&UART5)
    {
      periphclk = LL_RCC_GetUARTClockFreq(0x300);
    }
    if ((periphclk != 0) && (USART_InitStruct->BaudRate != 0))
    {
      status = SUCCESS;
      LL_USART_SetBaudRate
                (USARTx,periphclk,USART_InitStruct->OverSampling,USART_InitStruct->BaudRate);
    }
  }
  return status;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_HSI_IsReady(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  return (uint)((uVar1 & 0x400) == 0x400);
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_LSE_IsReady(void)
{
  uint uVar1;
  
  uVar1 = RCC.BDCR;
  return (uint)((uVar1 & 2) == 2);
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_MSI_IsEnabledRangeSelect(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  return (uint)((uVar1 & 8) == 8);
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_MSI_GetRange(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  return uVar1 & 0xf0;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_MSI_GetRangeAfterStandby(void)
{
  uint uVar1;
  
  uVar1 = RCC.CSR;
  return uVar1 & 0xf00;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_GetSysClkSource(void)
{
  uint uVar1;
  
  uVar1 = RCC.CFGR;
  return uVar1 & 0xc;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_GetAHBPrescaler(void)
{
  uint uVar1;
  
  uVar1 = RCC.CFGR;
  return uVar1 & 0xf0;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  uint uVar1;
  
  uVar1 = RCC.CFGR;
  return uVar1 & 0x700;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_GetAPB2Prescaler(void)
{
  uint uVar1;
  
  uVar1 = RCC.CFGR;
  return uVar1 & 0x3800;
}



uint32_t LL_RCC_GetUSARTClockSource(uint32_t USARTx)
{
  uint uVar1;
  uint32_t USARTx_local;
  
  uVar1 = RCC.CCIPR;
  return USARTx << 0x10 | uVar1 & USARTx;
}



uint32_t LL_RCC_GetUARTClockSource(uint32_t UARTx)
{
  uint uVar1;
  uint32_t UARTx_local;
  
  uVar1 = RCC.CCIPR;
  return UARTx << 0x10 | uVar1 & UARTx;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_PLL_GetMainSource(void)
{
  uint uVar1;
  
  uVar1 = RCC.PLLCFGR;
  return uVar1 & 3;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_PLL_GetN(void)
{
  uint uVar1;
  
  uVar1 = RCC.PLLCFGR;
  return uVar1 >> 8 & 0x7f;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_PLL_GetR(void)
{
  uint uVar1;
  
  uVar1 = RCC.PLLCFGR;
  return uVar1 & 0x6000000;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_PLL_GetDivider(void)
{
  uint uVar1;
  
  uVar1 = RCC.PLLCFGR;
  return uVar1 & 0x70;
}



uint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)
{
  uint32_t uVar1;
  uint32_t USARTxSource_local;
  uint32_t usart_frequency;
  
  usart_frequency = 0;
  if (USARTxSource == 3)
  {
    uVar1 = LL_RCC_GetUSARTClockSource(3);
    switch(uVar1)
    {
    case 0x30000:
      uVar1 = RCC_GetSystemClockFreq();
      uVar1 = RCC_GetHCLKClockFreq(uVar1);
      uVar1 = RCC_GetPCLK2ClockFreq(uVar1);
      return uVar1;
    case 0x30001:
      uVar1 = RCC_GetSystemClockFreq();
      return uVar1;
    case 0x30002:
      goto switchD_0800fbb6_caseD_30002;
    case 0x30003:
      uVar1 = LL_RCC_LSE_IsReady();
      if (uVar1 == 0)
      {
        return 0;
      }
      return 0x8000;
    default:
      return 0;
    }
  }
  if (USARTxSource != 0xc)
  {
    if (USARTxSource != 0x30)
    {
      return 0;
    }
    uVar1 = LL_RCC_GetUSARTClockSource(0x30);
    if (uVar1 == 0x300030)
    {
      uVar1 = LL_RCC_LSE_IsReady();
      if (uVar1 == 0)
      {
        return 0;
      }
      return 0x8000;
    }
    if (0x300030 < uVar1)
    {
      return 0;
    }
    if (uVar1 != 0x300020)
    {
      if (0x300020 < uVar1)
      {
        return 0;
      }
      if (uVar1 != 0x300000)
      {
        if (uVar1 != 0x300010)
        {
          return 0;
        }
        uVar1 = RCC_GetSystemClockFreq();
        return uVar1;
      }
      uVar1 = RCC_GetSystemClockFreq();
      uVar1 = RCC_GetHCLKClockFreq(uVar1);
      uVar1 = RCC_GetPCLK1ClockFreq(uVar1);
      return uVar1;
    }
    uVar1 = LL_RCC_HSI_IsReady();
    if (uVar1 == 0)
    {
      return 0;
    }
    return 16000000;
  }
  uVar1 = LL_RCC_GetUSARTClockSource(0xc);
  if (false)
  {
code_r0x0800fd28:
  }
  else
  {
    switch(uVar1)
    {
    case 0xc0000:
      uVar1 = RCC_GetSystemClockFreq();
      uVar1 = RCC_GetHCLKClockFreq(uVar1);
      usart_frequency = RCC_GetPCLK1ClockFreq(uVar1);
      break;
    default:
      goto code_r0x0800fd28;
    case 0xc0004:
      usart_frequency = RCC_GetSystemClockFreq();
      break;
    case 0xc0008:
      uVar1 = LL_RCC_HSI_IsReady();
      if (uVar1 != 0)
      {
        usart_frequency = 16000000;
      }
      break;
    case 0xc000c:
      uVar1 = LL_RCC_LSE_IsReady();
      if (uVar1 != 0)
      {
        usart_frequency = 0x8000;
      }
    }
  }
  return usart_frequency;
switchD_0800fbb6_caseD_30002:
  uVar1 = LL_RCC_HSI_IsReady();
  if (uVar1 == 0)
  {
    return 0;
  }
  return 16000000;
}



uint32_t LL_RCC_GetUARTClockFreq(uint32_t UARTxSource)
{
  uint32_t uVar1;
  uint32_t UARTxSource_local;
  uint32_t uart_frequency;
  
  uart_frequency = 0;
  if (UARTxSource == 0xc0)
  {
    uVar1 = LL_RCC_GetUARTClockSource(0xc0);
    if (uVar1 == 0xc000c0)
    {
      uVar1 = LL_RCC_LSE_IsReady();
      if (uVar1 != 0)
      {
        uart_frequency = 0x8000;
      }
    }
    else if (uVar1 < 0xc000c1)
    {
      if (uVar1 == 0xc00080)
      {
        uVar1 = LL_RCC_HSI_IsReady();
        if (uVar1 != 0)
        {
          uart_frequency = 16000000;
        }
      }
      else if (uVar1 < 0xc00081)
      {
        if (uVar1 == 0xc00000)
        {
          uVar1 = RCC_GetSystemClockFreq();
          uVar1 = RCC_GetHCLKClockFreq(uVar1);
          uart_frequency = RCC_GetPCLK1ClockFreq(uVar1);
        }
        else if (uVar1 == 0xc00040)
        {
          uart_frequency = RCC_GetSystemClockFreq();
        }
      }
    }
  }
  if (UARTxSource == 0x300)
  {
    uVar1 = LL_RCC_GetUARTClockSource(0x300);
    if (uVar1 == 0x3000300)
    {
      uVar1 = LL_RCC_LSE_IsReady();
      if (uVar1 != 0)
      {
        uart_frequency = 0x8000;
      }
    }
    else if (uVar1 < 0x3000301)
    {
      if (uVar1 == 0x3000200)
      {
        uVar1 = LL_RCC_HSI_IsReady();
        if (uVar1 != 0)
        {
          uart_frequency = 16000000;
        }
      }
      else if (uVar1 < 0x3000201)
      {
        if (uVar1 == 0x3000000)
        {
          uVar1 = RCC_GetSystemClockFreq();
          uVar1 = RCC_GetHCLKClockFreq(uVar1);
          uart_frequency = RCC_GetPCLK1ClockFreq(uVar1);
        }
        else if (uVar1 == 0x3000100)
        {
          uart_frequency = RCC_GetSystemClockFreq();
        }
      }
    }
  }
  return uart_frequency;
}



// WARNING: Unknown calling convention

uint32_t RCC_GetSystemClockFreq(void)
{
  uint32_t uVar1;
  uint uVar2;
  uint32_t frequency;
  
  uVar1 = LL_RCC_GetSysClkSource();
  if (false)
  {
switchD_0800fe9a_caseD_1:
    uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
    if (uVar1 == 0)
    {
      uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
      if (uVar1 == 0)
      {
        uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
      }
      else
      {
        uVar2 = LL_RCC_MSI_GetRange();
      }
      frequency = MSIRangeTable[uVar2 >> 8];
    }
    else
    {
      uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
      if (uVar1 == 0)
      {
        uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
      }
      else
      {
        uVar2 = LL_RCC_MSI_GetRange();
      }
      frequency = MSIRangeTable[uVar2 >> 4];
    }
  }
  else
  {
    switch(uVar1)
    {
    case 0:
      uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
      if (uVar1 == 0)
      {
        uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
        if (uVar1 == 0)
        {
          uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
        }
        else
        {
          uVar2 = LL_RCC_MSI_GetRange();
        }
        frequency = MSIRangeTable[uVar2 >> 8];
      }
      else
      {
        uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
        if (uVar1 == 0)
        {
          uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
        }
        else
        {
          uVar2 = LL_RCC_MSI_GetRange();
        }
        frequency = MSIRangeTable[uVar2 >> 4];
      }
      break;
    default:
      goto switchD_0800fe9a_caseD_1;
    case 4:
      frequency = 16000000;
      break;
    case 8:
      frequency = 8000000;
      break;
    case 0xc:
      frequency = RCC_PLL_GetFreqDomain_SYS();
    }
  }
  return frequency;
}



uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  uint32_t uVar1;
  uint32_t SYSCLK_Frequency_local;
  
  uVar1 = LL_RCC_GetAHBPrescaler();
  return SYSCLK_Frequency >> ""[uVar1 >> 4 & 0xf];
}



uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  uint32_t uVar1;
  uint32_t HCLK_Frequency_local;
  
  uVar1 = LL_RCC_GetAPB1Prescaler();
  return HCLK_Frequency >> ""[uVar1 >> 8];
}



uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
  uint32_t uVar1;
  uint32_t HCLK_Frequency_local;
  
  uVar1 = LL_RCC_GetAPB2Prescaler();
  return HCLK_Frequency >> ""[uVar1 >> 0xb];
}



// WARNING: Unknown calling convention

uint32_t RCC_PLL_GetFreqDomain_SYS(void)
{
  uint32_t uVar1;
  uint uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t pllsource;
  uint32_t pllinputfreq;
  
  uVar1 = LL_RCC_PLL_GetMainSource();
  if (uVar1 == 3)
  {
    pllinputfreq = 8000000;
    goto LAB_080100fe;
  }
  if (uVar1 < 4)
  {
    if (uVar1 == 1)
    {
      uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
      if (uVar1 == 0)
      {
        uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
        if (uVar1 == 0)
        {
          uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
        }
        else
        {
          uVar2 = LL_RCC_MSI_GetRange();
        }
        pllinputfreq = MSIRangeTable[uVar2 >> 8];
      }
      else
      {
        uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
        if (uVar1 == 0)
        {
          uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
        }
        else
        {
          uVar2 = LL_RCC_MSI_GetRange();
        }
        pllinputfreq = MSIRangeTable[uVar2 >> 4];
      }
      goto LAB_080100fe;
    }
    if (uVar1 == 2)
    {
      pllinputfreq = 16000000;
      goto LAB_080100fe;
    }
  }
  uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
  if (uVar1 == 0)
  {
    uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
    if (uVar1 == 0)
    {
      uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
    }
    else
    {
      uVar2 = LL_RCC_MSI_GetRange();
    }
    pllinputfreq = MSIRangeTable[uVar2 >> 8];
  }
  else
  {
    uVar1 = LL_RCC_MSI_IsEnabledRangeSelect();
    if (uVar1 == 0)
    {
      uVar2 = LL_RCC_MSI_GetRangeAfterStandby();
    }
    else
    {
      uVar2 = LL_RCC_MSI_GetRange();
    }
    pllinputfreq = MSIRangeTable[uVar2 >> 4];
  }
LAB_080100fe:
  uVar1 = LL_RCC_PLL_GetDivider();
  uVar3 = LL_RCC_PLL_GetN();
  uVar4 = LL_RCC_PLL_GetR();
  return (uVar3 * (pllinputfreq / ((uVar1 >> 4) + 1))) / (((uVar4 >> 0x19) + 1) * 2);
}



void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx,uint32_t Pin,uint32_t Mode)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint32_t Mode_local;
  uint32_t Pin_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t result_1;
  
  bVar2 = (byte)Pin;
  bVar3 = (byte)(Pin >> 8);
  bVar4 = (byte)(Pin >> 0x10);
  bVar1 = (byte)(Pin >> 0x18);
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar6 = 0x20;
  }
  else
  {
    iVar6 = LZCOUNT(uVar5);
  }
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar7 = 0x20;
  }
  else
  {
    iVar7 = LZCOUNT(uVar5);
  }
  GPIOx->MODER = GPIOx->MODER & ~(3 << (iVar6 << 1)) | Mode << (iVar7 << 1);
  return;
}



void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx,uint32_t PinMask,uint32_t OutputType)
{
  uint32_t OutputType_local;
  uint32_t PinMask_local;
  GPIO_TypeDef *GPIOx_local;
  
  GPIOx->OTYPER = GPIOx->OTYPER & ~PinMask | OutputType * PinMask;
  return;
}



void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx,uint32_t Pin,uint32_t Speed)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint32_t Speed_local;
  uint32_t Pin_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t result_1;
  
  bVar2 = (byte)Pin;
  bVar3 = (byte)(Pin >> 8);
  bVar4 = (byte)(Pin >> 0x10);
  bVar1 = (byte)(Pin >> 0x18);
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar6 = 0x20;
  }
  else
  {
    iVar6 = LZCOUNT(uVar5);
  }
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar7 = 0x20;
  }
  else
  {
    iVar7 = LZCOUNT(uVar5);
  }
  GPIOx->OSPEEDR = GPIOx->OSPEEDR & ~(3 << (iVar6 << 1)) | Speed << (iVar7 << 1);
  return;
}



void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx,uint32_t Pin,uint32_t Pull)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint32_t Pull_local;
  uint32_t Pin_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t result_1;
  
  bVar2 = (byte)Pin;
  bVar3 = (byte)(Pin >> 8);
  bVar4 = (byte)(Pin >> 0x10);
  bVar1 = (byte)(Pin >> 0x18);
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar6 = 0x20;
  }
  else
  {
    iVar6 = LZCOUNT(uVar5);
  }
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar7 = 0x20;
  }
  else
  {
    iVar7 = LZCOUNT(uVar5);
  }
  GPIOx->PUPDR = GPIOx->PUPDR & ~(3 << (iVar6 << 1)) | Pull << (iVar7 << 1);
  return;
}



void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx,uint32_t Pin,uint32_t Alternate)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint32_t Alternate_local;
  uint32_t Pin_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t result_1;
  
  bVar2 = (byte)Pin;
  bVar3 = (byte)(Pin >> 8);
  bVar4 = (byte)(Pin >> 0x10);
  bVar1 = (byte)(Pin >> 0x18);
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar6 = 0x20;
  }
  else
  {
    iVar6 = LZCOUNT(uVar5);
  }
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar7 = 0x20;
  }
  else
  {
    iVar7 = LZCOUNT(uVar5);
  }
  GPIOx->AFR[0] = GPIOx->AFR[0] & ~(0xf << (iVar6 << 2)) | Alternate << (iVar7 << 2);
  return;
}



void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx,uint32_t Pin,uint32_t Alternate)
{
  uint uVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  int iVar5;
  int iVar6;
  uint32_t Alternate_local;
  uint32_t Pin_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t result_1;
  
  bVar2 = (byte)(Pin >> 8);
  bVar3 = (byte)(Pin >> 0x10);
  bVar4 = (byte)(Pin >> 0x18);
  uVar1 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8;
  if (uVar1 == 0)
  {
    iVar5 = 0x20;
  }
  else
  {
    iVar5 = LZCOUNT(uVar1);
  }
  uVar1 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8;
  if (uVar1 == 0)
  {
    iVar6 = 0x20;
  }
  else
  {
    iVar6 = LZCOUNT(uVar1);
  }
  GPIOx->AFR[1] = GPIOx->AFR[1] & ~(0xf << (iVar5 << 2)) | Alternate << (iVar6 << 2);
  return;
}



ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx,LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint32_t uVar5;
  uint uVar6;
  LL_GPIO_InitTypeDef *GPIO_InitStruct_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t currentpin;
  uint32_t pinpos;
  
  uVar5 = GPIO_InitStruct->Pin;
  bVar2 = (byte)uVar5;
  bVar3 = (byte)(uVar5 >> 8);
  bVar4 = (byte)(uVar5 >> 0x10);
  bVar1 = (byte)(uVar5 >> 0x18);
  uVar6 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar6 == 0)
  {
    pinpos = 0x20;
  }
  else
  {
    pinpos = LZCOUNT(uVar6);
  }
  for (; GPIO_InitStruct->Pin >> (pinpos & 0xff) != 0; pinpos += 1)
  {
    uVar6 = 1 << (pinpos & 0xff) & GPIO_InitStruct->Pin;
    if (uVar6 != 0)
    {
      if ((GPIO_InitStruct->Mode == 1) || (GPIO_InitStruct->Mode == 2))
      {
        LL_GPIO_SetPinSpeed(GPIOx,uVar6,GPIO_InitStruct->Speed);
        LL_GPIO_SetPinOutputType(GPIOx,GPIO_InitStruct->Pin,GPIO_InitStruct->OutputType);
      }
      LL_GPIO_SetPinPull(GPIOx,uVar6,GPIO_InitStruct->Pull);
      if (GPIO_InitStruct->Mode == 2)
      {
        if (uVar6 < 0x100)
        {
          LL_GPIO_SetAFPin_0_7(GPIOx,uVar6,GPIO_InitStruct->Alternate);
        }
        else
        {
          LL_GPIO_SetAFPin_8_15(GPIOx,uVar6,GPIO_InitStruct->Alternate);
        }
      }
      LL_GPIO_SetPinMode(GPIOx,uVar6,GPIO_InitStruct->Mode);
    }
  }
  return SUCCESS;
}



void LL_EXTI_EnableIT_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.IMR1;
  EXTI.IMR1 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.IMR2;
  EXTI.IMR2 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_DisableIT_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.IMR1;
  EXTI.IMR1 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_DisableIT_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.IMR2;
  EXTI.IMR2 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_EnableEvent_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.EMR1;
  EXTI.EMR1 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_EnableEvent_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.EMR2;
  EXTI.EMR2 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.EMR1;
  EXTI.EMR1 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_DisableEvent_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.EMR2;
  EXTI.EMR2 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.RTSR1;
  EXTI.RTSR1 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.RTSR2;
  EXTI.RTSR2 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.RTSR1;
  EXTI.RTSR1 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_DisableRisingTrig_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.RTSR2;
  EXTI.RTSR2 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.FTSR1;
  EXTI.FTSR1 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_EnableFallingTrig_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.FTSR2;
  EXTI.FTSR2 = ExtiLine | uVar1;
  return;
}



void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.FTSR1;
  EXTI.FTSR1 = ~ExtiLine & uVar1;
  return;
}



void LL_EXTI_DisableFallingTrig_32_63(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.FTSR2;
  EXTI.FTSR2 = ~ExtiLine & uVar1;
  return;
}



uint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
  byte bVar1;
  LL_EXTI_InitTypeDef *EXTI_InitStruct_local;
  uint32_t status;
  
  status = 0;
  if (EXTI_InitStruct->LineCommand == DISABLE)
  {
    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
    LL_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);
    LL_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);
    return 0;
  }
  if (EXTI_InitStruct->Line_0_31 != 0)
  {
    bVar1 = EXTI_InitStruct->Mode;
    if (bVar1 == 2)
    {
      LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
      LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
    }
    else if (bVar1 < 3)
    {
      if (bVar1 == 0)
      {
        LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
        LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
      }
      else
      {
        if (bVar1 != 1) goto LAB_08010786;
        LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
        LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
      }
    }
    else
    {
LAB_08010786:
      status = 1;
    }
    if (EXTI_InitStruct->Trigger != '\0')
    {
      bVar1 = EXTI_InitStruct->Trigger;
      if (bVar1 == 3)
      {
        LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);
        LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);
      }
      else if (bVar1 < 4)
      {
        if (bVar1 == 1)
        {
          LL_EXTI_DisableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);
          LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);
        }
        else
        {
          if (bVar1 != 2) goto LAB_080107ec;
          LL_EXTI_DisableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);
          LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);
        }
      }
      else
      {
LAB_080107ec:
        status |= 2;
      }
    }
  }
  if (EXTI_InitStruct->Line_32_63 == 0)
  {
    return status;
  }
  bVar1 = EXTI_InitStruct->Mode;
  if (bVar1 == 2)
  {
    LL_EXTI_EnableIT_32_63(EXTI_InitStruct->Line_32_63);
    LL_EXTI_EnableEvent_32_63(EXTI_InitStruct->Line_32_63);
    goto LAB_08010862;
  }
  if (bVar1 < 3)
  {
    if (bVar1 == 0)
    {
      LL_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);
      LL_EXTI_EnableIT_32_63(EXTI_InitStruct->Line_32_63);
      goto LAB_08010862;
    }
    if (bVar1 == 1)
    {
      LL_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);
      LL_EXTI_EnableEvent_32_63(EXTI_InitStruct->Line_32_63);
      goto LAB_08010862;
    }
  }
  status |= 4;
LAB_08010862:
  if (EXTI_InitStruct->Trigger != '\0')
  {
    bVar1 = EXTI_InitStruct->Trigger;
    if (bVar1 == 3)
    {
      LL_EXTI_EnableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);
      LL_EXTI_EnableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);
    }
    else
    {
      if (bVar1 < 4)
      {
        if (bVar1 == 1)
        {
          LL_EXTI_DisableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);
          LL_EXTI_EnableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);
          return status;
        }
        if (bVar1 == 2)
        {
          LL_EXTI_DisableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);
          LL_EXTI_EnableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);
          return status;
        }
      }
      status = 1;
    }
  }
  return status;
}



void LL_EXTI_StructInit(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
  LL_EXTI_InitTypeDef *EXTI_InitStruct_local;
  
  EXTI_InitStruct->Line_0_31 = 0;
  EXTI_InitStruct->Line_32_63 = 0;
  EXTI_InitStruct->LineCommand = DISABLE;
  EXTI_InitStruct->Mode = '\0';
  EXTI_InitStruct->Trigger = '\x02';
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void LL_InitTick(uint32_t HCLKFrequency,uint32_t Ticks)
{
  uint32_t Ticks_local;
  uint32_t HCLKFrequency_local;
  
  _DAT_e000e014 = HCLKFrequency / Ticks - 1;
  _DAT_e000e018 = 0;
  _DAT_e000e010 = 5;
  return;
}



void LL_Init1msTick(uint32_t HCLKFrequency)
{
  uint32_t HCLKFrequency_local;
  
  LL_InitTick(HCLKFrequency,1000);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void LL_mDelay(uint32_t Delay)
{
  uint32_t Delay_local;
  uint32_t tmp;
  uint32_t tmpDelay;
  
  tmpDelay = Delay;
  if (Delay != 0xffffffff)
  {
    tmpDelay = Delay + 1;
  }
  while (tmpDelay != 0)
  {
    if ((_DAT_e000e010 & 0x10000) != 0)
    {
      tmpDelay -= 1;
    }
  }
  return;
}



void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
  uint32_t HCLKFrequency_local;
  
  SystemCoreClock = HCLKFrequency;
  return;
}



HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram,uint32_t Address,uint64_t Data)
{
  uint uVar1;
  uint64_t Data_local;
  uint32_t Address_local;
  uint32_t TypeProgram_local;
  uint32_t prog_bit;
  HAL_StatusTypeDef status;
  
  prog_bit = 0;
  if (pFlash.Lock == HAL_LOCKED)
  {
    status = HAL_BUSY;
  }
  else
  {
    pFlash.Lock = HAL_LOCKED;
    status = FLASH_WaitForLastOperation(50000);
    if (status == HAL_OK)
    {
      pFlash.ErrorCode = 0;
      uVar1 = FLASH.ACR;
      if ((uVar1 & 0x400) == 0)
      {
        pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
      }
      else
      {
        uVar1 = FLASH.ACR;
        FLASH.ACR = uVar1 & 0xfffffbff;
        pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
      }
      if (TypeProgram == 0)
      {
        FLASH_Program_DoubleWord(Address,Data);
        prog_bit = 1;
      }
      else if (((TypeProgram == 1) || (TypeProgram == 2)) &&
              (Data_local._0_4_ = (uint32_t)Data, FLASH_Program_Fast(Address,(uint32_t)Data_local),
              TypeProgram == 2))
      {
        prog_bit = 0x40000;
      }
      status = FLASH_WaitForLastOperation(50000);
      if (prog_bit != 0)
      {
        uVar1 = FLASH.CR;
        FLASH.CR = ~prog_bit & uVar1;
      }
      FLASH_FlushCaches();
    }
    pFlash.Lock = HAL_UNLOCKED;
  }
  return status;
}



// WARNING: Unknown calling convention

HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  uint uVar1;
  HAL_StatusTypeDef status;
  
  status = HAL_OK;
  uVar1 = FLASH.CR;
  if ((int)uVar1 < 0)
  {
    FLASH.KEYR = 0x45670123;
    FLASH.KEYR = 0xcdef89ab;
    uVar1 = FLASH.CR;
    if ((int)uVar1 < 0)
    {
      status = HAL_ERROR;
    }
  }
  return status;
}



// WARNING: Unknown calling convention

HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  uint uVar1;
  
  uVar1 = FLASH.CR;
  FLASH.CR = uVar1 | 0x80000000;
  return HAL_OK;
}



HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
  uint uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint uVar4;
  uint32_t Timeout_local;
  uint32_t error;
  uint32_t tickstart;
  
  uVar2 = HAL_GetTick();
  do
  {
    uVar4 = FLASH.SR;
    if ((uVar4 & 0x10000) == 0)
    {
      uVar4 = FLASH.SR;
      uVar4 &= 0xc3fa;
      if (uVar4 != 0)
      {
        if (false)
        {
          uVar1 = FLASH.ECCR;
          FLASH.ECCR = uVar1;
        }
        if (uVar4 != 0)
        {
          FLASH.SR = uVar4;
        }
        pFlash.ErrorCode = uVar4 | pFlash.ErrorCode;
        return HAL_ERROR;
      }
      uVar4 = FLASH.SR;
      if ((uVar4 & 1) != 0)
      {
        FLASH.SR = 1;
      }
      return HAL_OK;
    }
  } while ((Timeout == 0xffffffff) || (uVar3 = HAL_GetTick(), uVar3 - uVar2 < Timeout));
  return HAL_TIMEOUT;
}



void FLASH_Program_DoubleWord(uint32_t Address,uint64_t Data)
{
  uint uVar1;
  uint64_t Data_local;
  uint32_t Address_local;
  
  uVar1 = FLASH.CR;
  FLASH.CR = uVar1 | 1;
  Data_local._0_4_ = (undefined4)Data;
  *(undefined4 *)Address = (undefined4)Data_local;
  InstructionSynchronizationBarrier(0xf);
  Data_local._4_4_ = (undefined4)(Data >> 0x20);
  *(undefined4 *)(Address + 4) = Data_local._4_4_;
  return;
}



void FLASH_Program_Fast(uint32_t Address,uint32_t DataAddress)
{
  bool bVar1;
  uint uVar2;
  uint32_t DataAddress_local;
  uint32_t Address_local;
  uint32_t result;
  uint32_t primask_bit;
  uint32_t *src_addr;
  uint32_t *dest_addr;
  uint8_t row_index;
  
  row_index = '@';
  uVar2 = FLASH.CR;
  FLASH.CR = uVar2 | 0x40000;
  uVar2 = 0;
  bVar1 = (bool)isCurrentModePrivileged();
  if (bVar1)
  {
    uVar2 = isIRQinterruptsEnabled();
  }
  disableIRQinterrupts();
  src_addr = (uint32_t *)DataAddress;
  dest_addr = (uint32_t *)Address;
  do
  {
    *dest_addr = *src_addr;
    dest_addr = dest_addr + 1;
    src_addr = src_addr + 1;
    row_index += 0xff;
  } while (row_index != '\0');
  bVar1 = (bool)isCurrentModePrivileged();
  if (bVar1)
  {
    enableIRQinterrupts((uVar2 & 1) == 1);
  }
  return;
}



HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit,uint32_t *PageError)
{
  uint uVar1;
  uint32_t *PageError_local;
  FLASH_EraseInitTypeDef *pEraseInit_local;
  uint32_t page_index;
  HAL_StatusTypeDef status;
  
  if (pFlash.Lock == HAL_LOCKED)
  {
    status = HAL_BUSY;
  }
  else
  {
    pFlash.Lock = HAL_LOCKED;
    status = FLASH_WaitForLastOperation(50000);
    if (status == HAL_OK)
    {
      pFlash.ErrorCode = 0;
      uVar1 = FLASH.ACR;
      if ((uVar1 & 0x200) == 0)
      {
        uVar1 = FLASH.ACR;
        if ((uVar1 & 0x400) == 0)
        {
          pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
        }
        else
        {
          uVar1 = FLASH.ACR;
          FLASH.ACR = uVar1 & 0xfffffbff;
          pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
        }
      }
      else
      {
        uVar1 = FLASH.ACR;
        if ((uVar1 & 0x400) == 0)
        {
          pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;
        }
        else
        {
          uVar1 = FLASH.ACR;
          FLASH.ACR = uVar1 & 0xfffffbff;
          pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
        }
      }
      if (pEraseInit->TypeErase == 1)
      {
        FLASH_MassErase(pEraseInit->Banks);
        status = FLASH_WaitForLastOperation(50000);
        uVar1 = FLASH.CR;
        FLASH.CR = uVar1 & 0xffff7ffb;
      }
      else
      {
        *PageError = 0xffffffff;
        for (page_index = pEraseInit->Page; page_index < pEraseInit->NbPages + pEraseInit->Page;
            page_index += 1)
        {
          FLASH_PageErase(page_index,pEraseInit->Banks);
          status = FLASH_WaitForLastOperation(50000);
          uVar1 = FLASH.CR;
          FLASH.CR = uVar1 & 0xfffff805;
          if (status != HAL_OK)
          {
            *PageError = page_index;
            break;
          }
        }
      }
      FLASH_FlushCaches();
    }
    pFlash.Lock = HAL_UNLOCKED;
  }
  return status;
}



void FLASH_MassErase(uint32_t Banks)
{
  uint uVar1;
  uint32_t Banks_local;
  
  if ((Banks & 1) != 0)
  {
    uVar1 = FLASH.CR;
    FLASH.CR = uVar1 | 4;
  }
  if ((Banks & 2) != 0)
  {
    uVar1 = FLASH.CR;
    FLASH.CR = uVar1 | 0x8000;
  }
  uVar1 = FLASH.CR;
  FLASH.CR = uVar1 | 0x10000;
  return;
}



void FLASH_PageErase(uint32_t Page,uint32_t Banks)
{
  uint uVar1;
  uint32_t Banks_local;
  uint32_t Page_local;
  
  if ((Banks & 1) == 0)
  {
    uVar1 = FLASH.CR;
    FLASH.CR = uVar1 | 0x800;
  }
  else
  {
    uVar1 = FLASH.CR;
    FLASH.CR = uVar1 & 0xfffff7ff;
  }
  uVar1 = FLASH.CR;
  FLASH.CR = (Page & 0xff) << 3 | uVar1 & 0xfffff807;
  uVar1 = FLASH.CR;
  FLASH.CR = uVar1 | 2;
  uVar1 = FLASH.CR;
  FLASH.CR = uVar1 | 0x10000;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FLASH_FlushCaches(void)
{
  uint uVar1;
  FLASH_CacheTypeDef cache;
  
  if ((pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_ENABLED) ||
     (pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 & 0xfffffdff;
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 | 0x800;
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 & 0xfffff7ff;
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 | 0x200;
  }
  if ((pFlash.CacheToReactivate == FLASH_CACHE_DCACHE_ENABLED) ||
     (pFlash.CacheToReactivate == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 | 0x1000;
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 & 0xffffefff;
    uVar1 = FLASH.ACR;
    FLASH.ACR = uVar1 | 0x400;
  }
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
  return;
}



// WARNING: Unknown calling convention

uint32_t HAL_GetTick(void)
{
  return uwTick;
}



void LL_SPI_Enable(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  SPIx->CR1 = SPIx->CR1 | 0x40;
  return;
}



uint32_t LL_SPI_IsEnabled(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  return (uint)((SPIx->CR1 & 0x40) == 0x40);
}



void LL_SPI_SetStandard(SPI_TypeDef *SPIx,uint32_t Standard)
{
  uint32_t Standard_local;
  SPI_TypeDef *SPIx_local;
  
  SPIx->CR2 = SPIx->CR2 & 0xffffffef | Standard;
  return;
}



void LL_SPI_SetRxFIFOThreshold(SPI_TypeDef *SPIx,uint32_t Threshold)
{
  uint32_t Threshold_local;
  SPI_TypeDef *SPIx_local;
  
  SPIx->CR2 = SPIx->CR2 & 0xffffefff | Threshold;
  return;
}



void LL_SPI_DisableNSSPulseMgt(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  SPIx->CR2 = SPIx->CR2 & 0xfffffff7;
  return;
}



uint32_t LL_SPI_IsActiveFlag_RXNE(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  return (uint)((SPIx->SR & 1) == 1);
}



uint32_t LL_SPI_IsActiveFlag_TXE(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  return (uint)((SPIx->SR & 2) == 2);
}



uint8_t LL_SPI_ReceiveData8(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  return (uint8_t)SPIx->DR;
}



uint16_t LL_SPI_ReceiveData16(SPI_TypeDef *SPIx)
{
  SPI_TypeDef *SPIx_local;
  
  return (uint16_t)SPIx->DR;
}



void LL_SPI_TransmitData8(SPI_TypeDef *SPIx,uint8_t TxData)
{
  uint8_t TxData_local;
  SPI_TypeDef *SPIx_local;
  uint8_t *spidr;
  
  *(uint8_t *)&SPIx->DR = TxData;
  return;
}



void LL_SPI_TransmitData16(SPI_TypeDef *SPIx,uint16_t TxData)
{
  uint16_t TxData_local;
  SPI_TypeDef *SPIx_local;
  uint16_t *spidr;
  
  *(uint16_t *)&SPIx->DR = TxData;
  return;
}



void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.AHB2ENR;
  RCC.AHB2ENR = Periphs | uVar1;
  uVar1 = RCC.AHB2ENR;
  return;
}



void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.APB1ENR1;
  RCC.APB1ENR1 = Periphs | uVar1;
  uVar1 = RCC.APB1ENR1;
  return;
}



void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.APB2ENR;
  RCC.APB2ENR = Periphs | uVar1;
  uVar1 = RCC.APB2ENR;
  return;
}



uint32_t LL_DMA_IsActiveFlag_TC1(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 2) == 2);
}



uint32_t LL_DMA_IsActiveFlag_TC2(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x20) == 0x20);
}



uint32_t LL_DMA_IsActiveFlag_TC3(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x200) == 0x200);
}



uint32_t LL_DMA_IsActiveFlag_TC4(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x2000) == 0x2000);
}



uint32_t LL_DMA_IsActiveFlag_TC5(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x20000) == 0x20000);
}



uint32_t LL_DMA_IsActiveFlag_TE1(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 8) == 8);
}



uint32_t LL_DMA_IsActiveFlag_TE2(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x80) == 0x80);
}



uint32_t LL_DMA_IsActiveFlag_TE3(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x800) == 0x800);
}



uint32_t LL_DMA_IsActiveFlag_TE4(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x8000) == 0x8000);
}



uint32_t LL_DMA_IsActiveFlag_TE5(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x80000) == 0x80000);
}



void LL_DMA_ClearFlag_GI1(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 1;
  return;
}



void LL_DMA_ClearFlag_GI2(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x10;
  return;
}



void LL_DMA_ClearFlag_GI3(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x100;
  return;
}



void LL_DMA_ClearFlag_GI4(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x1000;
  return;
}



void LL_DMA_ClearFlag_GI5(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x10000;
  return;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_spi_init
          (smtc_hal_mcu_spi_cfg_t cfg,smtc_hal_mcu_spi_cfg_app_t *cfg_app,
          smtc_hal_mcu_spi_inst_t *inst)
{
  ErrorStatus EVar1;
  smtc_hal_mcu_spi_inst_s *psVar2;
  uint32_t uVar3;
  smtc_hal_mcu_status_t sVar4;
  smtc_hal_mcu_spi_inst_t *inst_local;
  smtc_hal_mcu_spi_cfg_app_t *cfg_app_local;
  smtc_hal_mcu_spi_cfg_t cfg_local;
  LL_GPIO_InitTypeDef GPIO_InitStruct_2;
  LL_GPIO_InitTypeDef GPIO_InitStruct_1;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  LL_SPI_InitTypeDef SPI_InitStruct;
  smtc_hal_mcu_spi_inst_s *spi_cfg_slot;
  
  psVar2 = smtc_hal_mcu_spi_stm32l4_get_free_slot();
  if (psVar2 == (smtc_hal_mcu_spi_inst_s *)0x0)
  {
    sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
  }
  else
  {
    psVar2->spi = cfg->spi;
    if ((SPI1 *)psVar2->spi == &SPI1)
    {
      LL_APB2_GRP1_EnableClock(0x1000);
      LL_AHB2_GRP1_EnableClock(1);
      GPIO_InitStruct.Pin = 0xe0;
      GPIO_InitStruct.Mode = 2;
      GPIO_InitStruct.Speed = 3;
      GPIO_InitStruct.OutputType = 0;
      GPIO_InitStruct.Pull = 0;
      GPIO_InitStruct.Alternate = 5;
      LL_GPIO_Init((GPIO_TypeDef *)&GPIOA,&GPIO_InitStruct);
    }
    else if ((SPI2 *)psVar2->spi == &SPI2)
    {
      LL_APB1_GRP1_EnableClock(0x4000);
      LL_AHB2_GRP1_EnableClock(2);
      GPIO_InitStruct_1.Pin = 0xe000;
      GPIO_InitStruct_1.Mode = 2;
      GPIO_InitStruct_1.Speed = 3;
      GPIO_InitStruct_1.OutputType = 0;
      GPIO_InitStruct_1.Pull = 0;
      GPIO_InitStruct_1.Alternate = 5;
      LL_GPIO_Init((GPIO_TypeDef *)&GPIOB,&GPIO_InitStruct_1);
    }
    else
    {
      if ((SPI3 *)psVar2->spi != &SPI3)
      {
        return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
      }
      LL_APB1_GRP1_EnableClock(0x8000);
      LL_AHB2_GRP1_EnableClock(4);
      GPIO_InitStruct_2.Pin = 0x1c00;
      GPIO_InitStruct_2.Mode = 2;
      GPIO_InitStruct_2.Speed = 3;
      GPIO_InitStruct_2.OutputType = 0;
      GPIO_InitStruct_2.Pull = 0;
      GPIO_InitStruct_2.Alternate = 6;
      LL_GPIO_Init((GPIO_TypeDef *)&GPIOC,&GPIO_InitStruct_2);
    }
    SPI_InitStruct.TransferDirection = 0;
    if (cfg_app->is_master == false)
    {
      SPI_InitStruct.Mode = 0;
    }
    else
    {
      SPI_InitStruct.Mode = 0x104;
    }
    SPI_InitStruct.DataWidth = 0x700;
    SPI_InitStruct.ClockPolarity = 0;
    SPI_InitStruct.ClockPhase = 0;
    SPI_InitStruct.NSS = 0x200;
    SPI_InitStruct.BaudRate = 0x18;
    SPI_InitStruct.BitOrder = 0;
    SPI_InitStruct.CRCCalculation = 0;
    SPI_InitStruct.CRCPoly = 7;
    EVar1 = LL_SPI_Init(psVar2->spi,&SPI_InitStruct);
    if (EVar1 == SUCCESS)
    {
      LL_SPI_SetRxFIFOThreshold(psVar2->spi,0x1000);
      LL_SPI_SetStandard(psVar2->spi,0);
      LL_SPI_DisableNSSPulseMgt(psVar2->spi);
      LL_SPI_Enable(psVar2->spi);
      do
      {
        uVar3 = LL_SPI_IsEnabled(psVar2->spi);
      } while (uVar3 == 0);
      psVar2->is_cfged = true;
      psVar2->dma_periph_mapping = (smtc_hal_mcu_spi_stm32l4_dma_periph_mapping_t *)0x0;
      *inst = psVar2;
      sVar4 = SMTC_HAL_MCU_STATUS_OK;
    }
    else
    {
      sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
    }
  }
  return sVar4;
}



smtc_hal_mcu_status_t smtc_hal_mcu_spi_deinit(smtc_hal_mcu_spi_inst_t *inst)
{
  _Bool _Var1;
  ErrorStatus EVar2;
  smtc_hal_mcu_status_t sVar3;
  smtc_hal_mcu_spi_inst_t inst_00;
  smtc_hal_mcu_spi_inst_t *inst_local_1;
  LL_GPIO_InitTypeDef GPIO_InitStruct_1;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  smtc_hal_mcu_spi_inst_t inst_local;
  
  inst_00 = *inst;
  _Var1 = smtc_hal_mcu_spi_stm32l4_is_real_inst(inst_00);
  if (_Var1)
  {
    if (inst_00->is_cfged == true)
    {
      if ((SPI1 *)inst_00->spi == &SPI1)
      {
        EVar2 = LL_SPI_DeInit(inst_00->spi);
        if (EVar2 != SUCCESS)
        {
          return SMTC_HAL_MCU_STATUS_ERROR;
        }
        GPIO_InitStruct.Pin = 0xe0;
        GPIO_InitStruct.Mode = 3;
        GPIO_InitStruct.Speed = 0;
        GPIO_InitStruct.OutputType = 1;
        GPIO_InitStruct.Pull = 0;
        GPIO_InitStruct.Alternate = 0;
        EVar2 = LL_GPIO_Init((GPIO_TypeDef *)&GPIOA,&GPIO_InitStruct);
        if (EVar2 != SUCCESS)
        {
          return SMTC_HAL_MCU_STATUS_ERROR;
        }
      }
      else
      {
        if ((SPI3 *)inst_00->spi != &SPI3)
        {
          return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
        }
        EVar2 = LL_SPI_DeInit(inst_00->spi);
        if (EVar2 != SUCCESS)
        {
          return SMTC_HAL_MCU_STATUS_ERROR;
        }
        GPIO_InitStruct_1.Pin = 0x1c00;
        GPIO_InitStruct_1.Mode = 3;
        GPIO_InitStruct_1.Speed = 0;
        GPIO_InitStruct_1.OutputType = 1;
        GPIO_InitStruct_1.Pull = 0;
        GPIO_InitStruct_1.Alternate = 0;
        EVar2 = LL_GPIO_Init((GPIO_TypeDef *)&GPIOC,&GPIO_InitStruct_1);
        if (EVar2 != SUCCESS)
        {
          return SMTC_HAL_MCU_STATUS_ERROR;
        }
      }
      inst_00->is_cfged = false;
      *inst = (smtc_hal_mcu_spi_inst_t)0x0;
      sVar3 = SMTC_HAL_MCU_STATUS_OK;
    }
    else
    {
      sVar3 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar3 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar3;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_spi_rw_buffer
          (smtc_hal_mcu_spi_inst_t inst,uint8_t *data_out,uint8_t *data_in,uint16_t data_length)
{
  _Bool _Var1;
  uint8_t uVar2;
  uint16_t uVar3;
  uint32_t uVar4;
  smtc_hal_mcu_status_t sVar5;
  uint16_t data_length_local;
  uint8_t *data_in_local;
  uint8_t *data_out_local;
  smtc_hal_mcu_spi_inst_t inst_local;
  uint16_t bytes_received;
  uint8_t byte_received;
  uint16_t bytes_to_transmit;
  uint8_t byte_to_transmit;
  uint16_t rem_bytes_to_receive;
  uint16_t rem_bytes_to_send;
  
  _Var1 = smtc_hal_mcu_spi_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    if (inst->is_cfged == true)
    {
      rem_bytes_to_receive = data_length;
      rem_bytes_to_send = data_length;
      if (data_length < 2)
      {
        LL_SPI_SetRxFIFOThreshold(inst->spi,0x1000);
      }
      else
      {
        LL_SPI_SetRxFIFOThreshold(inst->spi,0);
      }
      while ((rem_bytes_to_send != 0 || (rem_bytes_to_receive != 0)))
      {
        uVar4 = LL_SPI_IsActiveFlag_TXE(inst->spi);
        if ((uVar4 == 1) && (rem_bytes_to_send != 0))
        {
          if (rem_bytes_to_send < 2)
          {
            if (data_out == (uint8_t *)0x0)
            {
              uVar2 = '\0';
            }
            else
            {
              uVar2 = data_out[(uint)data_length - (uint)rem_bytes_to_send];
            }
            LL_SPI_TransmitData8(inst->spi,uVar2);
            rem_bytes_to_send -= 1;
          }
          else
          {
            if (data_out == (uint8_t *)0x0)
            {
              uVar3 = 0;
            }
            else
            {
              uVar3 = (ushort)data_out[(uint)data_length - (uint)rem_bytes_to_send] +
                      (ushort)data_out[((uint)data_length - (uint)rem_bytes_to_send) + 1] * 0x100;
            }
            LL_SPI_TransmitData16(inst->spi,uVar3);
            rem_bytes_to_send -= 2;
          }
        }
        uVar4 = LL_SPI_IsActiveFlag_RXNE(inst->spi);
        if ((uVar4 == 1) && (rem_bytes_to_receive != 0))
        {
          if (rem_bytes_to_receive < 2)
          {
            uVar2 = LL_SPI_ReceiveData8(inst->spi);
            if (data_in != (uint8_t *)0x0)
            {
              data_in[(uint)data_length - (uint)rem_bytes_to_receive] = uVar2;
            }
            rem_bytes_to_receive -= 1;
          }
          else
          {
            uVar3 = LL_SPI_ReceiveData16(inst->spi);
            if (data_in != (uint8_t *)0x0)
            {
              data_in[((uint)data_length - (uint)rem_bytes_to_receive) + 1] = (uint8_t)(uVar3 >> 8);
              data_in[(uint)data_length - (uint)rem_bytes_to_receive] = (uint8_t)uVar3;
            }
            rem_bytes_to_receive -= 2;
            if (rem_bytes_to_receive == 1)
            {
              LL_SPI_SetRxFIFOThreshold(inst->spi,0x1000);
            }
          }
        }
      }
      sVar5 = SMTC_HAL_MCU_STATUS_OK;
    }
    else
    {
      sVar5 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar5 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar5;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_spi_inst_s * smtc_hal_mcu_spi_stm32l4_get_free_slot(void)
{
  int i;
  
  i = 0;
  while( true )
  {
    if (3 < i)
    {
      return (smtc_hal_mcu_spi_inst_s *)0x0;
    }
    if (spi_inst_array[i].is_cfged != true) break;
    i += 1;
  }
  return spi_inst_array + i;
}



_Bool smtc_hal_mcu_spi_stm32l4_is_real_inst(smtc_hal_mcu_spi_inst_t inst)
{
  smtc_hal_mcu_spi_inst_t inst_local;
  int i;
  
  i = 0;
  while( true )
  {
    if (3 < i)
    {
      return false;
    }
    if (inst == spi_inst_array + i) break;
    i += 1;
  }
  return true;
}



uint32_t smtc_hal_mcu_spi_stm32l4_is_active_flag_tc(uint32_t channel,DMA_TypeDef *dma)
{
  uint32_t uVar1;
  DMA_TypeDef *dma_local;
  uint32_t channel_local;
  
  switch(channel)
  {
  case 0:
    uVar1 = LL_DMA_IsActiveFlag_TC1(dma);
    break;
  case 1:
    uVar1 = LL_DMA_IsActiveFlag_TC2(dma);
    break;
  case 2:
    uVar1 = LL_DMA_IsActiveFlag_TC3(dma);
    break;
  case 3:
    uVar1 = LL_DMA_IsActiveFlag_TC4(dma);
    break;
  case 4:
    uVar1 = LL_DMA_IsActiveFlag_TC5(dma);
    break;
  default:
    uVar1 = 0;
  }
  return uVar1;
}



void smtc_hal_mcu_spi_stm32l4_clear_flag_gi(uint32_t channel,DMA_TypeDef *dma)
{
  DMA_TypeDef *dma_local;
  uint32_t channel_local;
  
  switch(channel)
  {
  case 0:
    LL_DMA_ClearFlag_GI1(dma);
    break;
  case 1:
    LL_DMA_ClearFlag_GI2(dma);
    break;
  case 2:
    LL_DMA_ClearFlag_GI3(dma);
    break;
  case 3:
    LL_DMA_ClearFlag_GI4(dma);
    break;
  case 4:
    LL_DMA_ClearFlag_GI5(dma);
  }
  return;
}



uint32_t smtc_hal_mcu_spi_stm32l4_is_active_flag_te(uint32_t channel,DMA_TypeDef *dma)
{
  uint32_t uVar1;
  DMA_TypeDef *dma_local;
  uint32_t channel_local;
  
  switch(channel)
  {
  case 0:
    uVar1 = LL_DMA_IsActiveFlag_TE1(dma);
    break;
  case 1:
    uVar1 = LL_DMA_IsActiveFlag_TE2(dma);
    break;
  case 2:
    uVar1 = LL_DMA_IsActiveFlag_TE3(dma);
    break;
  case 3:
    uVar1 = LL_DMA_IsActiveFlag_TE4(dma);
    break;
  case 4:
    uVar1 = LL_DMA_IsActiveFlag_TE5(dma);
    break;
  default:
    uVar1 = 0;
  }
  return uVar1;
}



void smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq(DMA_TypeDef *dma,uint32_t channel)
{
  uint32_t uVar1;
  uint32_t channel_local;
  DMA_TypeDef *dma_local;
  smtc_hal_mcu_spi_inst_t local_instance;
  int i;
  
  i = 0;
  do
  {
    if (3 < i)
    {
      return;
    }
    if ((spi_inst_array[i].is_cfged != false) &&
       (spi_inst_array[i].dma_periph_mapping != (smtc_hal_mcu_spi_stm32l4_dma_periph_mapping_t *)0x0
       ))
    {
      if ((dma == (spi_inst_array[i].dma_periph_mapping)->dma) &&
         (uVar1 = smtc_hal_mcu_spi_stm32l4_is_active_flag_tc(channel,dma), uVar1 != 0))
      {
        smtc_hal_mcu_spi_stm32l4_clear_flag_gi(channel,dma);
        if (channel == (spi_inst_array[i].dma_periph_mapping)->dma_channel_rx)
        {
          if (spi_inst_array[i].DMAcallback_rx == (_func_void *)0x0)
          {
            return;
          }
          (*spi_inst_array[i].DMAcallback_rx)();
          return;
        }
        if (channel == (spi_inst_array[i].dma_periph_mapping)->dma_channel_tx)
        {
          if (spi_inst_array[i].DMAcallback_tx == (_func_void *)0x0)
          {
            return;
          }
          (*spi_inst_array[i].DMAcallback_tx)();
          return;
        }
      }
      uVar1 = smtc_hal_mcu_spi_stm32l4_is_active_flag_te(channel,dma);
      if (uVar1 != 0)
      {
        if (channel == (spi_inst_array[i].dma_periph_mapping)->dma_channel_rx)
        {
          if (spi_inst_array[i].DMAcallback_rx_error == (_func_void *)0x0)
          {
            return;
          }
          (*spi_inst_array[i].DMAcallback_rx_error)();
          return;
        }
        if (channel == (spi_inst_array[i].dma_periph_mapping)->dma_channel_tx)
        {
          if (spi_inst_array[i].DMAcallback_tx_error == (_func_void *)0x0)
          {
            return;
          }
          (*spi_inst_array[i].DMAcallback_tx_error)();
          return;
        }
      }
    }
    i += 1;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA1_Channel2_IRQHandler(void)
{
  smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq((DMA_TypeDef *)&DMA1,1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA1_Channel3_IRQHandler(void)
{
  smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq((DMA_TypeDef *)&DMA1,2);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA1_Channel4_IRQHandler(void)
{
  smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq((DMA_TypeDef *)&DMA1,3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA1_Channel5_IRQHandler(void)
{
  smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq((DMA_TypeDef *)&DMA1,4);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA2_Channel1_IRQHandler(void)
{
  smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq((DMA_TypeDef *)&DMA2,0);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA2_Channel2_IRQHandler(void)
{
  smtc_hal_mcu_spi_stm32l4_call_dma_callback_irq((DMA_TypeDef *)&DMA2,1);
  return;
}



void LL_I2C_Enable(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->CR1 = I2Cx->CR1 | 1;
  return;
}



uint32_t LL_I2C_IsEnabled(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  return (uint)((I2Cx->CR1 & 1) == 1);
}



uint32_t LL_I2C_IsActiveFlag_TXIS(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  return (uint)((I2Cx->ISR & 2) == 2);
}



uint32_t LL_I2C_IsActiveFlag_NACK(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  return (uint)((I2Cx->ISR & 0x10) == 0x10);
}



uint32_t LL_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  return (uint)((I2Cx->ISR & 0x20) == 0x20);
}



void LL_I2C_ClearFlag_NACK(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->ICR = I2Cx->ICR | 0x10;
  return;
}



void LL_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx)
{
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->ICR = I2Cx->ICR | 0x20;
  return;
}



void LL_I2C_HandleTransfer
               (I2C_TypeDef *I2Cx,uint32_t SlaveAddr,uint32_t SlaveAddrSize,uint32_t TransferSize,
               uint32_t EndMode,uint32_t Request)
{
  uint32_t TransferSize_local;
  uint32_t SlaveAddrSize_local;
  uint32_t SlaveAddr_local;
  I2C_TypeDef *I2Cx_local;
  uint32_t tmp;
  
  I2Cx->CR2 = I2Cx->CR2 & ~(Request >> 0x15 & 0x400 | 0x3ff7bff) |
              (Request |
              SlaveAddr & 0x3ff | SlaveAddrSize & 0x800 | (TransferSize & 0xff) << 0x10 | EndMode) &
              0x7fffffff;
  return;
}



void LL_I2C_TransmitData8(I2C_TypeDef *I2Cx,uint8_t Data)
{
  uint8_t Data_local;
  I2C_TypeDef *I2Cx_local;
  
  I2Cx->TXDR = (uint)Data;
  return;
}



void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.AHB2ENR;
  RCC.AHB2ENR = Periphs | uVar1;
  uVar1 = RCC.AHB2ENR;
  return;
}



void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.APB1ENR1;
  RCC.APB1ENR1 = Periphs | uVar1;
  uVar1 = RCC.APB1ENR1;
  return;
}



void LL_RCC_SetI2CClockSource(uint32_t I2CxSource)
{
  uint *puVar1;
  uint32_t I2CxSource_local;
  uint32_t *reg;
  
  puVar1 = (uint *)((int)&RCC.CCIPR + (I2CxSource >> 0x18));
  *puVar1 = *puVar1 & ~(3 << (I2CxSource >> 0x10 & 0x1f)) |
            (I2CxSource & 0xff) << (I2CxSource >> 0x10 & 0x1f);
  return;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_i2c_init(smtc_hal_mcu_i2c_cfg_t cfg,smtc_hal_mcu_i2c_inst_t *inst)
{
  ErrorStatus EVar1;
  smtc_hal_mcu_i2c_inst_s *psVar2;
  uint32_t uVar3;
  smtc_hal_mcu_status_t sVar4;
  smtc_hal_mcu_i2c_inst_t *inst_local;
  smtc_hal_mcu_i2c_cfg_t cfg_local;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  LL_I2C_InitTypeDef I2C_InitStruct;
  smtc_hal_mcu_i2c_inst_s *i2c_cfg_slot;
  
  psVar2 = smtc_hal_mcu_i2c_stm32l4_get_free_slot();
  if (psVar2 == (smtc_hal_mcu_i2c_inst_s *)0x0)
  {
    sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
  }
  else
  {
    psVar2->i2c = cfg->i2c;
    if ((I2C1 *)psVar2->i2c == &I2C1)
    {
      LL_APB1_GRP1_EnableClock(0x200000);
      LL_AHB2_GRP1_EnableClock(2);
      LL_RCC_SetI2CClockSource(0xc0001);
      GPIO_InitStruct.Pin = 0x300;
      GPIO_InitStruct.Mode = 2;
      GPIO_InitStruct.Speed = 3;
      GPIO_InitStruct.OutputType = 1;
      GPIO_InitStruct.Pull = 1;
      GPIO_InitStruct.Alternate = 4;
      LL_GPIO_Init((GPIO_TypeDef *)&GPIOB,&GPIO_InitStruct);
      I2C_InitStruct.PeripheralMode = 0;
      I2C_InitStruct.Timing = 0x300f33;
      I2C_InitStruct.AnalogFilter = 0;
      I2C_InitStruct.DigitalFilter = 0;
      I2C_InitStruct.OwnAddress1 = 0;
      I2C_InitStruct.TypeAcknowledge = 0;
      I2C_InitStruct.OwnAddrSize = 0;
      EVar1 = LL_I2C_Init(psVar2->i2c,&I2C_InitStruct);
      if (EVar1 == SUCCESS)
      {
        LL_I2C_Enable(psVar2->i2c);
        do
        {
          uVar3 = LL_I2C_IsEnabled(psVar2->i2c);
        } while (uVar3 == 0);
        psVar2->is_cfged = true;
        psVar2->current_nacks_in_a_row = '\0';
        psVar2->max_nacks_in_a_row = cfg->max_nacks_in_a_row;
        *inst = psVar2;
        sVar4 = SMTC_HAL_MCU_STATUS_OK;
      }
      else
      {
        sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
      }
    }
    else
    {
      sVar4 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
  }
  return sVar4;
}



smtc_hal_mcu_status_t smtc_hal_mcu_i2c_deinit(smtc_hal_mcu_i2c_inst_t *inst)
{
  _Bool _Var1;
  ErrorStatus EVar2;
  smtc_hal_mcu_status_t sVar3;
  smtc_hal_mcu_i2c_inst_t inst_00;
  smtc_hal_mcu_i2c_inst_t *inst_local_1;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  smtc_hal_mcu_i2c_inst_t inst_local;
  
  inst_00 = *inst;
  _Var1 = smtc_hal_mcu_i2c_stm32l4_is_real_inst(inst_00);
  if (_Var1)
  {
    if (inst_00->is_cfged == true)
    {
      if ((I2C1 *)inst_00->i2c == &I2C1)
      {
        EVar2 = LL_I2C_DeInit(inst_00->i2c);
        if (EVar2 == SUCCESS)
        {
          GPIO_InitStruct.Pin = 0x300;
          GPIO_InitStruct.Mode = 3;
          GPIO_InitStruct.Speed = 0;
          GPIO_InitStruct.OutputType = 1;
          GPIO_InitStruct.Pull = 0;
          GPIO_InitStruct.Alternate = 0;
          EVar2 = LL_GPIO_Init((GPIO_TypeDef *)&GPIOB,&GPIO_InitStruct);
          if (EVar2 == SUCCESS)
          {
            inst_00->max_nacks_in_a_row = '\0';
            inst_00->current_nacks_in_a_row = '\0';
            inst_00->is_cfged = false;
            *inst = (smtc_hal_mcu_i2c_inst_t)0x0;
            sVar3 = SMTC_HAL_MCU_STATUS_OK;
          }
          else
          {
            sVar3 = SMTC_HAL_MCU_STATUS_ERROR;
          }
        }
        else
        {
          sVar3 = SMTC_HAL_MCU_STATUS_ERROR;
        }
      }
      else
      {
        sVar3 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
      }
    }
    else
    {
      sVar3 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar3 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar3;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_i2c_write_buffer
          (smtc_hal_mcu_i2c_inst_t inst,smtc_hal_mcu_i2c_address_format_t address_format,
          uint16_t device_addr,uint8_t *data_out,uint16_t data_length)
{
  _Bool _Var1;
  uint32_t uVar2;
  smtc_hal_mcu_status_t sVar3;
  uint uVar4;
  uint8_t *data_out_local;
  uint16_t device_addr_local;
  smtc_hal_mcu_i2c_address_format_t address_format_local;
  smtc_hal_mcu_i2c_inst_t inst_local;
  int address_format_mcu;
  uint8_t i;
  
  _Var1 = smtc_hal_mcu_i2c_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    if (inst->is_cfged == true)
    {
      i = '\0';
      uVar2 = smtc_hal_mcu_i2c_stm32l4_get_address_parameter(address_format);
      LL_I2C_HandleTransfer
                (inst->i2c,(uint)device_addr,uVar2,(uint)data_length,0x2000000,0x80002000);
      while (uVar2 = LL_I2C_IsActiveFlag_STOP(inst->i2c), uVar2 == 0)
      {
        uVar2 = LL_I2C_IsActiveFlag_TXIS(inst->i2c);
        if (uVar2 != 0)
        {
          uVar4 = (uint)i;
          i += '\x01';
          LL_I2C_TransmitData8(inst->i2c,data_out[uVar4]);
        }
      }
      LL_I2C_ClearFlag_STOP(inst->i2c);
      uVar2 = LL_I2C_IsActiveFlag_NACK(inst->i2c);
      if (uVar2 == 0)
      {
        inst->current_nacks_in_a_row = '\0';
      }
      else
      {
        LL_I2C_ClearFlag_NACK(inst->i2c);
        if ((inst->max_nacks_in_a_row != '\0') &&
           (inst->current_nacks_in_a_row = inst->current_nacks_in_a_row + '\x01',
           inst->max_nacks_in_a_row <= inst->current_nacks_in_a_row))
        {
          return SMTC_HAL_MCU_STATUS_ERROR;
        }
      }
      sVar3 = SMTC_HAL_MCU_STATUS_OK;
    }
    else
    {
      sVar3 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar3 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar3;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_i2c_inst_s * smtc_hal_mcu_i2c_stm32l4_get_free_slot(void)
{
  int i;
  
  i = 0;
  while( true )
  {
    if (1 < i)
    {
      return (smtc_hal_mcu_i2c_inst_s *)0x0;
    }
    if (i2c_inst_array[i].is_cfged != true) break;
    i += 1;
  }
  return i2c_inst_array + i;
}



_Bool smtc_hal_mcu_i2c_stm32l4_is_real_inst(smtc_hal_mcu_i2c_inst_t inst)
{
  smtc_hal_mcu_i2c_inst_t inst_local;
  int i;
  
  i = 0;
  while( true )
  {
    if (1 < i)
    {
      return false;
    }
    if (inst == i2c_inst_array + i) break;
    i += 1;
  }
  return true;
}



int smtc_hal_mcu_i2c_stm32l4_get_address_parameter(smtc_hal_mcu_i2c_address_format_t address_format)
{
  int iVar1;
  smtc_hal_mcu_i2c_address_format_t address_format_local;
  
  if (address_format == SMTC_HAL_MCU_I2C_ADDRESS_FORMAT_7_BITS)
  {
    iVar1 = 0;
  }
  else if (address_format == SMTC_HAL_MCU_I2C_ADDRESS_FORMAT_10_BITS)
  {
    iVar1 = 0x800;
  }
  else
  {
    iVar1 = 0;
  }
  return iVar1;
}



void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  IRQn_Type IRQn_local;
  
  if (SysTick_IRQn < IRQn)
  {
    *(int *)(((uint)(int)IRQn >> 5) * 4 + -0x1fff1f00) = 1 << (IRQn & I2C1_EV_IRQn);
  }
  return;
}



void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  IRQn_Type IRQn_local;
  
  if (SysTick_IRQn < IRQn)
  {
    *(int *)((((uint)(int)IRQn >> 5) + 0x20) * 4 + -0x1fff1f00) = 1 << (IRQn & I2C1_EV_IRQn);
    DataSynchronizationBarrier(0xf);
    InstructionSynchronizationBarrier(0xf);
  }
  return;
}



void __NVIC_SetPriority(IRQn_Type IRQn,uint32_t priority)
{
  uint32_t priority_local;
  IRQn_Type IRQn_local;
  
  if (IRQn < WWDG_IRQn)
  {
    *(char *)(((byte)IRQn & 0xf) + 0xe000ed14) = (char)((priority & 0xff) << 4);
  }
  else
  {
    *(char *)(IRQn + -0x1fff1c00) = (char)((priority & 0xff) << 4);
  }
  return;
}



uint32_t LL_GPIO_GetPinMode(GPIO_TypeDef *GPIOx,uint32_t Pin)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint32_t Pin_local;
  GPIO_TypeDef *GPIOx_local;
  uint32_t result;
  uint32_t result_1;
  
  bVar2 = (byte)Pin;
  bVar3 = (byte)(Pin >> 8);
  bVar4 = (byte)(Pin >> 0x10);
  bVar1 = (byte)(Pin >> 0x18);
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar6 = 0x20;
  }
  else
  {
    iVar6 = LZCOUNT(uVar5);
  }
  uVar5 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar5 == 0)
  {
    iVar7 = 0x20;
  }
  else
  {
    iVar7 = LZCOUNT(uVar5);
  }
  return (GPIOx->MODER & 3 << (iVar6 << 1)) >> (iVar7 << 1);
}



uint32_t LL_GPIO_IsInputPinSet(GPIO_TypeDef *GPIOx,uint32_t PinMask)
{
  uint32_t PinMask_local;
  GPIO_TypeDef *GPIOx_local;
  
  return (uint)(PinMask == (PinMask & GPIOx->IDR));
}



uint32_t LL_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx,uint32_t PinMask)
{
  uint32_t PinMask_local;
  GPIO_TypeDef *GPIOx_local;
  
  return (uint)(PinMask == (PinMask & GPIOx->ODR));
}



void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx,uint32_t PinMask)
{
  uint32_t PinMask_local;
  GPIO_TypeDef *GPIOx_local;
  
  GPIOx->BSRR = PinMask;
  return;
}



void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx,uint32_t PinMask)
{
  uint32_t PinMask_local;
  GPIO_TypeDef *GPIOx_local;
  
  GPIOx->BRR = PinMask;
  return;
}



void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.AHB2ENR;
  RCC.AHB2ENR = Periphs | uVar1;
  uVar1 = RCC.AHB2ENR;
  return;
}



void LL_AHB2_GRP1_DisableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  
  uVar1 = RCC.AHB2ENR;
  RCC.AHB2ENR = ~Periphs & uVar1;
  return;
}



uint32_t LL_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine)
{
  uint uVar1;
  uint32_t ExtiLine_local;
  
  uVar1 = EXTI.PR1;
  return (uint)(ExtiLine == (ExtiLine & uVar1));
}



void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
  uint32_t ExtiLine_local;
  
  EXTI.PR1 = ExtiLine;
  return;
}



void LL_SYSCFG_SetEXTISource(uint32_t Port,uint32_t Line)
{
  uint uVar1;
  byte bVar2;
  byte bVar3;
  int iVar4;
  uint32_t Line_local;
  uint32_t Port_local;
  uint32_t result;
  
  bVar2 = (byte)(Line >> 0x10);
  bVar3 = (byte)(Line >> 0x18);
  uVar1 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10;
  if (uVar1 == 0)
  {
    iVar4 = 0x20;
  }
  else
  {
    iVar4 = LZCOUNT(uVar1);
  }
  (&SYSCFG.EXTICR1)[Line & 3] = Port << iVar4 | (&SYSCFG.EXTICR1)[Line & 3] & ~(Line >> 0x10);
  return;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_gpio_init_output
          (smtc_hal_mcu_gpio_cfg_t cfg,smtc_hal_mcu_gpio_output_cfg_t *output_cfg,
          smtc_hal_mcu_gpio_inst_t *inst)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  ErrorStatus EVar3;
  smtc_hal_mcu_gpio_inst_s *inst_00;
  smtc_hal_mcu_gpio_inst_t *inst_local;
  smtc_hal_mcu_gpio_output_cfg_t *output_cfg_local;
  smtc_hal_mcu_gpio_cfg_t cfg_local;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  smtc_hal_mcu_gpio_inst_s *gpio_cfg_slot;
  smtc_hal_mcu_status_t status;
  
  _Var1 = smtc_hal_mcu_gpio_stm32l4_is_configured(cfg);
  if (_Var1)
  {
    sVar2 = SMTC_HAL_MCU_STATUS_ERROR;
  }
  else
  {
    inst_00 = smtc_hal_mcu_gpio_stm32l4_get_free_slot();
    if (inst_00 == (smtc_hal_mcu_gpio_inst_s *)0x0)
    {
      sVar2 = SMTC_HAL_MCU_STATUS_ERROR;
    }
    else
    {
      inst_00->is_cfged = false;
      inst_00->is_irq_cfged = false;
      inst_00->port = cfg->port;
      inst_00->pin = cfg->pin;
      GPIO_InitStruct.Speed = 0;
      GPIO_InitStruct.OutputType = 0;
      GPIO_InitStruct.Pull = 0;
      GPIO_InitStruct.Alternate = 0;
      GPIO_InitStruct.Pin = inst_00->pin;
      GPIO_InitStruct.Mode = 1;
      sVar2 = smtc_hal_mcu_gpio_stm32l4_enable_clock(inst_00->port);
      if ((sVar2 == SMTC_HAL_MCU_STATUS_OK) &&
         (sVar2 = smtc_hal_mcu_gpio_set_state(inst_00,output_cfg->initial_state),
         sVar2 == SMTC_HAL_MCU_STATUS_OK))
      {
        EVar3 = LL_GPIO_Init(inst_00->port,&GPIO_InitStruct);
        if (EVar3 == SUCCESS)
        {
          inst_00->is_cfged = true;
          *inst = inst_00;
          sVar2 = SMTC_HAL_MCU_STATUS_OK;
        }
        else
        {
          sVar2 = SMTC_HAL_MCU_STATUS_ERROR;
        }
      }
    }
  }
  return sVar2;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_gpio_init_input
          (smtc_hal_mcu_gpio_cfg_t cfg,smtc_hal_mcu_gpio_input_cfg_t *input_cfg,
          smtc_hal_mcu_gpio_inst_t *inst)
{
  smtc_hal_mcu_gpio_irq_mode_t sVar1;
  undefined2 uVar2;
  _Bool _Var3;
  ErrorStatus EVar4;
  smtc_hal_mcu_status_t sVar5;
  smtc_hal_mcu_gpio_inst_s *inst_00;
  _func_void_void_ptr *p_Var6;
  void *pvVar7;
  smtc_hal_mcu_gpio_inst_t *inst_local;
  smtc_hal_mcu_gpio_input_cfg_t *input_cfg_local;
  smtc_hal_mcu_gpio_cfg_t cfg_local;
  LL_EXTI_InitTypeDef EXTI_InitStruct;
  smtc_hal_mcu_gpio_irq_exti_cfg_t exti_cfg;
  uint32_t trigger;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  smtc_hal_mcu_gpio_inst_s *gpio_cfg_slot;
  smtc_hal_mcu_status_t status;
  
  _Var3 = smtc_hal_mcu_gpio_stm32l4_is_configured(cfg);
  if (_Var3)
  {
    status = SMTC_HAL_MCU_STATUS_ERROR;
  }
  else
  {
    inst_00 = smtc_hal_mcu_gpio_stm32l4_get_free_slot();
    if (inst_00 == (smtc_hal_mcu_gpio_inst_s *)0x0)
    {
      status = SMTC_HAL_MCU_STATUS_ERROR;
    }
    else
    {
      inst_00->is_cfged = false;
      inst_00->is_irq_cfged = false;
      inst_00->port = cfg->port;
      inst_00->pin = cfg->pin;
      GPIO_InitStruct.Mode = 0;
      GPIO_InitStruct.Speed = 0;
      GPIO_InitStruct.Pull = 0;
      GPIO_InitStruct.Alternate = 0;
      GPIO_InitStruct.Pin = inst_00->pin;
      GPIO_InitStruct.OutputType = 1;
      status = smtc_hal_mcu_gpio_stm32l4_enable_clock(inst_00->port);
      if (status == SMTC_HAL_MCU_STATUS_OK)
      {
        EVar4 = LL_GPIO_Init(inst_00->port,&GPIO_InitStruct);
        if (EVar4 == SUCCESS)
        {
          if (input_cfg->irq_mode != SMTC_HAL_MCU_GPIO_IRQ_MODE_OFF)
          {
            sVar5 = smtc_hal_mcu_gpio_stm32l4_get_exti_cfg(inst_00,&exti_cfg);
            if (sVar5 != SMTC_HAL_MCU_STATUS_OK)
            {
              return sVar5;
            }
            sVar5 = smtc_hal_mcu_gpio_stm32l4_get_trigger(input_cfg->irq_mode,&trigger);
            if (sVar5 != SMTC_HAL_MCU_STATUS_OK)
            {
              return sVar5;
            }
            sVar1 = input_cfg->irq_mode;
            uVar2 = *(undefined2 *)&input_cfg->field_0x2;
            p_Var6 = input_cfg->callback;
            pvVar7 = input_cfg->context;
            (inst_00->irq_cfg).input_cfg.pull_mode = input_cfg->pull_mode;
            (inst_00->irq_cfg).input_cfg.irq_mode = sVar1;
            *(undefined2 *)&(inst_00->irq_cfg).input_cfg.field_0x2 = uVar2;
            (inst_00->irq_cfg).input_cfg.callback = p_Var6;
            (inst_00->irq_cfg).input_cfg.context = pvVar7;
            (inst_00->irq_cfg).is_irq_enabled = false;
            (inst_00->irq_cfg).exti_cfg.syscfg_exti_port = exti_cfg.syscfg_exti_port;
            (inst_00->irq_cfg).exti_cfg.syscfg_exti_line = exti_cfg.syscfg_exti_line;
            (inst_00->irq_cfg).exti_cfg.exti_line = exti_cfg.exti_line;
            (inst_00->irq_cfg).exti_cfg.irq_number = exti_cfg.irq_number;
            EXTI_InitStruct.Line_0_31 = (inst_00->irq_cfg).exti_cfg.exti_line;
            EXTI_InitStruct.Line_32_63 = 0;
            EXTI_InitStruct.LineCommand = ENABLE;
            EXTI_InitStruct.Mode = '\0';
            EXTI_InitStruct.Trigger = (uint8_t)trigger;
            LL_EXTI_Init(&EXTI_InitStruct);
            inst_00->is_irq_cfged = true;
            status = SMTC_HAL_MCU_STATUS_OK;
          }
          inst_00->is_cfged = true;
          *inst = inst_00;
        }
        else
        {
          status = SMTC_HAL_MCU_STATUS_ERROR;
        }
      }
    }
  }
  return status;
}



smtc_hal_mcu_status_t smtc_hal_mcu_gpio_deinit(smtc_hal_mcu_gpio_inst_t *inst)
{
  bool bVar1;
  _Bool _Var2;
  ErrorStatus EVar3;
  smtc_hal_mcu_status_t sVar4;
  smtc_hal_mcu_gpio_inst_t inst_00;
  smtc_hal_mcu_gpio_inst_t *inst_local_1;
  LL_EXTI_InitTypeDef EXTI_InitStruct;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  smtc_hal_mcu_gpio_inst_t inst_local;
  int i;
  _Bool can_disable_clock;
  
  inst_00 = *inst;
  _Var2 = smtc_hal_mcu_gpio_stm32l4_is_real_inst(inst_00);
  if (_Var2)
  {
    if (inst_00->is_cfged == true)
    {
      GPIO_InitStruct.Speed = 0;
      GPIO_InitStruct.Pull = 0;
      GPIO_InitStruct.Alternate = 0;
      GPIO_InitStruct.Pin = inst_00->pin;
      GPIO_InitStruct.Mode = 3;
      GPIO_InitStruct.OutputType = 1;
      EVar3 = LL_GPIO_Init(inst_00->port,&GPIO_InitStruct);
      if (EVar3 == SUCCESS)
      {
        inst_00->is_cfged = false;
        if (inst_00->is_irq_cfged != false)
        {
          if ((inst_00->irq_cfg).is_irq_enabled != false)
          {
            smtc_hal_mcu_gpio_disable_irq(inst_00);
            LL_EXTI_StructInit(&EXTI_InitStruct);
            EXTI_InitStruct.Line_0_31 = (inst_00->irq_cfg).exti_cfg.exti_line;
            LL_EXTI_Init(&EXTI_InitStruct);
          }
          inst_00->is_irq_cfged = false;
        }
        bVar1 = true;
        for (i = 0; i < 0x10; i += 1)
        {
          if ((gpio_inst_array[i].port == inst_00->port) && (gpio_inst_array[i].is_cfged != false))
          {
            bVar1 = false;
            break;
          }
        }
        if (bVar1)
        {
          smtc_hal_mcu_gpio_stm32l4_disable_clock(inst_00->port);
        }
        *inst = (smtc_hal_mcu_gpio_inst_t)0x0;
        sVar4 = SMTC_HAL_MCU_STATUS_OK;
      }
      else
      {
        sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
      }
    }
    else
    {
      sVar4 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar4 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar4;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_gpio_set_state(smtc_hal_mcu_gpio_inst_t inst,smtc_hal_mcu_gpio_state_t state)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  smtc_hal_mcu_gpio_state_t state_local;
  smtc_hal_mcu_gpio_inst_t inst_local;
  
  _Var1 = smtc_hal_mcu_gpio_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    if (state == SMTC_HAL_MCU_GPIO_STATE_LOW)
    {
      LL_GPIO_ResetOutputPin(inst->port,inst->pin);
    }
    else
    {
      if (state != SMTC_HAL_MCU_GPIO_STATE_HIGH)
      {
        return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
      }
      LL_GPIO_SetOutputPin(inst->port,inst->pin);
    }
    sVar2 = SMTC_HAL_MCU_STATUS_OK;
  }
  else
  {
    sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar2;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_gpio_get_state(smtc_hal_mcu_gpio_inst_t inst,smtc_hal_mcu_gpio_state_t *state)
{
  _Bool _Var1;
  uint32_t uVar2;
  smtc_hal_mcu_gpio_state_t sVar3;
  smtc_hal_mcu_status_t sVar4;
  bool bVar5;
  smtc_hal_mcu_gpio_state_t *state_local;
  smtc_hal_mcu_gpio_inst_t inst_local;
  uint32_t pin_mode;
  
  _Var1 = smtc_hal_mcu_gpio_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    uVar2 = LL_GPIO_GetPinMode(inst->port,inst->pin);
    if (uVar2 == 1)
    {
      uVar2 = LL_GPIO_IsOutputPinSet(inst->port,inst->pin);
      bVar5 = uVar2 == 1;
      if (bVar5)
      {
        uVar2 = 1;
      }
      sVar3 = (smtc_hal_mcu_gpio_state_t)uVar2;
      if (!bVar5)
      {
        sVar3 = SMTC_HAL_MCU_GPIO_STATE_LOW;
      }
      *state = sVar3;
    }
    else
    {
      if (uVar2 != 0)
      {
        return SMTC_HAL_MCU_STATUS_NOT_INIT;
      }
      uVar2 = LL_GPIO_IsInputPinSet(inst->port,inst->pin);
      bVar5 = uVar2 == 1;
      if (bVar5)
      {
        uVar2 = 1;
      }
      sVar3 = (smtc_hal_mcu_gpio_state_t)uVar2;
      if (!bVar5)
      {
        sVar3 = SMTC_HAL_MCU_GPIO_STATE_LOW;
      }
      *state = sVar3;
    }
    sVar4 = SMTC_HAL_MCU_STATUS_OK;
  }
  else
  {
    sVar4 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar4;
}



smtc_hal_mcu_status_t smtc_hal_mcu_gpio_enable_irq(smtc_hal_mcu_gpio_inst_t inst)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  smtc_hal_mcu_gpio_inst_t inst_local;
  
  _Var1 = smtc_hal_mcu_gpio_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    if ((inst->is_irq_cfged == false) || ((inst->irq_cfg).is_irq_enabled == true))
    {
      sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
    else
    {
      LL_SYSCFG_SetEXTISource
                ((inst->irq_cfg).exti_cfg.syscfg_exti_port,(inst->irq_cfg).exti_cfg.syscfg_exti_line
                );
      __NVIC_EnableIRQ((IRQn_Type)(inst->irq_cfg).exti_cfg.irq_number);
      __NVIC_SetPriority((IRQn_Type)(inst->irq_cfg).exti_cfg.irq_number,0);
      (inst->irq_cfg).is_irq_enabled = true;
      sVar2 = SMTC_HAL_MCU_STATUS_OK;
    }
  }
  else
  {
    sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar2;
}



smtc_hal_mcu_status_t smtc_hal_mcu_gpio_disable_irq(smtc_hal_mcu_gpio_inst_t inst)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  smtc_hal_mcu_gpio_inst_t inst_local;
  
  _Var1 = smtc_hal_mcu_gpio_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    if (inst->is_irq_cfged == false)
    {
      sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
    else
    {
      if ((inst->irq_cfg).is_irq_enabled != false)
      {
        __NVIC_DisableIRQ((IRQn_Type)(inst->irq_cfg).exti_cfg.irq_number);
        (inst->irq_cfg).is_irq_enabled = false;
      }
      sVar2 = SMTC_HAL_MCU_STATUS_OK;
    }
  }
  else
  {
    sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar2;
}



_Bool smtc_hal_mcu_gpio_stm32l4_is_configured(smtc_hal_mcu_gpio_cfg_t cfg)
{
  smtc_hal_mcu_gpio_cfg_t cfg_local;
  int i;
  
  i = 0;
  while( true )
  {
    if (0xf < i)
    {
      return false;
    }
    if (((gpio_inst_array[i].is_cfged != false) && (gpio_inst_array[i].port == cfg->port)) &&
       (gpio_inst_array[i].pin == cfg->pin)) break;
    i += 1;
  }
  return true;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_gpio_inst_s * smtc_hal_mcu_gpio_stm32l4_get_free_slot(void)
{
  int i;
  
  i = 0;
  while( true )
  {
    if (0xf < i)
    {
      return (smtc_hal_mcu_gpio_inst_s *)0x0;
    }
    if (gpio_inst_array[i].is_cfged != true) break;
    i += 1;
  }
  return gpio_inst_array + i;
}



_Bool smtc_hal_mcu_gpio_stm32l4_is_real_inst(smtc_hal_mcu_gpio_inst_t inst)
{
  smtc_hal_mcu_gpio_inst_t inst_local;
  int i;
  
  i = 0;
  while( true )
  {
    if (0xf < i)
    {
      return false;
    }
    if (inst == gpio_inst_array + i) break;
    i += 1;
  }
  return true;
}



smtc_hal_mcu_status_t smtc_hal_mcu_gpio_stm32l4_enable_clock(GPIO_TypeDef *port)
{
  GPIO_TypeDef *port_local;
  
  if ((GPIOA *)port == &GPIOA)
  {
    LL_AHB2_GRP1_EnableClock(1);
  }
  else if ((GPIOB *)port == &GPIOB)
  {
    LL_AHB2_GRP1_EnableClock(2);
  }
  else if ((GPIOC *)port == &GPIOC)
  {
    LL_AHB2_GRP1_EnableClock(4);
  }
  else if ((GPIOD *)port == &GPIOD)
  {
    LL_AHB2_GRP1_EnableClock(8);
  }
  else if ((GPIOE *)port == &GPIOE)
  {
    LL_AHB2_GRP1_EnableClock(0x10);
  }
  else if ((GPIOF *)port == &GPIOF)
  {
    LL_AHB2_GRP1_EnableClock(0x20);
  }
  else if ((GPIOG *)port == &GPIOG)
  {
    LL_AHB2_GRP1_EnableClock(0x40);
  }
  else
  {
    if ((GPIOH *)port != &GPIOH)
    {
      return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
    LL_AHB2_GRP1_EnableClock(0x80);
  }
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t smtc_hal_mcu_gpio_stm32l4_disable_clock(GPIO_TypeDef *port)
{
  GPIO_TypeDef *port_local;
  
  if ((GPIOA *)port == &GPIOA)
  {
    LL_AHB2_GRP1_DisableClock(1);
  }
  else if ((GPIOB *)port == &GPIOB)
  {
    LL_AHB2_GRP1_DisableClock(2);
  }
  else if ((GPIOC *)port == &GPIOC)
  {
    LL_AHB2_GRP1_DisableClock(4);
  }
  else if ((GPIOD *)port == &GPIOD)
  {
    LL_AHB2_GRP1_DisableClock(8);
  }
  else if ((GPIOE *)port == &GPIOE)
  {
    LL_AHB2_GRP1_DisableClock(0x10);
  }
  else if ((GPIOF *)port == &GPIOF)
  {
    LL_AHB2_GRP1_DisableClock(0x20);
  }
  else if ((GPIOG *)port == &GPIOG)
  {
    LL_AHB2_GRP1_DisableClock(0x40);
  }
  else
  {
    if ((GPIOH *)port != &GPIOH)
    {
      return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
    LL_AHB2_GRP1_DisableClock(0x80);
  }
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_gpio_stm32l4_get_exti_cfg
          (smtc_hal_mcu_gpio_inst_t inst,smtc_hal_mcu_gpio_irq_exti_cfg_t *exti_cfg)
{
  smtc_hal_mcu_gpio_irq_exti_cfg_t *exti_cfg_local;
  smtc_hal_mcu_gpio_inst_t inst_local;
  
  if (inst->pin == 1)
  {
    exti_cfg->exti_line = 1;
    exti_cfg->syscfg_exti_line = 0xf0000;
    exti_cfg->irq_number = 6;
  }
  else if (inst->pin == 2)
  {
    exti_cfg->exti_line = 2;
    exti_cfg->syscfg_exti_line = 0xf00000;
    exti_cfg->irq_number = 7;
  }
  else if (inst->pin == 4)
  {
    exti_cfg->exti_line = 4;
    exti_cfg->syscfg_exti_line = 0xf000000;
    exti_cfg->irq_number = 8;
  }
  else if (inst->pin == 8)
  {
    exti_cfg->exti_line = 8;
    exti_cfg->syscfg_exti_line = 0xf0000000;
    exti_cfg->irq_number = 9;
  }
  else if (inst->pin == 0x10)
  {
    exti_cfg->exti_line = 0x10;
    exti_cfg->syscfg_exti_line = 0xf0001;
    exti_cfg->irq_number = 10;
  }
  else if (inst->pin == 0x20)
  {
    exti_cfg->exti_line = 0x20;
    exti_cfg->syscfg_exti_line = 0xf00001;
    exti_cfg->irq_number = 0x17;
  }
  else if (inst->pin == 0x40)
  {
    exti_cfg->exti_line = 0x40;
    exti_cfg->syscfg_exti_line = 0xf000001;
    exti_cfg->irq_number = 0x17;
  }
  else if (inst->pin == 0x80)
  {
    exti_cfg->exti_line = 0x80;
    exti_cfg->syscfg_exti_line = 0xf0000001;
    exti_cfg->irq_number = 0x17;
  }
  else if (inst->pin == 0x100)
  {
    exti_cfg->exti_line = 0x100;
    exti_cfg->syscfg_exti_line = 0xf0002;
    exti_cfg->irq_number = 0x17;
  }
  else if (inst->pin == 0x200)
  {
    exti_cfg->exti_line = 0x200;
    exti_cfg->syscfg_exti_line = 0xf00002;
    exti_cfg->irq_number = 0x17;
  }
  else if (inst->pin == 0x400)
  {
    exti_cfg->exti_line = 0x400;
    exti_cfg->syscfg_exti_line = 0xf000002;
    exti_cfg->irq_number = 0x28;
  }
  else if (inst->pin == 0x800)
  {
    exti_cfg->exti_line = 0x800;
    exti_cfg->syscfg_exti_line = 0xf0000002;
    exti_cfg->irq_number = 0x28;
  }
  else if (inst->pin == 0x1000)
  {
    exti_cfg->exti_line = 0x1000;
    exti_cfg->syscfg_exti_line = 0xf0003;
    exti_cfg->irq_number = 0x28;
  }
  else if (inst->pin == 0x2000)
  {
    exti_cfg->exti_line = 0x2000;
    exti_cfg->syscfg_exti_line = 0xf00003;
    exti_cfg->irq_number = 0x28;
  }
  else if (inst->pin == 0x4000)
  {
    exti_cfg->exti_line = 0x4000;
    exti_cfg->syscfg_exti_line = 0xf000003;
    exti_cfg->irq_number = 0x28;
  }
  else
  {
    if (inst->pin != 0x8000)
    {
      return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
    exti_cfg->exti_line = 0x8000;
    exti_cfg->syscfg_exti_line = 0xf0000003;
    exti_cfg->irq_number = 0x28;
  }
  if ((GPIOA *)inst->port == &GPIOA)
  {
    exti_cfg->syscfg_exti_port = 0;
  }
  else if ((GPIOB *)inst->port == &GPIOB)
  {
    exti_cfg->syscfg_exti_port = 1;
  }
  else if ((GPIOC *)inst->port == &GPIOC)
  {
    exti_cfg->syscfg_exti_port = 2;
  }
  else if ((GPIOD *)inst->port == &GPIOD)
  {
    exti_cfg->syscfg_exti_port = 3;
  }
  else if ((GPIOE *)inst->port == &GPIOE)
  {
    exti_cfg->syscfg_exti_port = 4;
  }
  else if ((GPIOF *)inst->port == &GPIOF)
  {
    exti_cfg->syscfg_exti_port = 5;
  }
  else if ((GPIOG *)inst->port == &GPIOG)
  {
    exti_cfg->syscfg_exti_port = 6;
  }
  else
  {
    if ((GPIOH *)inst->port != &GPIOH)
    {
      return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
    exti_cfg->syscfg_exti_port = 7;
  }
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_gpio_stm32l4_get_trigger(smtc_hal_mcu_gpio_irq_mode_t mode,uint32_t *trigger)
{
  uint32_t *trigger_local;
  smtc_hal_mcu_gpio_irq_mode_t mode_local;
  
  switch(mode)
  {
  case SMTC_HAL_MCU_GPIO_IRQ_MODE_OFF:
    *trigger = 0;
    break;
  case SMTC_HAL_MCU_GPIO_IRQ_MODE_RISING:
    *trigger = 1;
    break;
  case SMTC_HAL_MCU_GPIO_IRQ_MODE_FALLING:
    *trigger = 2;
    break;
  case SMTC_HAL_MCU_GPIO_IRQ_MODE_RISING_FALLING:
    *trigger = 3;
    break;
  default:
    return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t smtc_hal_mcu_gpio_stm32l4_call_exti_callback(uint32_t pin)
{
  uint32_t pin_local;
  uint32_t i;
  
  i = 0;
  while( true )
  {
    if (0xf < i)
    {
      return SMTC_HAL_MCU_STATUS_ERROR;
    }
    if (((pin == gpio_inst_array[i].pin) && (gpio_inst_array[i].irq_cfg.is_irq_enabled != false)) &&
       (gpio_inst_array[i].irq_cfg.input_cfg.callback != (_func_void_void_ptr *)0x0)) break;
    i += 1;
  }
  (*gpio_inst_array[i].irq_cfg.input_cfg.callback)(gpio_inst_array[i].irq_cfg.input_cfg.context);
  return SMTC_HAL_MCU_STATUS_OK;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI0_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(1);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(1);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(1);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI1_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(2);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(2);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(2);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI2_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(4);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(4);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(4);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI3_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(8);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(8);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(8);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI4_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x10);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x10);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x10);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI9_5_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x20);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x20);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x20);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x40);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x40);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x40);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x80);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x80);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x80);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x100);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x100);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x100);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x200);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x200);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x200);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EXTI15_10_IRQHandler(void)
{
  uint32_t uVar1;
  
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x400);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x400);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x400);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x800);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x800);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x800);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x1000);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x1000);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x1000);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x2000);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x2000);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x2000);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x4000);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x4000);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x4000);
  }
  uVar1 = LL_EXTI_IsActiveFlag_0_31(0x8000);
  if (uVar1 != 0)
  {
    LL_EXTI_ClearFlag_0_31(0x8000);
    smtc_hal_mcu_gpio_stm32l4_call_exti_callback(0x8000);
  }
  return;
}



void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  IRQn_Type IRQn_local;
  
  if (SysTick_IRQn < IRQn)
  {
    *(int *)(((uint)(int)IRQn >> 5) * 4 + -0x1fff1f00) = 1 << (IRQn & I2C1_EV_IRQn);
  }
  return;
}



void __NVIC_SetPriority(IRQn_Type IRQn,uint32_t priority)
{
  uint32_t priority_local;
  IRQn_Type IRQn_local;
  
  if (IRQn < WWDG_IRQn)
  {
    *(char *)(((byte)IRQn & 0xf) + 0xe000ed14) = (char)((priority & 0xff) << 4);
  }
  else
  {
    *(char *)(IRQn + -0x1fff1c00) = (char)((priority & 0xff) << 4);
  }
  return;
}



void LL_USART_Enable(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  USARTx->CR1 = USARTx->CR1 | 1;
  return;
}



uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  return (uint)((USARTx->CR1 & 1) == 1);
}



void LL_USART_ConfigAsyncMode(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  USARTx->CR2 = USARTx->CR2 & 0xffffb7ff;
  USARTx->CR3 = USARTx->CR3 & 0xffffffd5;
  return;
}



uint32_t LL_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  return (uint)((USARTx->ISR & 0x20) == 0x20);
}



void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  USARTx->ICR = 8;
  return;
}



void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
{
  bool bVar1;
  USART_TypeDef *USARTx_local;
  uint32_t result;
  uint32_t result_1;
  uint32_t val;
  
  do
  {
    ExclusiveAccess(USARTx);
    bVar1 = (bool)hasExclusiveAccess(USARTx);
  } while (!bVar1);
  USARTx->CR1 = USARTx->CR1 | 0x20;
  return;
}



uint32_t LL_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  return (uint)((USARTx->CR1 & 0x20) == 0x20);
}



void LL_USART_EnableDMAReq_RX(USART_TypeDef *USARTx)
{
  bool bVar1;
  USART_TypeDef *USARTx_local;
  uint32_t result;
  uint32_t result_1;
  uint32_t val;
  
  do
  {
    ExclusiveAccess(&USARTx->CR3);
    bVar1 = (bool)hasExclusiveAccess(&USARTx->CR3);
  } while (!bVar1);
  USARTx->CR3 = USARTx->CR3 | 0x40;
  return;
}



void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
{
  bool bVar1;
  USART_TypeDef *USARTx_local;
  uint32_t result;
  uint32_t result_1;
  uint32_t val;
  
  do
  {
    ExclusiveAccess(&USARTx->CR3);
    bVar1 = (bool)hasExclusiveAccess(&USARTx->CR3);
  } while (!bVar1);
  USARTx->CR3 = USARTx->CR3 & 0xffffffbf;
  return;
}



void LL_USART_EnableDMAReq_TX(USART_TypeDef *USARTx)
{
  bool bVar1;
  USART_TypeDef *USARTx_local;
  uint32_t result;
  uint32_t result_1;
  uint32_t val;
  
  do
  {
    ExclusiveAccess(&USARTx->CR3);
    bVar1 = (bool)hasExclusiveAccess(&USARTx->CR3);
  } while (!bVar1);
  USARTx->CR3 = USARTx->CR3 | 0x80;
  return;
}



uint32_t LL_USART_DMA_GetRegAddr(USART_TypeDef *USARTx,uint32_t Direction)
{
  uint32_t Direction_local;
  USART_TypeDef *USARTx_local;
  uint32_t data_reg_addr;
  
  if (Direction == 0)
  {
    data_reg_addr = (uint32_t)&USARTx->TDR;
  }
  else
  {
    data_reg_addr = (uint32_t)&USARTx->RDR;
  }
  return data_reg_addr;
}



uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  return (uint8_t)USARTx->RDR;
}



void LL_USART_RequestRxDataFlush(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  USARTx->RQR = USARTx->RQR | 8;
  return;
}



void LL_USART_RequestTxDataFlush(USART_TypeDef *USARTx)
{
  USART_TypeDef *USARTx_local;
  
  USARTx->RQR = USARTx->RQR | 0x10;
  return;
}



void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.AHB1ENR;
  RCC.AHB1ENR = Periphs | uVar1;
  uVar1 = RCC.AHB1ENR;
  return;
}



void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.AHB2ENR;
  RCC.AHB2ENR = Periphs | uVar1;
  uVar1 = RCC.AHB2ENR;
  return;
}



void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.APB1ENR1;
  RCC.APB1ENR1 = Periphs | uVar1;
  uVar1 = RCC.APB1ENR1;
  return;
}



void LL_DMA_EnableChannel(DMA_TypeDef *DMAx,uint32_t Channel)
{
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) =
       *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) | 1;
  return;
}



void LL_DMA_DisableChannel(DMA_TypeDef *DMAx,uint32_t Channel)
{
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) =
       *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) & 0xfffffffe;
  return;
}



uint32_t LL_DMA_IsEnabledChannel(DMA_TypeDef *DMAx,uint32_t Channel)
{
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  return (uint)((*(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) & 1) == 1);
}



void LL_DMA_ConfigTransfer(DMA_TypeDef *DMAx,uint32_t Channel,uint32_t Configuration)
{
  uint32_t Configuration_local;
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) =
       *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) & 0xffff800f | Configuration;
  return;
}



uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx,uint32_t Channel)
{
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  return *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) & 0x4010;
}



void LL_DMA_SetDataLength(DMA_TypeDef *DMAx,uint32_t Channel,uint32_t NbData)
{
  uint32_t NbData_local;
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  *(uint *)((int)&DMAx->IFCR + (uint)CHANNEL_OFFSET_TAB[Channel]) =
       *(uint *)((int)&DMAx->IFCR + (uint)CHANNEL_OFFSET_TAB[Channel]) & 0xffff0000 | NbData;
  return;
}



void LL_DMA_ConfigAddresses
               (DMA_TypeDef *DMAx,uint32_t Channel,uint32_t SrcAddress,uint32_t DstAddress,
               uint32_t Direction)
{
  uint32_t DstAddress_local;
  uint32_t SrcAddress_local;
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  if (Direction == 0x10)
  {
    *(uint32_t *)((int)&DMAx[1].IFCR + (uint)CHANNEL_OFFSET_TAB[Channel]) = SrcAddress;
    *(uint32_t *)((int)&DMAx[1].ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) = DstAddress;
  }
  else
  {
    *(uint32_t *)((int)&DMAx[1].ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) = SrcAddress;
    *(uint32_t *)((int)&DMAx[1].IFCR + (uint)CHANNEL_OFFSET_TAB[Channel]) = DstAddress;
  }
  return;
}



void LL_DMA_SetPeriphRequest(DMA_TypeDef *DMAx,uint32_t Channel,uint32_t PeriphRequest)
{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  int iVar5;
  uint uVar6;
  uint32_t PeriphRequest_local;
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t result;
  
  iVar5 = 0xf << ((Channel & 7) << 2);
  bVar2 = (byte)iVar5;
  bVar3 = (byte)((uint)iVar5 >> 8);
  bVar4 = (byte)((uint)iVar5 >> 0x10);
  bVar1 = (byte)((uint)iVar5 >> 0x18);
  uVar6 = (uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) << 1 |
                          bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 | bVar2 >> 5 & 1) << 1 |
                       bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18 |
          (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1) << 1 |
                          bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 | bVar3 >> 5 & 1) << 1 |
                       bVar3 >> 6 & 1) << 1 | bVar3 >> 7) << 0x10 |
          (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 | bVar4 >> 2 & 1) << 1 |
                          bVar4 >> 3 & 1) << 1 | bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |
                       bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |
          (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) << 1 |
                          bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 | bVar1 >> 5 & 1) << 1 |
                       bVar1 >> 6 & 1) << 1 | bVar1 >> 7);
  if (uVar6 == 0)
  {
    iVar5 = 0x20;
  }
  else
  {
    iVar5 = LZCOUNT(uVar6);
  }
  DMAx[0x15].ISR = PeriphRequest << iVar5 | DMAx[0x15].ISR & ~(0xf << ((Channel & 7) << 2));
  return;
}



uint32_t LL_DMA_IsActiveFlag_TC6(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x200000) == 0x200000);
}



uint32_t LL_DMA_IsActiveFlag_TC7(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x2000000) == 0x2000000);
}



uint32_t LL_DMA_IsActiveFlag_TE6(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x800000) == 0x800000);
}



uint32_t LL_DMA_IsActiveFlag_TE7(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  return (uint)((DMAx->ISR & 0x8000000) == 0x8000000);
}



void LL_DMA_ClearFlag_GI6(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x100000;
  return;
}



void LL_DMA_ClearFlag_GI7(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x1000000;
  return;
}



void LL_DMA_ClearFlag_TC6(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x200000;
  return;
}



void LL_DMA_ClearFlag_HT6(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x400000;
  return;
}



void LL_DMA_ClearFlag_TE6(DMA_TypeDef *DMAx)
{
  DMA_TypeDef *DMAx_local;
  
  DMAx->IFCR = 0x800000;
  return;
}



void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx,uint32_t Channel)
{
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) =
       *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) | 2;
  return;
}



void LL_DMA_EnableIT_TE(DMA_TypeDef *DMAx,uint32_t Channel)
{
  uint32_t Channel_local;
  DMA_TypeDef *DMAx_local;
  uint32_t dma_base_addr;
  
  *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) =
       *(uint *)((int)&DMAx->ISR + (uint)CHANNEL_OFFSET_TAB[Channel]) | 8;
  return;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_uart_init
          (smtc_hal_mcu_uart_cfg_t cfg,smtc_hal_mcu_uart_cfg_app_t *cfg_app,
          smtc_hal_mcu_uart_inst_t *inst)
{
  ErrorStatus EVar1;
  smtc_hal_mcu_uart_inst_s *psVar2;
  uint32_t uVar3;
  smtc_hal_mcu_status_t sVar4;
  smtc_hal_mcu_uart_inst_t *inst_local;
  smtc_hal_mcu_uart_cfg_app_t *cfg_app_local;
  smtc_hal_mcu_uart_cfg_t cfg_local;
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  LL_USART_InitTypeDef USART_InitStruct;
  smtc_hal_mcu_uart_inst_s *uart_cfg_slot;
  
  psVar2 = smtc_hal_mcu_uart_stm32l4_get_free_slot();
  if (psVar2 == (smtc_hal_mcu_uart_inst_s *)0x0)
  {
    sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
  }
  else
  {
    if (cfg->usart == (USART_TypeDef *)&USART2)
    {
      psVar2->usart = cfg->usart;
      LL_APB1_GRP1_EnableClock(0x20000);
      LL_AHB2_GRP1_EnableClock(1);
      GPIO_InitStruct.Pin = 0xc;
      GPIO_InitStruct.Mode = 2;
      GPIO_InitStruct.Speed = 3;
      GPIO_InitStruct.OutputType = 0;
      GPIO_InitStruct.Pull = 0;
      GPIO_InitStruct.Alternate = 7;
      LL_GPIO_Init((GPIO_TypeDef *)&GPIOA,&GPIO_InitStruct);
      __NVIC_SetPriority(USART2_IRQn,0);
      __NVIC_EnableIRQ(USART2_IRQn);
    }
    USART_InitStruct.BaudRate = cfg_app->baudrate;
    USART_InitStruct.DataWidth = 0;
    USART_InitStruct.StopBits = 0;
    USART_InitStruct.Parity = 0;
    USART_InitStruct.TransferDirection = 0xc;
    USART_InitStruct.HardwareFlowControl = 0;
    USART_InitStruct.OverSampling = 0;
    psVar2->callback_rx = cfg_app->callback_rx;
    EVar1 = LL_USART_Init(psVar2->usart,&USART_InitStruct);
    if (EVar1 == ERROR)
    {
      sVar4 = SMTC_HAL_MCU_STATUS_ERROR;
    }
    else
    {
      LL_USART_ConfigAsyncMode(psVar2->usart);
      LL_USART_Enable(psVar2->usart);
      do
      {
        uVar3 = LL_USART_IsEnabled(psVar2->usart);
      } while (uVar3 == 0);
      LL_USART_RequestRxDataFlush(psVar2->usart);
      LL_USART_RequestTxDataFlush(psVar2->usart);
      if (cfg_app->callback_rx != (_func_void_uint8_t *)0x0)
      {
        LL_USART_EnableIT_RXNE(psVar2->usart);
      }
      psVar2->is_cfged = true;
      *inst = psVar2;
      sVar4 = SMTC_HAL_MCU_STATUS_OK;
    }
  }
  return sVar4;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_uart_dma_init
          (smtc_hal_mcu_uart_dma_cfg_t cfg,smtc_hal_mcu_uart_dma_cfg_app_t *cfg_app,
          smtc_hal_mcu_uart_inst_t *inst)
{
  smtc_hal_mcu_uart_inst_t *inst_local;
  smtc_hal_mcu_uart_dma_cfg_app_t *cfg_app_local;
  smtc_hal_mcu_uart_dma_cfg_t cfg_local;
  smtc_hal_mcu_uart_cfg_app_s cfg_uart_app;
  smtc_hal_mcu_uart_cfg_s cfg_uart;
  smtc_hal_mcu_uart_inst_t uart_cfg_slot;
  smtc_hal_mcu_status_t status;
  
  if ((DMA1 *)cfg->dma == &DMA1)
  {
    uart_cfg_slot = (smtc_hal_mcu_uart_inst_t)0x0;
    cfg_uart.usart = (USART_TypeDef *)&USART2;
    cfg_uart_app.baudrate = cfg_app->baudrate;
    cfg_uart_app.callback_rx = (_func_void_uint8_t *)0x0;
    status = smtc_hal_mcu_uart_init(&cfg_uart,&cfg_uart_app,&uart_cfg_slot);
    if (status == SMTC_HAL_MCU_STATUS_OK)
    {
      uart_cfg_slot->DMAcallback_rx = cfg_app->callback_rx;
      uart_cfg_slot->DMAcallback_tx = cfg_app->callback_tx;
      uart_cfg_slot->DMAcallback_rx_error = cfg_app->callback_error_rx;
      uart_cfg_slot->DMAcallback_tx_error = cfg_app->callback_error_tx;
      uart_cfg_slot->dma = cfg->dma;
      LL_AHB1_GRP1_EnableClock(1);
      __NVIC_SetPriority(DMA1_Channel7_IRQn,0);
      __NVIC_EnableIRQ(DMA1_Channel7_IRQn);
      __NVIC_SetPriority(DMA1_Channel6_IRQn,0);
      __NVIC_EnableIRQ(DMA1_Channel6_IRQn);
      LL_DMA_ConfigTransfer((DMA_TypeDef *)&DMA1,6,0x2090);
      LL_DMA_ConfigTransfer((DMA_TypeDef *)&DMA1,5,0x2080);
      LL_DMA_EnableIT_TC((DMA_TypeDef *)&DMA1,6);
      LL_DMA_EnableIT_TE((DMA_TypeDef *)&DMA1,6);
      LL_DMA_EnableIT_TC((DMA_TypeDef *)&DMA1,5);
      LL_DMA_EnableIT_TE((DMA_TypeDef *)&DMA1,5);
      *inst = uart_cfg_slot;
      status = SMTC_HAL_MCU_STATUS_OK;
    }
  }
  else
  {
    status = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return status;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_uart_dma_send(smtc_hal_mcu_uart_inst_t inst,uint8_t *aTxBuffer,uint data_length)
{
  uint32_t DstAddress;
  uint32_t Direction;
  DMA_TypeDef *DMAx;
  uint data_length_local;
  uint8_t *aTxBuffer_local;
  smtc_hal_mcu_uart_inst_t inst_local;
  
  DMAx = inst->dma;
  DstAddress = LL_USART_DMA_GetRegAddr(inst->usart,0);
  Direction = LL_DMA_GetDataTransferDirection((DMA_TypeDef *)&DMA1,6);
  LL_DMA_ConfigAddresses(DMAx,6,(uint32_t)aTxBuffer,DstAddress,Direction);
  LL_DMA_SetDataLength(inst->dma,6,data_length);
  LL_DMA_SetPeriphRequest(inst->dma,6,2);
  LL_USART_EnableDMAReq_TX(inst->usart);
  LL_DMA_EnableChannel(inst->dma,6);
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_uart_dma_receive(smtc_hal_mcu_uart_inst_t inst,uint8_t *aRxBuffer,uint data_length)
{
  uint32_t SrcAddress;
  uint32_t Direction;
  DMA_TypeDef *DMAx;
  uint data_length_local;
  uint8_t *aRxBuffer_local;
  smtc_hal_mcu_uart_inst_t inst_local;
  
  DMAx = inst->dma;
  SrcAddress = LL_USART_DMA_GetRegAddr(inst->usart,1);
  Direction = LL_DMA_GetDataTransferDirection(inst->dma,5);
  LL_DMA_ConfigAddresses(DMAx,5,SrcAddress,(uint32_t)aRxBuffer,Direction);
  LL_DMA_SetDataLength(inst->dma,5,data_length);
  LL_DMA_SetPeriphRequest(inst->dma,5,2);
  LL_USART_EnableDMAReq_RX(inst->usart);
  LL_DMA_EnableChannel(inst->dma,5);
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t smtc_hal_mcu_uart_dma_abort_rx(smtc_hal_mcu_uart_inst_t inst)
{
  _Bool _Var1;
  uint32_t uVar2;
  smtc_hal_mcu_status_t sVar3;
  smtc_hal_mcu_status_t extraout_r3;
  smtc_hal_mcu_uart_inst_t inst_local;
  
  _Var1 = smtc_hal_mcu_uart_stm32l4_is_real_inst(inst);
  if (_Var1)
  {
    if (inst->is_cfged == true)
    {
      LL_USART_DisableDMAReq_RX(inst->usart);
      LL_DMA_DisableChannel(inst->dma,5);
      do
      {
        uVar2 = LL_DMA_IsEnabledChannel(inst->dma,5);
      } while (uVar2 != 0);
      LL_DMA_ClearFlag_TC6(inst->dma);
      LL_DMA_ClearFlag_HT6(inst->dma);
      LL_DMA_ClearFlag_TE6(inst->dma);
      while (uVar2 = LL_USART_IsActiveFlag_RXNE(inst->usart), uVar2 != 0)
      {
        LL_USART_ReceiveData8(inst->usart);
      }
      LL_USART_ClearFlag_ORE(inst->usart);
      sVar3 = extraout_r3;
    }
    else
    {
      sVar3 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar3 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar3;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_uart_inst_s * smtc_hal_mcu_uart_stm32l4_get_free_slot(void)
{
  int i;
  
  i = 0;
  while( true )
  {
    if (0 < i)
    {
      return (smtc_hal_mcu_uart_inst_s *)0x0;
    }
    if (uart_inst_array[i].is_cfged != true) break;
    i += 1;
  }
  return uart_inst_array + i;
}



_Bool smtc_hal_mcu_uart_stm32l4_is_real_inst(smtc_hal_mcu_uart_inst_t inst)
{
  smtc_hal_mcu_uart_inst_t inst_local;
  int i;
  
  i = 0;
  while( true )
  {
    if (0 < i)
    {
      return false;
    }
    if (inst == uart_inst_array + i) break;
    i += 1;
  }
  return true;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void USART2_IRQHandler(void)
{
  uint8_t uVar1;
  uint32_t uVar2;
  uint8_t data;
  int i;
  
  uVar2 = LL_USART_IsActiveFlag_RXNE((USART_TypeDef *)&USART2);
  if ((uVar2 != 0) && (uVar2 = LL_USART_IsEnabledIT_RXNE((USART_TypeDef *)&USART2), uVar2 != 0))
  {
    uVar1 = LL_USART_ReceiveData8((USART_TypeDef *)&USART2);
    for (i = 0; i < 1; i += 1)
    {
      if (uart_inst_array[i].usart == (USART_TypeDef *)0x40004400)
      {
        if (uart_inst_array[i].callback_rx == (_func_void_uint8_t *)0x0)
        {
          return;
        }
        (*uart_inst_array[i].callback_rx)(uVar1);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA1_Channel7_IRQHandler(void)
{
  uint32_t uVar1;
  int i_1;
  int i;
  
  uVar1 = LL_DMA_IsActiveFlag_TC7((DMA_TypeDef *)&DMA1);
  if (uVar1 == 0)
  {
    uVar1 = LL_DMA_IsActiveFlag_TE7((DMA_TypeDef *)&DMA1);
    if (uVar1 != 0)
    {
      for (i_1 = 0; i_1 < 1; i_1 += 1)
      {
        if (uart_inst_array[i_1].dma == (DMA_TypeDef *)0x40020000)
        {
          if (uart_inst_array[i_1].DMAcallback_tx_error == (_func_void *)0x0)
          {
            return;
          }
          (*uart_inst_array[i_1].DMAcallback_tx_error)();
          return;
        }
      }
    }
  }
  else
  {
    LL_DMA_ClearFlag_GI7((DMA_TypeDef *)&DMA1);
    for (i = 0; i < 1; i += 1)
    {
      if (uart_inst_array[i].dma == (DMA_TypeDef *)0x40020000)
      {
        if (uart_inst_array[i].DMAcallback_tx != (_func_void *)0x0)
        {
          (*uart_inst_array[i].DMAcallback_tx)();
        }
        break;
      }
    }
    LL_DMA_DisableChannel((DMA_TypeDef *)&DMA1,6);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DMA1_Channel6_IRQHandler(void)
{
  uint32_t uVar1;
  int i_1;
  int i;
  
  uVar1 = LL_DMA_IsActiveFlag_TC6((DMA_TypeDef *)&DMA1);
  if (uVar1 == 0)
  {
    uVar1 = LL_DMA_IsActiveFlag_TE6((DMA_TypeDef *)&DMA1);
    if (uVar1 != 0)
    {
      for (i_1 = 0; i_1 < 1; i_1 += 1)
      {
        if (uart_inst_array[i_1].dma == (DMA_TypeDef *)0x40020000)
        {
          if (uart_inst_array[i_1].DMAcallback_rx_error == (_func_void *)0x0)
          {
            return;
          }
          (*uart_inst_array[i_1].DMAcallback_rx_error)();
          return;
        }
      }
    }
  }
  else
  {
    LL_DMA_ClearFlag_GI6((DMA_TypeDef *)&DMA1);
    LL_USART_ClearFlag_ORE((USART_TypeDef *)&USART2);
    LL_DMA_DisableChannel((DMA_TypeDef *)&DMA1,5);
    for (i = 0; i < 1; i += 1)
    {
      if (uart_inst_array[i].dma == (DMA_TypeDef *)0x40020000)
      {
        if (uart_inst_array[i].DMAcallback_rx == (_func_void *)0x0)
        {
          return;
        }
        (*uart_inst_array[i].DMAcallback_rx)();
        return;
      }
    }
  }
  return;
}



void LL_LPTIM_ClearFlag_ARRM(LPTIM_TypeDef *LPTIMx)
{
  LPTIM_TypeDef *LPTIMx_local;
  
  LPTIMx->ICR = LPTIMx->ICR | 2;
  return;
}



uint32_t LL_LPTIM_IsActiveFlag_ARRM(LPTIM_TypeDef *LPTIMx)
{
  LPTIM_TypeDef *LPTIMx_local;
  
  return (uint)((LPTIMx->ISR & 2) == 2);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LPTIM1_IRQHandler(void)
{
  uint32_t uVar1;
  int i;
  
  uVar1 = LL_LPTIM_IsActiveFlag_ARRM((LPTIM_TypeDef *)&LPTIM1);
  if (uVar1 == 1)
  {
    LL_LPTIM_ClearFlag_ARRM((LPTIM_TypeDef *)&LPTIM1);
    for (i = 0; i < 1; i += 1)
    {
      if ((tim_inst_array[i].tim == (LPTIM_TypeDef *)0x40007c00) &&
         (tim_inst_array[i].cfg_app.expiry_func != (_func_void_void_ptr *)0x0))
      {
        (*tim_inst_array[i].cfg_app.expiry_func)(tim_inst_array[i].cfg_app.context);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LPTIM2_IRQHandler(void)
{
  uint32_t uVar1;
  int i;
  
  uVar1 = LL_LPTIM_IsActiveFlag_ARRM((LPTIM_TypeDef *)&LPTIM2);
  if (uVar1 == 1)
  {
    LL_LPTIM_ClearFlag_ARRM((LPTIM_TypeDef *)&LPTIM2);
    for (i = 0; i < 1; i += 1)
    {
      if ((tim_inst_array[i].tim == (LPTIM_TypeDef *)0x40009400) &&
         (tim_inst_array[i].cfg_app.expiry_func != (_func_void_void_ptr *)0x0))
      {
        (*tim_inst_array[i].cfg_app.expiry_func)(tim_inst_array[i].cfg_app.context);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_RCC_HSI_Enable(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  RCC.CR = uVar1 | 0x100;
  return;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_HSI_IsReady(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  return (uint)((uVar1 & 0x400) == 0x400);
}



void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
  uint uVar1;
  uint32_t Value_local;
  
  uVar1 = RCC.ICSCR;
  RCC.ICSCR = Value << 0x18 | uVar1 & 0xe0ffffff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_RCC_LSI_Enable(void)
{
  uint uVar1;
  
  uVar1 = RCC.CSR;
  RCC.CSR = uVar1 | 1;
  return;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_LSI_IsReady(void)
{
  uint uVar1;
  
  uVar1 = RCC.CSR;
  return (uint)((uVar1 & 2) == 2);
}



void LL_RCC_SetSysClkSource(uint32_t Source)
{
  uint uVar1;
  uint32_t Source_local;
  
  uVar1 = RCC.CFGR;
  RCC.CFGR = Source | uVar1 & 0xfffffffc;
  return;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_GetSysClkSource(void)
{
  uint uVar1;
  
  uVar1 = RCC.CFGR;
  return uVar1 & 0xc;
}



void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
  uint uVar1;
  uint32_t Prescaler_local;
  
  uVar1 = RCC.CFGR;
  RCC.CFGR = Prescaler | uVar1 & 0xffffff0f;
  return;
}



void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
{
  uint uVar1;
  uint32_t Prescaler_local;
  
  uVar1 = RCC.CFGR;
  RCC.CFGR = Prescaler | uVar1 & 0xfffff8ff;
  return;
}



void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
{
  uint uVar1;
  uint32_t Prescaler_local;
  
  uVar1 = RCC.CFGR;
  RCC.CFGR = Prescaler | uVar1 & 0xffffc7ff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_RCC_PLL_Enable(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  RCC.CR = uVar1 | 0x1000000;
  return;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_PLL_IsReady(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  return (uint)((uVar1 & 0x2000000) == 0x2000000);
}



void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source,uint32_t PLLM,uint32_t PLLN,uint32_t PLLR)
{
  uint uVar1;
  uint32_t PLLR_local;
  uint32_t PLLN_local;
  uint32_t PLLM_local;
  uint32_t Source_local;
  
  uVar1 = RCC.PLLCFGR;
  RCC.PLLCFGR = uVar1 & 0xf9ff808c | PLLR | Source | PLLM | PLLN << 8;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_RCC_PLL_EnableDomain_SYS(void)
{
  uint uVar1;
  
  uVar1 = RCC.PLLCFGR;
  RCC.PLLCFGR = uVar1 | 0x1000000;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_RCC_PLLSAI1_Enable(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  RCC.CR = uVar1 | 0x4000000;
  return;
}



// WARNING: Unknown calling convention

uint32_t LL_RCC_PLLSAI1_IsReady(void)
{
  uint uVar1;
  
  uVar1 = RCC.CR;
  return (uint)((uVar1 & 0x8000000) == 0x8000000);
}



void LL_RCC_PLLSAI1_ConfigDomain_48M(uint32_t Source,uint32_t PLLM,uint32_t PLLN,uint32_t PLLQ)
{
  uint uVar1;
  uint32_t PLLQ_local;
  uint32_t PLLN_local;
  uint32_t PLLM_local;
  uint32_t Source_local;
  
  uVar1 = RCC.PLLCFGR;
  RCC.PLLCFGR = PLLM | Source | uVar1 & 0xffffff8c;
  uVar1 = RCC.PLLSAI1CFGR;
  RCC.PLLSAI1CFGR = uVar1 & 0xff9f80ff | PLLQ | PLLN << 8;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_RCC_PLLSAI1_EnableDomain_48M(void)
{
  uint uVar1;
  
  uVar1 = RCC.PLLSAI1CFGR;
  RCC.PLLSAI1CFGR = uVar1 | 0x100000;
  return;
}



void LL_FLASH_SetLatency(uint32_t Latency)
{
  uint uVar1;
  uint32_t Latency_local;
  
  uVar1 = FLASH.ACR;
  FLASH.ACR = Latency | uVar1 & 0xfffffff8;
  return;
}



// WARNING: Unknown calling convention

uint32_t LL_FLASH_GetLatency(void)
{
  uint uVar1;
  
  uVar1 = FLASH.ACR;
  return uVar1 & 7;
}



void LL_PWR_SetRegulVoltageScaling(uint32_t VoltageScaling)
{
  uint uVar1;
  uint32_t VoltageScaling_local;
  
  uVar1 = PWR.CR1;
  PWR.CR1 = VoltageScaling | uVar1 & 0xfffff9ff;
  return;
}



void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  uint uVar1;
  uint32_t Periphs_local;
  uint32_t tmpreg;
  
  uVar1 = RCC.APB2ENR;
  RCC.APB2ENR = Periphs | uVar1;
  uVar1 = RCC.APB2ENR;
  return;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_status_t smtc_hal_mcu_init(void)
{
  uint32_t uVar1;
  
  LL_FLASH_SetLatency(4);
  do
  {
    uVar1 = LL_FLASH_GetLatency();
  } while (uVar1 != 4);
  LL_PWR_SetRegulVoltageScaling(0x200);
  LL_RCC_HSI_Enable();
  do
  {
    uVar1 = LL_RCC_HSI_IsReady();
  } while (uVar1 != 1);
  LL_RCC_LSI_Enable();
  do
  {
    uVar1 = LL_RCC_LSI_IsReady();
  } while (uVar1 != 1);
  LL_RCC_HSI_SetCalibTrimming(0x10);
  LL_RCC_PLL_ConfigDomain_SYS(2,0,10,0);
  LL_RCC_PLL_Enable();
  LL_RCC_PLL_EnableDomain_SYS();
  do
  {
    uVar1 = LL_RCC_PLL_IsReady();
  } while (uVar1 != 1);
  LL_RCC_PLLSAI1_ConfigDomain_48M(2,0,0xc,0x200000);
  LL_RCC_PLLSAI1_Enable();
  LL_RCC_PLLSAI1_EnableDomain_48M();
  do
  {
    uVar1 = LL_RCC_PLLSAI1_IsReady();
  } while (uVar1 != 1);
  LL_RCC_SetSysClkSource(3);
  do
  {
    uVar1 = LL_RCC_GetSysClkSource();
  } while (uVar1 != 0xc);
  LL_RCC_SetAHBPrescaler(0);
  LL_RCC_SetAPB1Prescaler(0);
  LL_RCC_SetAPB2Prescaler(0);
  LL_Init1msTick(80000000);
  LL_SetSystemCoreClock(80000000);
  LL_APB2_GRP1_EnableClock(1);
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t smtc_hal_mcu_wait_ms(uint32_t milliseconds)
{
  uint32_t milliseconds_local;
  
  LL_mDelay(milliseconds);
  return SMTC_HAL_MCU_STATUS_OK;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_nvm_init(uint32_t start_address,uint32_t end_address,smtc_hal_mcu_nvm_inst_t *inst)
{
  smtc_hal_mcu_nvm_inst_t psVar1;
  smtc_hal_mcu_status_t sVar2;
  smtc_hal_mcu_nvm_inst_t *inst_local;
  uint32_t end_address_local;
  uint32_t start_address_local;
  smtc_hal_mcu_nvm_inst_t allocated_inst;
  uint8_t index;
  
  psVar1 = smtc_hal_mcu_nvm_stm32l4_get_free_slot();
  if (psVar1 == (smtc_hal_mcu_nvm_inst_t)0x0)
  {
    sVar2 = SMTC_HAL_MCU_STATUS_ERROR;
  }
  else if (((start_address < 0x8000000) || (0x80fffff < end_address)) ||
          (end_address <= start_address))
  {
    sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  else
  {
    for (index = '\0'; index < 0x10; index += '\x01')
    {
      if (((start_address <= nvm_inst_array[index].start_address) &&
          (start_address <= nvm_inst_array[index].end_address)) ||
         ((end_address <= nvm_inst_array[index].start_address &&
          (end_address <= nvm_inst_array[index].end_address))))
      {
        return SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
      }
    }
    psVar1->start_address = start_address;
    psVar1->end_address = end_address;
    psVar1->is_cfged = true;
    *inst = psVar1;
    sVar2 = SMTC_HAL_MCU_STATUS_OK;
  }
  return sVar2;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_nvm_write(smtc_hal_mcu_nvm_inst_t inst,uint32_t offset,uint8_t *buffer,uint32_t length)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  uint uVar3;
  uint64_t doubleword;
  uint32_t length_local;
  uint8_t *buffer_local;
  uint32_t offset_local;
  smtc_hal_mcu_nvm_inst_t inst_local;
  smtc_hal_mcu_status_t local_status_1;
  uint64_t data_to_be_written;
  uint8_t data64_meaningful_len;
  smtc_hal_mcu_status_t local_status_2;
  smtc_hal_mcu_status_t local_status;
  smtc_hal_mcu_status_t status;
  uint32_t address;
  uint32_t buf_index;
  
  _Var1 = smtc_hal_mcu_nvm_stm32l4_is_valid_instance(inst);
  if (_Var1)
  {
    if (inst->is_cfged == true)
    {
      if (length == 0)
      {
        sVar2 = SMTC_HAL_MCU_STATUS_OK;
      }
      else
      {
        buf_index = 0;
        address = inst->start_address + offset;
        _Var1 = smtc_hal_mcu_nvm_smt32l4_is_offset_within_bounds(inst,offset);
        if ((_Var1) &&
           (_Var1 = smtc_hal_mcu_nvm_smt32l4_is_offset_within_bounds(inst,length + offset), _Var1))
        {
          sVar2 = smtc_hal_mcu_nvm_stm32l4_unlock();
          if (sVar2 == SMTC_HAL_MCU_STATUS_OK)
          {
            for (; buf_index < length; buf_index = (uVar3 & 0xff) + buf_index)
            {
              uVar3 = length - buf_index;
              if (7 < uVar3)
              {
                uVar3 = 8;
              }
              doubleword = smtc_hal_mcu_nvm_stm32l4_create_64_bits_data
                                     (buffer + buf_index,(uint8_t)uVar3);
              sVar2 = smtc_hal_mcu_nvm_stm32l4_write_doubleword(doubleword,address);
              if (sVar2 != SMTC_HAL_MCU_STATUS_OK)
              {
                return sVar2;
              }
              address += 8;
            }
            sVar2 = smtc_hal_mcu_nvm_stm32l4_lock();
          }
        }
        else
        {
          sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
        }
      }
    }
    else
    {
      sVar2 = SMTC_HAL_MCU_STATUS_NOT_INIT;
    }
  }
  else
  {
    sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar2;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_nvm_read(smtc_hal_mcu_nvm_inst_t inst,uint32_t offset,uint8_t *buffer,uint32_t length)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  uint32_t uVar3;
  uint32_t length_local;
  uint8_t *buffer_local;
  uint32_t offset_local;
  smtc_hal_mcu_nvm_inst_t inst_local;
  uint32_t start_address;
  uint32_t address;
  
  if (length == 0)
  {
    sVar2 = SMTC_HAL_MCU_STATUS_OK;
  }
  else
  {
    _Var1 = smtc_hal_mcu_nvm_stm32l4_is_valid_instance(inst);
    if (_Var1)
    {
      _Var1 = smtc_hal_mcu_nvm_smt32l4_is_offset_within_bounds(inst,offset);
      if ((_Var1) &&
         (_Var1 = smtc_hal_mcu_nvm_smt32l4_is_offset_within_bounds(inst,length + offset), _Var1))
      {
        uVar3 = inst->start_address + offset;
        buffer_local = buffer;
        for (address = uVar3; (address < length + uVar3 && (address < inst->end_address));
            address += 1)
        {
          *buffer_local = *(uint8_t *)address;
          buffer_local = buffer_local + 1;
        }
        sVar2 = SMTC_HAL_MCU_STATUS_OK;
      }
      else
      {
        sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
      }
    }
    else
    {
      sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
    }
  }
  return sVar2;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_nvm_erase(smtc_hal_mcu_nvm_inst_t inst,uint32_t offset,uint32_t length)
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  uint32_t bank_number_00;
  uint32_t first_page_00;
  uint32_t uVar3;
  uint32_t length_local;
  uint32_t offset_local;
  smtc_hal_mcu_nvm_inst_t inst_local;
  uint32_t pages_number;
  uint32_t first_page;
  uint32_t bank_number;
  uint32_t address;
  
  _Var1 = smtc_hal_mcu_nvm_stm32l4_is_valid_instance(inst);
  if (_Var1)
  {
    uVar3 = inst->start_address + offset;
    bank_number_00 = smtc_hal_mcu_nvm_stm32l4_get_bank_by_address(uVar3);
    first_page_00 = smtc_hal_mcu_nvm_stm32l4_get_page_by_address(uVar3);
    uVar3 = smtc_hal_mcu_nvm_stm32l4_get_page_by_address(length + uVar3);
    sVar2 = smtc_hal_mcu_nvm_stm32l4_erase_pages
                      (bank_number_00,first_page_00,(uVar3 - first_page_00) + 1);
  }
  else
  {
    sVar2 = SMTC_HAL_MCU_STATUS_BAD_PARAMETERS;
  }
  return sVar2;
}



_Bool smtc_hal_mcu_nvm_stm32l4_is_valid_instance(smtc_hal_mcu_nvm_inst_t inst)
{
  smtc_hal_mcu_nvm_inst_t inst_local;
  int i;
  
  i = 0;
  while( true )
  {
    if (0xf < i)
    {
      return false;
    }
    if (inst == nvm_inst_array + i) break;
    i += 1;
  }
  return true;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_status_t smtc_hal_mcu_nvm_stm32l4_unlock(void)
{
  HAL_StatusTypeDef HVar1;
  
  HVar1 = HAL_FLASH_Unlock();
  return HVar1 != HAL_OK;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_status_t smtc_hal_mcu_nvm_stm32l4_lock(void)
{
  HAL_StatusTypeDef HVar1;
  
  HVar1 = HAL_FLASH_Lock();
  return HVar1 != HAL_OK;
}



_Bool smtc_hal_mcu_nvm_smt32l4_is_offset_within_bounds(smtc_hal_mcu_nvm_inst_t inst,uint32_t offset)
{
  uint uVar1;
  undefined1 uVar2;
  uint uVar3;
  uint uVar4;
  uint32_t offset_local;
  smtc_hal_mcu_nvm_inst_t inst_local;
  
  uVar1 = inst->start_address + offset;
  uVar3 = inst->end_address;
  uVar4 = uVar3;
  if (uVar1 <= uVar3)
  {
    uVar4 = 1;
  }
  uVar2 = (undefined1)uVar4;
  if (uVar3 < uVar1)
  {
    uVar2 = 0;
  }
  return (_Bool)uVar2;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_nvm_stm32l4_write_doubleword(uint64_t doubleword,uint32_t address)
{
  HAL_StatusTypeDef HVar1;
  uint32_t address_local;
  uint64_t doubleword_local;
  smtc_hal_mcu_status_t status;
  
  HVar1 = HAL_FLASH_Program(0,address,doubleword);
  return HVar1 != HAL_OK;
}



smtc_hal_mcu_status_t
smtc_hal_mcu_nvm_stm32l4_erase_pages(uint32_t bank_number,uint32_t first_page,uint32_t pages_number)
{
  HAL_StatusTypeDef HVar1;
  uint32_t pages_number_local;
  uint32_t first_page_local;
  uint32_t bank_number_local;
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t page_error;
  smtc_hal_mcu_status_t local_status_1;
  smtc_hal_mcu_status_t local_status;
  smtc_hal_mcu_status_t status;
  
  status = SMTC_HAL_MCU_STATUS_OK;
  EraseInitStruct.TypeErase = 0;
  EraseInitStruct.Banks = bank_number;
  EraseInitStruct.Page = first_page;
  EraseInitStruct.NbPages = pages_number;
  status = smtc_hal_mcu_nvm_stm32l4_unlock();
  if (status == SMTC_HAL_MCU_STATUS_OK)
  {
    FLASH.SR = 0x8000;
    local_status = status;
    HVar1 = HAL_FLASHEx_Erase(&EraseInitStruct,&page_error);
    if (HVar1 == HAL_OK)
    {
      status = smtc_hal_mcu_nvm_stm32l4_lock();
    }
    else
    {
      status = SMTC_HAL_MCU_STATUS_ERROR;
      smtc_hal_mcu_nvm_stm32l4_lock();
    }
  }
  return status;
}



uint64_t smtc_hal_mcu_nvm_stm32l4_create_64_bits_data(uint8_t *buf,uint8_t len)
{
  byte bVar1;
  uint uVar2;
  uint8_t len_local;
  uint8_t *buf_local;
  uint64_t temp;
  uint8_t i;
  uint64_t data64;
  
  data64._0_4_ = 0;
  data64._4_4_ = 0;
  if (len < 9)
  {
    buf_local = buf;
    for (i = '\0'; i < len; i += '\x01')
    {
      bVar1 = *buf_local;
      uVar2 = (uint)i * 8;
      (uint)data64 |= (uint)bVar1 << (uVar2 & 0xff);
      data64._4_4_ |=
           0 << (uVar2 & 0xff) | (uint)bVar1 << (uVar2 - 0x20 & 0xff) |
           (uint)(bVar1 >> ((uint)i * -8 + 0x20 & 0xff));
      buf_local = buf_local + 1;
    }
  }
  else
  {
    data64._0_4_ = 0;
    data64._4_4_ = 0;
  }
  return CONCAT44(data64._4_4_,(uint)data64);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t smtc_hal_mcu_nvm_stm32l4_get_bank_by_address(uint32_t addr)
{
  uint uVar1;
  uint32_t addr_local;
  uint32_t bank;
  
  uVar1 = SYSCFG.MEMRMP;
  if ((uVar1 & 0x100) == 0)
  {
    if ((_DAT_1fff75e0 & 0xffff) == 0xffff)
    {
      uVar1 = 0x8080000;
    }
    else
    {
      uVar1 = ((_DAT_1fff75e0 << 10) >> 1 & 0x1fffe00) + 0x8000000;
    }
    if (addr < uVar1)
    {
      bank = 1;
    }
    else
    {
      bank = 2;
    }
  }
  else
  {
    if ((_DAT_1fff75e0 & 0xffff) == 0xffff)
    {
      uVar1 = 0x8080000;
    }
    else
    {
      uVar1 = ((_DAT_1fff75e0 << 10) >> 1 & 0x1fffe00) + 0x8000000;
    }
    if (addr < uVar1)
    {
      bank = 2;
    }
    else
    {
      bank = 1;
    }
  }
  return bank;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t smtc_hal_mcu_nvm_stm32l4_get_page_by_address(uint32_t addr)
{
  uint uVar1;
  int iVar2;
  uint32_t addr_local;
  uint32_t page;
  
  if ((_DAT_1fff75e0 & 0xffff) == 0xffff)
  {
    uVar1 = 0x8080000;
  }
  else
  {
    uVar1 = ((_DAT_1fff75e0 << 10) >> 1 & 0x1fffe00) + 0x8000000;
  }
  if (addr < uVar1)
  {
    uVar1 = addr + 0xf8000000;
  }
  else
  {
    if ((_DAT_1fff75e0 & 0xffff) == 0xffff)
    {
      iVar2 = 0x8080000;
    }
    else
    {
      iVar2 = ((_DAT_1fff75e0 << 10) >> 1 & 0x1fffe00) + 0x8000000;
    }
    uVar1 = addr - iVar2;
  }
  page = uVar1 >> 0xb;
  return page;
}



// WARNING: Unknown calling convention

smtc_hal_mcu_nvm_inst_t smtc_hal_mcu_nvm_stm32l4_get_free_slot(void)
{
  int i;
  
  i = 0;
  while( true )
  {
    if (0xf < i)
    {
      return (smtc_hal_mcu_nvm_inst_t)0x0;
    }
    if (nvm_inst_array[i].is_cfged != true) break;
    i += 1;
  }
  return nvm_inst_array + i;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void SystemInit(void)
{
  _DAT_e000ed88 = _DAT_e000ed88 | 0xf00000;
  return;
}



void * system_alloc(void *allocator_data,size_t size)
{
  void *pvVar1;
  size_t size_local;
  void *allocator_data_local;
  
  pvVar1 = malloc(size);
  return pvVar1;
}



void system_free(void *allocator_data,void *data)
{
  void *data_local;
  void *allocator_data_local;
  
  free(data);
  return;
}



void * do_alloc(ProtobufCAllocator *allocator,size_t size)
{
  void *pvVar1;
  size_t size_local;
  ProtobufCAllocator *allocator_local;
  
  pvVar1 = (*allocator->alloc)(allocator->allocator_data,size);
  return pvVar1;
}



void do_free(ProtobufCAllocator *allocator,void *data)
{
  void *data_local;
  ProtobufCAllocator *allocator_local;
  
  if (data != (void *)0x0)
  {
    (*allocator->free)(allocator->allocator_data,data);
  }
  return;
}



size_t get_tag_size(uint32_t number)
{
  size_t sVar1;
  uint32_t number_local;
  
  if (number < 0x10)
  {
    sVar1 = 1;
  }
  else if (number < 0x800)
  {
    sVar1 = 2;
  }
  else if (number < 0x40000)
  {
    sVar1 = 3;
  }
  else if (number < 0x2000000)
  {
    sVar1 = 4;
  }
  else
  {
    sVar1 = 5;
  }
  return sVar1;
}



size_t uint32_size(uint32_t v)
{
  size_t sVar1;
  uint32_t v_local;
  
  if (v < 0x80)
  {
    sVar1 = 1;
  }
  else if (v < 0x4000)
  {
    sVar1 = 2;
  }
  else if (v < 0x200000)
  {
    sVar1 = 3;
  }
  else if (v < 0x10000000)
  {
    sVar1 = 4;
  }
  else
  {
    sVar1 = 5;
  }
  return sVar1;
}



size_t int32_size(int32_t v)
{
  size_t sVar1;
  int32_t v_local;
  
  if (v < 0)
  {
    sVar1 = 10;
  }
  else if (v < 0x80)
  {
    sVar1 = 1;
  }
  else if (v < 0x4000)
  {
    sVar1 = 2;
  }
  else if (v < 0x200000)
  {
    sVar1 = 3;
  }
  else if (v < 0x10000000)
  {
    sVar1 = 4;
  }
  else
  {
    sVar1 = 5;
  }
  return sVar1;
}



uint32_t zigzag32(int32_t v)
{
  int32_t v_local;
  
  return v << 1 ^ v >> 0x1f;
}



size_t sint32_size(int32_t v)
{
  uint32_t v_00;
  size_t sVar1;
  int32_t v_local;
  
  v_00 = zigzag32(v);
  sVar1 = uint32_size(v_00);
  return sVar1;
}



size_t uint64_size(uint64_t v)
{
  size_t sVar1;
  uint64_t v_local;
  uint32_t upper_v;
  
  v_local._4_4_ = (int)(v >> 0x20);
  if (v_local._4_4_ == 0)
  {
    v_local._0_4_ = (uint32_t)v;
    sVar1 = uint32_size((uint32_t)v_local);
  }
  else if (v < 0x800000000)
  {
    sVar1 = 5;
  }
  else if (v < 0x40000000000)
  {
    sVar1 = 6;
  }
  else if (v < 0x2000000000000)
  {
    sVar1 = 7;
  }
  else if (v < 0x100000000000000)
  {
    sVar1 = 8;
  }
  else if ((longlong)v < 0)
  {
    sVar1 = 10;
  }
  else
  {
    sVar1 = 9;
  }
  return sVar1;
}



uint64_t zigzag64(int64_t v)
{
  int64_t v_local;
  
  v_local._0_4_ = (uint)v;
  v_local._4_4_ = (int)((ulonglong)v >> 0x20);
  return CONCAT44(v_local._4_4_ * 2 + (uint)CARRY4((uint)v_local,(uint)v_local) ^
                  v_local._4_4_ >> 0x1f,(uint)v_local * 2 ^ v_local._4_4_ >> 0x1f);
}



size_t sint64_size(int64_t v)
{
  size_t sVar1;
  uint64_t v_00;
  int64_t v_local;
  
  v_00 = zigzag64(v);
  sVar1 = uint64_size(v_00);
  return sVar1;
}



size_t required_field_get_packed_size(ProtobufCFieldDescriptor *field,void *member)
{
  size_t sVar1;
  size_t v;
  size_t sVar2;
  size_t sVar3;
  uint32_t v_00;
  void *member_local;
  ProtobufCFieldDescriptor *field_local;
  size_t len;
  char *str;
  size_t len_1;
  size_t subrv;
  ProtobufCMessage *msg;
  size_t rv;
  
  sVar1 = get_tag_size(field->id);
  switch(field->type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_ENUM:
                    // WARNING: Load size is inaccurate
    sVar2 = int32_size(*member);
    sVar2 = sVar1 + sVar2;
    break;
  case PROTOBUF_C_TYPE_SINT32:
                    // WARNING: Load size is inaccurate
    sVar2 = sint32_size(*member);
    sVar2 = sVar1 + sVar2;
    break;
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_FIXED32:
    sVar2 = sVar1 + 4;
    break;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_UINT64:
                    // WARNING: Load size is inaccurate
    sVar2 = uint64_size(*member);
    sVar2 = sVar1 + sVar2;
    break;
  case PROTOBUF_C_TYPE_SINT64:
                    // WARNING: Load size is inaccurate
    sVar2 = sint64_size(*member);
    sVar2 = sVar1 + sVar2;
    break;
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_FIXED64:
    sVar2 = sVar1 + 8;
    break;
  case PROTOBUF_C_TYPE_UINT32:
                    // WARNING: Load size is inaccurate
    sVar2 = uint32_size(*member);
    sVar2 = sVar1 + sVar2;
    break;
  case PROTOBUF_C_TYPE_FLOAT:
    sVar2 = sVar1 + 4;
    break;
  case PROTOBUF_C_TYPE_DOUBLE:
    sVar2 = sVar1 + 8;
    break;
  case PROTOBUF_C_TYPE_BOOL:
    sVar2 = sVar1 + 1;
    break;
  case PROTOBUF_C_TYPE_STRING:
                    // WARNING: Load size is inaccurate
    if (*member == (char *)0x0)
    {
      v = 0;
    }
    else
    {
      v = strlen(*member);
    }
    sVar2 = uint32_size(v);
    sVar2 = v + sVar2 + sVar1;
    break;
  case PROTOBUF_C_TYPE_BYTES:
                    // WARNING: Load size is inaccurate
    v_00 = *member;
    sVar2 = uint32_size(v_00);
    sVar2 = v_00 + sVar2 + sVar1;
    break;
  case PROTOBUF_C_TYPE_MESSAGE:
                    // WARNING: Load size is inaccurate
    if (*member == (ProtobufCMessage *)0x0)
    {
      sVar2 = 0;
    }
    else
    {
      sVar2 = protobuf_c_message_get_packed_size(*member);
    }
    sVar3 = uint32_size(sVar2);
    sVar2 += sVar3 + sVar1;
    break;
  default:
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x1cb,"required_field_get_packed_size"
                  ,"0");
  }
  return sVar2;
}



size_t oneof_field_get_packed_size(ProtobufCFieldDescriptor *field,uint32_t oneof_case,void *member)
{
  size_t sVar1;
  void *member_local;
  uint32_t oneof_case_local;
  ProtobufCFieldDescriptor *field_local;
  void *ptr;
  
  if (oneof_case == field->id)
  {
                    // WARNING: Load size is inaccurate
    if (((field->type == PROTOBUF_C_TYPE_MESSAGE) || (field->type == PROTOBUF_C_TYPE_STRING)) &&
       ((*member == (void *)0x0 || (*member == field->default_value))))
    {
      sVar1 = 0;
    }
    else
    {
      sVar1 = required_field_get_packed_size(field,member);
    }
  }
  else
  {
    sVar1 = 0;
  }
  return sVar1;
}



size_t optional_field_get_packed_size
                 (ProtobufCFieldDescriptor *field,protobuf_c_boolean has,void *member)
{
  size_t sVar1;
  void *member_local;
  protobuf_c_boolean has_local;
  ProtobufCFieldDescriptor *field_local;
  void *ptr;
  
  if ((field->type == PROTOBUF_C_TYPE_MESSAGE) || (field->type == PROTOBUF_C_TYPE_STRING))
  {
                    // WARNING: Load size is inaccurate
    if ((*member == (void *)0x0) || (*member == field->default_value))
    {
      return 0;
    }
  }
  else if (has == 0)
  {
    return 0;
  }
  sVar1 = required_field_get_packed_size(field,member);
  return sVar1;
}



protobuf_c_boolean field_is_zeroish(ProtobufCFieldDescriptor *field,void *member)
{
  byte bVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;
  float fVar5;
  void *member_local;
  ProtobufCFieldDescriptor *field_local;
  protobuf_c_boolean ret;
  
  switch(field->type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_SINT32:
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_UINT32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_ENUM:
                    // WARNING: Load size is inaccurate
    iVar3 = *member;
    bVar4 = iVar3 == 0;
    if (bVar4)
    {
      iVar3 = 1;
    }
    bVar1 = (byte)iVar3;
    if (!bVar4)
    {
      bVar1 = 0;
    }
    ret = (protobuf_c_boolean)bVar1;
    break;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_SINT64:
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_UINT64:
  case PROTOBUF_C_TYPE_FIXED64:
                    // WARNING: Load size is inaccurate
    uVar2 = *(uint *)((int)member + 4) | *member;
    bVar4 = uVar2 == 0;
    if (bVar4)
    {
      uVar2 = 1;
    }
    bVar1 = (byte)uVar2;
    if (!bVar4)
    {
      bVar1 = 0;
    }
    ret = (protobuf_c_boolean)bVar1;
    break;
  case PROTOBUF_C_TYPE_FLOAT:
                    // WARNING: Load size is inaccurate
    fVar5 = *member;
    if (fVar5 == 0.0)
    {
      member = (void *)0x1;
    }
    bVar1 = (byte)member;
    if (fVar5 != 0.0)
    {
      bVar1 = 0;
    }
    ret = (protobuf_c_boolean)bVar1;
    break;
  case PROTOBUF_C_TYPE_DOUBLE:
                    // WARNING: Load size is inaccurate
    bVar4 = __aeabi_dcmpeq(*member,*(uint *)((int)member + 4),0,0);
    ret = (protobuf_c_boolean)bVar4;
    break;
  case PROTOBUF_C_TYPE_BOOL:
                    // WARNING: Load size is inaccurate
    iVar3 = *member;
    bVar4 = iVar3 == 0;
    if (bVar4)
    {
      iVar3 = 1;
    }
    bVar1 = (byte)iVar3;
    if (!bVar4)
    {
      bVar1 = 0;
    }
    ret = (protobuf_c_boolean)bVar1;
    break;
  case PROTOBUF_C_TYPE_STRING:
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
    if ((*member == 0) || (**member == '\0'))
    {
      ret = 1;
    }
    else
    {
      ret = 0;
    }
    break;
  case PROTOBUF_C_TYPE_BYTES:
  case PROTOBUF_C_TYPE_MESSAGE:
                    // WARNING: Load size is inaccurate
    iVar3 = *member;
    bVar4 = iVar3 == 0;
    if (bVar4)
    {
      iVar3 = 1;
    }
    bVar1 = (byte)iVar3;
    if (!bVar4)
    {
      bVar1 = 0;
    }
    ret = (protobuf_c_boolean)bVar1;
    break;
  default:
    ret = 1;
  }
  return ret;
}



size_t unlabeled_field_get_packed_size(ProtobufCFieldDescriptor *field,void *member)
{
  protobuf_c_boolean pVar1;
  size_t sVar2;
  void *member_local;
  ProtobufCFieldDescriptor *field_local;
  
  pVar1 = field_is_zeroish(field,member);
  if (pVar1 == 0)
  {
    sVar2 = required_field_get_packed_size(field,member);
  }
  else
  {
    sVar2 = 0;
  }
  return sVar2;
}



size_t repeated_field_get_packed_size(ProtobufCFieldDescriptor *field,size_t count,void *member)
{
  size_t v;
  size_t sVar1;
  int iVar2;
  size_t sVar3;
  uint32_t v_00;
  void *member_local;
  size_t count_local;
  ProtobufCFieldDescriptor *field_local;
  size_t len;
  size_t len_1;
  size_t len_2;
  void *array;
  uint i;
  size_t rv;
  size_t header_size;
  
  rv = 0;
                    // WARNING: Load size is inaccurate
  iVar2 = *member;
  if (count == 0)
  {
    sVar3 = 0;
  }
  else
  {
    header_size = get_tag_size(field->id);
    if ((field->flags & 1) == 0)
    {
      header_size = count * header_size;
    }
    switch(field->type)
    {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_ENUM:
      for (i = 0; i < count; i += 1)
      {
        sVar3 = int32_size(*(int32_t *)(i * 4 + iVar2));
        rv += sVar3;
      }
      break;
    case PROTOBUF_C_TYPE_SINT32:
      for (i = 0; i < count; i += 1)
      {
        sVar3 = sint32_size(*(int32_t *)(i * 4 + iVar2));
        rv += sVar3;
      }
      break;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      rv = count * 4;
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      for (i = 0; i < count; i += 1)
      {
        sVar3 = uint64_size(*(uint64_t *)(i * 8 + iVar2));
        rv += sVar3;
      }
      break;
    case PROTOBUF_C_TYPE_SINT64:
      for (i = 0; i < count; i += 1)
      {
        sVar3 = sint64_size(*(int64_t *)(i * 8 + iVar2));
        rv += sVar3;
      }
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      rv = count * 8;
      break;
    case PROTOBUF_C_TYPE_UINT32:
      for (i = 0; i < count; i += 1)
      {
        sVar3 = uint32_size(*(uint32_t *)(i * 4 + iVar2));
        rv += sVar3;
      }
      break;
    case PROTOBUF_C_TYPE_BOOL:
      rv = count;
      break;
    case PROTOBUF_C_TYPE_STRING:
      for (i = 0; i < count; i += 1)
      {
        v = strlen(*(char **)(i * 4 + iVar2));
        sVar3 = uint32_size(v);
        rv = v + sVar3 + rv;
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      for (i = 0; i < count; i += 1)
      {
        v_00 = *(uint32_t *)(i * 8 + iVar2);
        sVar3 = uint32_size(v_00);
        rv = v_00 + sVar3 + rv;
      }
      break;
    case PROTOBUF_C_TYPE_MESSAGE:
      for (i = 0; i < count; i += 1)
      {
        sVar3 = protobuf_c_message_get_packed_size(*(ProtobufCMessage **)(i * 4 + iVar2));
        sVar1 = uint32_size(sVar3);
        rv = sVar3 + sVar1 + rv;
      }
    }
    if ((field->flags & 1) != 0)
    {
      sVar3 = uint32_size(rv);
      header_size += sVar3;
    }
    sVar3 = rv + header_size;
  }
  return sVar3;
}



size_t unknown_field_get_packed_size(ProtobufCMessageUnknownField *field)
{
  size_t sVar1;
  ProtobufCMessageUnknownField *field_local;
  
  sVar1 = get_tag_size(field->tag);
  return field->len + sVar1;
}



size_t protobuf_c_message_get_packed_size(ProtobufCMessage *message)
{
  size_t sVar1;
  ProtobufCFieldDescriptor *field_00;
  void *member_00;
  uint32_t *puVar2;
  ProtobufCMessage *message_local;
  void *qmember;
  void *member;
  ProtobufCFieldDescriptor *field;
  size_t rv;
  uint i;
  
  rv = 0;
  if (message->descriptor->magic != 0x28aaeef9)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x2c9,
                  "protobuf_c_message_get_packed_size",
                  "((message)->descriptor)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
  }
  for (i = 0; i < message->descriptor->n_fields; i += 1)
  {
    field_00 = message->descriptor->fields + i;
    member_00 = (void *)((int)&message->descriptor + field_00->offset);
    puVar2 = (uint32_t *)((int)&message->descriptor + field_00->quantifier_offset);
    if (field_00->label == PROTOBUF_C_LABEL_REQUIRED)
    {
      sVar1 = required_field_get_packed_size(field_00,member_00);
      rv += sVar1;
    }
    else if (((field_00->label == PROTOBUF_C_LABEL_OPTIONAL) ||
             (field_00->label == PROTOBUF_C_LABEL_NONE)) && ((field_00->flags & 4) != 0))
    {
      sVar1 = oneof_field_get_packed_size(field_00,*puVar2,member_00);
      rv += sVar1;
    }
    else if (field_00->label == PROTOBUF_C_LABEL_OPTIONAL)
    {
      sVar1 = optional_field_get_packed_size(field_00,*puVar2,member_00);
      rv += sVar1;
    }
    else if (field_00->label == PROTOBUF_C_LABEL_NONE)
    {
      sVar1 = unlabeled_field_get_packed_size(field_00,member_00);
      rv += sVar1;
    }
    else
    {
      sVar1 = repeated_field_get_packed_size(field_00,*puVar2,member_00);
      rv += sVar1;
    }
  }
  for (i = 0; i < message->n_unknown_fields; i += 1)
  {
    sVar1 = unknown_field_get_packed_size(message->unknown_fields + i);
    rv += sVar1;
  }
  return rv;
}



size_t uint32_pack(uint32_t value,uint8_t *out)
{
  uint8_t *out_local;
  uint32_t value_local;
  uint rv;
  
  rv = 0;
  value_local = value;
  if (0x7f < value)
  {
    rv = 1;
    *out = (byte)value | 0x80;
    value_local = value >> 7;
    if (0x7f < value_local)
    {
      rv = 2;
      out[1] = (byte)value_local | 0x80;
      value_local = value >> 0xe;
      if (0x7f < value_local)
      {
        rv = 3;
        out[2] = (byte)value_local | 0x80;
        value_local = value >> 0x15;
        if (0x7f < value_local)
        {
          rv = 4;
          out[3] = (byte)value_local | 0x80;
          value_local = value >> 0x1c;
        }
      }
    }
  }
  out[rv] = (uint8_t)value_local;
  return rv + 1;
}



size_t int32_pack(uint32_t value,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  uint32_t value_local;
  
  if ((int)value < 0)
  {
    *out = (byte)value | 0x80;
    out[1] = (byte)(value >> 7) | 0x80;
    out[2] = (byte)(value >> 0xe) | 0x80;
    out[3] = (byte)(value >> 0x15) | 0x80;
    out[4] = (byte)(value >> 0x1c) | 0xf0;
    out[8] = 0xff;
    out[7] = out[8];
    out[6] = out[7];
    out[5] = out[6];
    out[9] = '\x01';
    sVar1 = 10;
  }
  else
  {
    sVar1 = uint32_pack(value,out);
  }
  return sVar1;
}



size_t sint32_pack(int32_t value,uint8_t *out)
{
  uint32_t value_00;
  size_t sVar1;
  uint8_t *out_local;
  int32_t value_local;
  
  value_00 = zigzag32(value);
  sVar1 = uint32_pack(value_00,out);
  return sVar1;
}



size_t uint64_pack(uint64_t value,uint8_t *out)
{
  byte bVar1;
  size_t sVar2;
  uint8_t *out_local;
  uint64_t value_local;
  uint32_t lo;
  uint rv;
  uint32_t hi;
  
  value_local._4_4_ = (uint)(value >> 0x20);
  value_local._0_4_ = (uint32_t)value;
  if (value_local._4_4_ == 0)
  {
    sVar2 = uint32_pack((uint32_t)value_local,out);
  }
  else
  {
    *out = (byte)value | 0x80;
    out[1] = (byte)((uint32_t)value_local >> 7) | 0x80;
    out[2] = (byte)((uint32_t)value_local >> 0xe) | 0x80;
    out[3] = (byte)((uint32_t)value_local >> 0x15) | 0x80;
    bVar1 = (byte)(value >> 0x18);
    if (value < 0x800000000)
    {
      out[4] = bVar1 >> 4 | (byte)((value_local._4_4_ & 0xf) << 4);
      sVar2 = 5;
    }
    else
    {
      out[4] = bVar1 >> 4 | (byte)((value_local._4_4_ & 7) << 4) | 0x80;
      rv = 5;
      for (hi = value_local._4_4_ >> 3; 0x7f < hi; hi >>= 7)
      {
        out[rv] = (byte)hi | 0x80;
        rv = rv + 1;
      }
      sVar2 = rv + 1;
      out[rv] = (byte)hi;
    }
  }
  return sVar2;
}



size_t sint64_pack(int64_t value,uint8_t *out)
{
  size_t sVar1;
  uint64_t value_00;
  uint8_t *out_local;
  int64_t value_local;
  
  value_00 = zigzag64(value);
  sVar1 = uint64_pack(value_00,out);
  return sVar1;
}



size_t fixed32_pack(uint32_t value,void *out)
{
  void *out_local;
  uint32_t value_local;
  
  *(uint32_t *)out = value;
  return 4;
}



size_t fixed64_pack(uint64_t value,void *out)
{
  void *out_local;
  uint64_t value_local;
  
  value_local = value;
  memcpy(out,&value_local,8);
  return 8;
}



size_t boolean_pack(protobuf_c_boolean value,uint8_t *out)
{
  uint8_t uVar1;
  bool bVar2;
  uint8_t *out_local;
  protobuf_c_boolean value_local;
  
  bVar2 = value != 0;
  if (bVar2)
  {
    value = 1;
  }
  uVar1 = (uint8_t)value;
  if (!bVar2)
  {
    uVar1 = '\0';
  }
  *out = uVar1;
  return 1;
}



size_t string_pack(char *str,uint8_t *out)
{
  size_t value;
  size_t sVar1;
  uint8_t *out_local;
  char *str_local;
  size_t rv;
  size_t len;
  
  if (str == (char *)0x0)
  {
    *out = '\0';
    sVar1 = 1;
  }
  else
  {
    value = strlen(str);
    sVar1 = uint32_pack(value,out);
    memcpy(out + sVar1,str,value);
    sVar1 = value + sVar1;
  }
  return sVar1;
}



size_t binary_data_pack(ProtobufCBinaryData *bd,uint8_t *out)
{
  size_t sVar1;
  uint32_t value;
  uint8_t *out_local;
  ProtobufCBinaryData *bd_local;
  size_t rv;
  size_t len;
  
  value = bd->len;
  sVar1 = uint32_pack(value,out);
  memcpy(out + sVar1,bd->data,value);
  return value + sVar1;
}



size_t prefixed_message_pack(ProtobufCMessage *message,uint8_t *out)
{
  size_t sVar1;
  size_t sVar2;
  uint8_t *out_local;
  ProtobufCMessage *message_local;
  uint32_t rv_packed_size;
  size_t rv;
  
  if (message == (ProtobufCMessage *)0x0)
  {
    *out = '\0';
    sVar2 = 1;
  }
  else
  {
    sVar2 = protobuf_c_message_pack(message,out + 1);
    sVar1 = uint32_size(sVar2);
    if (sVar1 != 1)
    {
      memmove(out + sVar1,out + 1,sVar2);
    }
    sVar1 = uint32_pack(sVar2,out);
    sVar2 += sVar1;
  }
  return sVar2;
}



size_t tag_pack(uint32_t id,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  uint32_t id_local;
  
  if (id < 0x20000000)
  {
    sVar1 = uint32_pack(id << 3,out);
  }
  else
  {
    sVar1 = uint64_pack(CONCAT44(id >> 0x1d,id << 3),out);
  }
  return sVar1;
}



size_t required_field_pack(ProtobufCFieldDescriptor *field,void *member,uint8_t *out)
{
  size_t sVar1;
  size_t sVar2;
  uint8_t *out_local;
  void *member_local;
  ProtobufCFieldDescriptor *field_local;
  size_t rv;
  
  sVar1 = tag_pack(field->id,out);
  switch(field->type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_ENUM:
    *out = *out;
                    // WARNING: Load size is inaccurate
    sVar2 = int32_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_SINT32:
    *out = *out;
                    // WARNING: Load size is inaccurate
    sVar2 = sint32_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_FLOAT:
    *out = *out | 5;
                    // WARNING: Load size is inaccurate
    sVar2 = fixed32_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_UINT64:
    *out = *out;
                    // WARNING: Load size is inaccurate
    sVar2 = uint64_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_SINT64:
    *out = *out;
                    // WARNING: Load size is inaccurate
    sVar2 = sint64_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_FIXED64:
  case PROTOBUF_C_TYPE_DOUBLE:
    *out = *out | 1;
                    // WARNING: Load size is inaccurate
    sVar2 = fixed64_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_UINT32:
    *out = *out;
                    // WARNING: Load size is inaccurate
    sVar2 = uint32_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_BOOL:
    *out = *out;
                    // WARNING: Load size is inaccurate
    sVar2 = boolean_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_STRING:
    *out = *out | 2;
                    // WARNING: Load size is inaccurate
    sVar2 = string_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_BYTES:
    *out = *out | 2;
    sVar2 = binary_data_pack((ProtobufCBinaryData *)member,out + sVar1);
    sVar1 += sVar2;
    break;
  case PROTOBUF_C_TYPE_MESSAGE:
    *out = *out | 2;
                    // WARNING: Load size is inaccurate
    sVar2 = prefixed_message_pack(*member,out + sVar1);
    sVar1 += sVar2;
    break;
  default:
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x470,"required_field_pack","0");
  }
  return sVar1;
}



size_t oneof_field_pack(ProtobufCFieldDescriptor *field,uint32_t oneof_case,void *member,
                       uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  void *member_local;
  uint32_t oneof_case_local;
  ProtobufCFieldDescriptor *field_local;
  void *ptr;
  
  if (oneof_case == field->id)
  {
                    // WARNING: Load size is inaccurate
    if (((field->type == PROTOBUF_C_TYPE_MESSAGE) || (field->type == PROTOBUF_C_TYPE_STRING)) &&
       ((*member == (void *)0x0 || (*member == field->default_value))))
    {
      sVar1 = 0;
    }
    else
    {
      sVar1 = required_field_pack(field,member,out);
    }
  }
  else
  {
    sVar1 = 0;
  }
  return sVar1;
}



size_t optional_field_pack(ProtobufCFieldDescriptor *field,protobuf_c_boolean has,void *member,
                          uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  void *member_local;
  protobuf_c_boolean has_local;
  ProtobufCFieldDescriptor *field_local;
  void *ptr;
  
  if ((field->type == PROTOBUF_C_TYPE_MESSAGE) || (field->type == PROTOBUF_C_TYPE_STRING))
  {
                    // WARNING: Load size is inaccurate
    if ((*member == (void *)0x0) || (*member == field->default_value))
    {
      return 0;
    }
  }
  else if (has == 0)
  {
    return 0;
  }
  sVar1 = required_field_pack(field,member,out);
  return sVar1;
}



size_t unlabeled_field_pack(ProtobufCFieldDescriptor *field,void *member,uint8_t *out)
{
  protobuf_c_boolean pVar1;
  size_t sVar2;
  uint8_t *out_local;
  void *member_local;
  ProtobufCFieldDescriptor *field_local;
  
  pVar1 = field_is_zeroish(field,member);
  if (pVar1 == 0)
  {
    sVar2 = required_field_pack(field,member,out);
  }
  else
  {
    sVar2 = 0;
  }
  return sVar2;
}



size_t sizeof_elt_in_repeated_array(ProtobufCType type)
{
  size_t sVar1;
  ProtobufCType type_local;
  
  switch(type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_SINT32:
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_UINT32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_FLOAT:
  case PROTOBUF_C_TYPE_ENUM:
    sVar1 = 4;
    break;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_SINT64:
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_UINT64:
  case PROTOBUF_C_TYPE_FIXED64:
  case PROTOBUF_C_TYPE_DOUBLE:
    sVar1 = 8;
    break;
  case PROTOBUF_C_TYPE_BOOL:
    sVar1 = 4;
    break;
  case PROTOBUF_C_TYPE_STRING:
  case PROTOBUF_C_TYPE_MESSAGE:
    sVar1 = 4;
    break;
  case PROTOBUF_C_TYPE_BYTES:
    sVar1 = 8;
    break;
  default:
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x4ef,"sizeof_elt_in_repeated_array",
                  "0");
  }
  return sVar1;
}



void copy_to_little_endian_32(void *out,void *in,uint n)
{
  uint n_local;
  void *in_local;
  void *out_local;
  
  memcpy(out,in,n << 2);
  return;
}



void copy_to_little_endian_64(void *out,void *in,uint n)
{
  uint n_local;
  void *in_local;
  void *out_local;
  
  memcpy(out,in,n << 3);
  return;
}



uint get_type_min_size(ProtobufCType type)
{
  uint uVar1;
  ProtobufCType type_local;
  
  if (((type == PROTOBUF_C_TYPE_SFIXED32) || (type == PROTOBUF_C_TYPE_FIXED32)) ||
     (type == PROTOBUF_C_TYPE_FLOAT))
  {
    uVar1 = 4;
  }
  else if (((type == PROTOBUF_C_TYPE_SFIXED64) || (type == PROTOBUF_C_TYPE_FIXED64)) ||
          (type == PROTOBUF_C_TYPE_DOUBLE))
  {
    uVar1 = 8;
  }
  else
  {
    uVar1 = 1;
  }
  return uVar1;
}



size_t repeated_field_pack(ProtobufCFieldDescriptor *field,size_t count,void *member,uint8_t *out)
{
  size_t sVar1;
  uint uVar2;
  size_t sVar3;
  size_t sVar4;
  uint32_t v;
  uint8_t *out_local;
  void *member_local;
  size_t count_local;
  ProtobufCFieldDescriptor *field_local;
  uint actual_length_size;
  uint payload_len;
  int32_t *arr;
  int32_t *arr_1;
  uint64_t *arr_4;
  int64_t *arr_2;
  uint32_t *arr_3;
  protobuf_c_boolean *arr_5;
  uint length_size_min;
  uint min_length;
  uint len_start;
  uint siz;
  size_t rv;
  uint8_t *payload_at;
  uint header_len;
  uint i;
  void *array;
  
                    // WARNING: Load size is inaccurate
  array = *member;
  if ((field->flags & 1) == 0)
  {
    rv = 0;
    sVar1 = sizeof_elt_in_repeated_array(field->type);
    for (i = 0; i < count; i += 1)
    {
      sVar3 = required_field_pack(field,array,out + rv);
      rv += sVar3;
      array = (void *)(sVar1 + (int)array);
    }
  }
  else if (count == 0)
  {
    rv = 0;
  }
  else
  {
    sVar1 = tag_pack(field->id,out);
    *out = *out | 2;
    uVar2 = get_type_min_size(field->type);
    sVar3 = uint32_size(uVar2 * count);
    header_len = sVar3 + sVar1;
    payload_at = out + header_len;
    switch(field->type)
    {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_ENUM:
      for (i = 0; i < count; i += 1)
      {
        sVar4 = int32_pack(*(uint32_t *)(i * 4 + (int)array),payload_at);
        payload_at = payload_at + sVar4;
      }
      break;
    case PROTOBUF_C_TYPE_SINT32:
      for (i = 0; i < count; i += 1)
      {
        sVar4 = sint32_pack(*(int32_t *)(i * 4 + (int)array),payload_at);
        payload_at = payload_at + sVar4;
      }
      break;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      copy_to_little_endian_32(payload_at,array,count);
      payload_at = payload_at + count * 4;
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      for (i = 0; i < count; i += 1)
      {
        sVar4 = uint64_pack(*(uint64_t *)(i * 8 + (int)array),payload_at);
        payload_at = payload_at + sVar4;
      }
      break;
    case PROTOBUF_C_TYPE_SINT64:
      for (i = 0; i < count; i += 1)
      {
        sVar4 = sint64_pack(*(int64_t *)(i * 8 + (int)array),payload_at);
        payload_at = payload_at + sVar4;
      }
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      copy_to_little_endian_64(payload_at,array,count);
      payload_at = payload_at + count * 8;
      break;
    case PROTOBUF_C_TYPE_UINT32:
      for (i = 0; i < count; i += 1)
      {
        sVar4 = uint32_pack(*(uint32_t *)(i * 4 + (int)array),payload_at);
        payload_at = payload_at + sVar4;
      }
      break;
    case PROTOBUF_C_TYPE_BOOL:
      for (i = 0; i < count; i += 1)
      {
        sVar4 = boolean_pack(*(protobuf_c_boolean *)(i * 4 + (int)array),payload_at);
        payload_at = payload_at + sVar4;
      }
      break;
    default:
                    // WARNING: Subroutine does not return
      __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x599,"repeated_field_pack","0");
    }
    v = (int)payload_at - (int)(out + header_len);
    sVar4 = uint32_size(v);
    if (sVar3 != sVar4)
    {
      if (sVar4 != sVar3 + 1)
      {
                    // WARNING: Subroutine does not return
        __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x59f,"repeated_field_pack",
                      "actual_length_size == length_size_min + 1");
      }
      memmove(out + header_len + 1,out + header_len,v);
      header_len += 1;
    }
    uint32_pack(v,out + sVar1);
    rv = v + header_len;
  }
  return rv;
}



size_t unknown_field_pack(ProtobufCMessageUnknownField *field,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  ProtobufCMessageUnknownField *field_local;
  size_t rv;
  
  sVar1 = tag_pack(field->tag,out);
  *out = field->wire_type | *out;
  memcpy(out + sVar1,field->data,field->len);
  return sVar1 + field->len;
}



size_t protobuf_c_message_pack(ProtobufCMessage *message,uint8_t *out)
{
  size_t sVar1;
  ProtobufCFieldDescriptor *field_00;
  void *member_00;
  uint32_t *puVar2;
  uint8_t *out_local;
  ProtobufCMessage *message_local;
  void *qmember;
  void *member;
  ProtobufCFieldDescriptor *field;
  size_t rv;
  uint i;
  
  rv = 0;
  if (message->descriptor->magic != 0x28aaeef9)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0x5c5,"protobuf_c_message_pack",
                  "((message)->descriptor)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
  }
  for (i = 0; i < message->descriptor->n_fields; i += 1)
  {
    field_00 = message->descriptor->fields + i;
    member_00 = (void *)((int)&message->descriptor + field_00->offset);
    puVar2 = (uint32_t *)((int)&message->descriptor + field_00->quantifier_offset);
    if (field_00->label == PROTOBUF_C_LABEL_REQUIRED)
    {
      sVar1 = required_field_pack(field_00,member_00,out + rv);
      rv += sVar1;
    }
    else if (((field_00->label == PROTOBUF_C_LABEL_OPTIONAL) ||
             (field_00->label == PROTOBUF_C_LABEL_NONE)) && ((field_00->flags & 4) != 0))
    {
      sVar1 = oneof_field_pack(field_00,*puVar2,member_00,out + rv);
      rv += sVar1;
    }
    else if (field_00->label == PROTOBUF_C_LABEL_OPTIONAL)
    {
      sVar1 = optional_field_pack(field_00,*puVar2,member_00,out + rv);
      rv += sVar1;
    }
    else if (field_00->label == PROTOBUF_C_LABEL_NONE)
    {
      sVar1 = unlabeled_field_pack(field_00,member_00,out + rv);
      rv += sVar1;
    }
    else
    {
      sVar1 = repeated_field_pack(field_00,*puVar2,member_00,out + rv);
      rv += sVar1;
    }
  }
  for (i = 0; i < message->n_unknown_fields; i += 1)
  {
    sVar1 = unknown_field_pack(message->unknown_fields + i,out + rv);
    rv += sVar1;
  }
  return rv;
}



int int_range_lookup(uint n_ranges,ProtobufCIntRange *ranges,int value)
{
  int iVar1;
  int value_local;
  ProtobufCIntRange *ranges_local;
  uint n_ranges_local;
  uint new_start;
  uint mid;
  uint range_size;
  uint start_orig_index;
  uint start;
  uint n;
  
  if (n_ranges != 0)
  {
    start = 0;
    n = n_ranges;
    while (1 < n)
    {
      iVar1 = (n >> 1) + start;
      if (value < ranges[iVar1].start_value)
      {
        n = iVar1 - start;
      }
      else
      {
        if (value < (int)(ranges[iVar1].start_value +
                         (ranges[iVar1 + 1].orig_index - ranges[iVar1].orig_index)))
        {
          return ranges[iVar1].orig_index + (value - ranges[iVar1].start_value);
        }
        n = (start + n) - (iVar1 + 1U);
        start = iVar1 + 1U;
      }
    }
    if (n != 0)
    {
      if ((ranges[start].start_value <= value) &&
         (value < (int)((ranges[start + 1].orig_index - ranges[start].orig_index) +
                       ranges[start].start_value)))
      {
        return ranges[start].orig_index + (value - ranges[start].start_value);
      }
    }
  }
  return -1;
}



size_t parse_tag_and_wiretype(size_t len,uint8_t *data,uint32_t *tag_out,uint8_t *wiretype_out)
{
  size_t sVar1;
  uint8_t *wiretype_out_local;
  uint32_t *tag_out_local;
  uint8_t *data_local;
  size_t len_local;
  uint max_rv;
  uint rv;
  uint shift;
  uint32_t tag;
  
  if (4 < len)
  {
    len = 5;
  }
  tag = (int)(uint)*data >> 3 & 0xf;
  shift = 4;
  if ((*data & 0xf8) == 0)
  {
    sVar1 = 0;
  }
  else
  {
    *wiretype_out = *data & 7;
    if ((char)*data < '\0')
    {
      for (rv = 1; rv < len; rv += 1)
      {
        if (-1 < (char)data[rv])
        {
          *tag_out = tag | (uint)data[rv] << (shift & 0xff);
          return rv + 1;
        }
        tag |= (data[rv] & 0x7f) << (shift & 0xff);
        shift += 7;
      }
      sVar1 = 0;
    }
    else
    {
      *tag_out = tag;
      sVar1 = 1;
    }
  }
  return sVar1;
}



size_t scan_length_prefixed_data(size_t len,uint8_t *data,size_t *prefix_len_out)
{
  size_t sVar1;
  size_t *prefix_len_out_local;
  uint8_t *data_local;
  size_t len_local;
  uint hdr_len;
  uint hdr_max;
  uint shift;
  uint i;
  size_t val;
  
  sVar1 = len;
  if (4 < len)
  {
    sVar1 = 5;
  }
  val = 0;
  shift = 0;
  for (i = 0; i < sVar1; i += 1)
  {
    val = (data[i] & 0x7f) << (shift & 0xff) | val;
    shift += 7;
    if (-1 < (char)data[i]) break;
  }
  if (i == sVar1)
  {
    sVar1 = 0;
  }
  else
  {
    sVar1 = i + 1;
    *prefix_len_out = sVar1;
    if ((int)val < 0)
    {
      sVar1 = 0;
    }
    else if (len < val + sVar1)
    {
      sVar1 = 0;
    }
    else
    {
      sVar1 = val + sVar1;
    }
  }
  return sVar1;
}



size_t max_b128_numbers(size_t len,uint8_t *data)
{
  uint8_t uVar1;
  uint8_t *puVar2;
  size_t sVar3;
  uint8_t *data_local;
  size_t len_local;
  size_t rv;
  
  rv = 0;
  data_local = data;
  len_local = len;
  while (sVar3 = len_local - 1, len_local != 0)
  {
    puVar2 = data_local + 1;
    uVar1 = *data_local;
    data_local = puVar2;
    len_local = sVar3;
    if (-1 < (char)uVar1)
    {
      rv += 1;
    }
  }
  return rv;
}



protobuf_c_boolean
merge_messages(ProtobufCMessage *earlier_msg,ProtobufCMessage *latter_msg,
              ProtobufCAllocator *allocator)
{
  ProtobufCType PVar1;
  bool bVar2;
  size_t sVar3;
  void *pvVar4;
  int iVar5;
  protobuf_c_boolean pVar6;
  ProtobufCFieldDescriptor *pPVar7;
  int *piVar8;
  undefined4 *puVar9;
  int *piVar10;
  undefined4 *puVar11;
  int *__src;
  int *__dest;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessage *latter_msg_local;
  ProtobufCMessage *earlier_msg_local;
  uint8_t *new_field;
  size_t el_size;
  uint8_t **p_latter;
  size_t *n_latter;
  uint8_t **p_earlier;
  size_t *n_earlier;
  size_t el_size_1;
  char *d_str;
  char *l_str;
  char *e_str;
  ProtobufCBinaryData *d_bd;
  uint8_t *l_data;
  uint8_t *e_data;
  ProtobufCMessage *lm;
  ProtobufCMessage *em;
  void *def_val;
  void *latter_elem;
  void *earlier_elem;
  int field_index;
  uint32_t *latter_case_p;
  uint32_t *earlier_case_p;
  ProtobufCFieldDescriptor *fields;
  protobuf_c_boolean need_to_merge;
  ProtobufCFieldDescriptor *field;
  uint i;
  
  pPVar7 = latter_msg->descriptor->fields;
  i = 0;
  do
  {
    if (latter_msg->descriptor->n_fields <= i)
    {
      return 1;
    }
    if (pPVar7[i].label == PROTOBUF_C_LABEL_REPEATED)
    {
      piVar8 = (int *)((int)&earlier_msg->descriptor + pPVar7[i].quantifier_offset);
      puVar9 = (undefined4 *)((int)&earlier_msg->descriptor + pPVar7[i].offset);
      piVar10 = (int *)((int)&latter_msg->descriptor + pPVar7[i].quantifier_offset);
      puVar11 = (undefined4 *)((int)&latter_msg->descriptor + pPVar7[i].offset);
      if (*piVar8 != 0)
      {
        if (*piVar10 == 0)
        {
          *piVar10 = *piVar8;
          *puVar11 = *puVar9;
        }
        else
        {
          sVar3 = sizeof_elt_in_repeated_array(pPVar7[i].type);
          pvVar4 = do_alloc(allocator,sVar3 * (*piVar10 + *piVar8));
          if (pvVar4 == (void *)0x0)
          {
            return 0;
          }
          memcpy(pvVar4,(void *)*puVar9,sVar3 * *piVar8);
          memcpy((void *)((int)pvVar4 + sVar3 * *piVar8),(void *)*puVar11,sVar3 * *piVar10);
          do_free(allocator,(void *)*puVar11);
          do_free(allocator,(void *)*puVar9);
          *puVar11 = pvVar4;
          *piVar10 = *piVar8 + *piVar10;
        }
        *piVar8 = 0;
        *puVar9 = 0;
      }
    }
    else if ((pPVar7[i].label == PROTOBUF_C_LABEL_OPTIONAL) ||
            (pPVar7[i].label == PROTOBUF_C_LABEL_NONE))
    {
      piVar8 = (int *)((int)&earlier_msg->descriptor + pPVar7[i].quantifier_offset);
      piVar10 = (int *)((int)&latter_msg->descriptor + pPVar7[i].quantifier_offset);
      bVar2 = false;
      if ((pPVar7[i].flags & 4) == 0)
      {
        field = pPVar7 + i;
      }
      else
      {
        if (*piVar10 != 0) goto LAB_08016860;
        iVar5 = int_range_lookup(latter_msg->descriptor->n_field_ranges,
                                 latter_msg->descriptor->field_ranges,*piVar8);
        if (iVar5 < 0)
        {
          return 0;
        }
        field = latter_msg->descriptor->fields + iVar5;
      }
      __src = (int *)((int)&earlier_msg->descriptor + field->offset);
      __dest = (int *)((int)&latter_msg->descriptor + field->offset);
      pvVar4 = field->default_value;
      PVar1 = field->type;
      if (PVar1 == PROTOBUF_C_TYPE_MESSAGE)
      {
        if ((ProtobufCMessage *)*__src != (ProtobufCMessage *)0x0)
        {
          if ((ProtobufCMessage *)*__dest == (ProtobufCMessage *)0x0)
          {
            bVar2 = true;
          }
          else
          {
            pVar6 = merge_messages((ProtobufCMessage *)*__src,(ProtobufCMessage *)*__dest,allocator)
            ;
            if (pVar6 == 0)
            {
              return 0;
            }
            bVar2 = false;
          }
        }
      }
      else if (PVar1 < (PROTOBUF_C_TYPE_MESSAGE|PROTOBUF_C_TYPE_SINT32))
      {
        if (PVar1 == PROTOBUF_C_TYPE_STRING)
        {
          if (((void *)*__src == pvVar4) || ((void *)*__dest != pvVar4))
          {
            bVar2 = false;
          }
          else
          {
            bVar2 = true;
          }
        }
        else
        {
          if (PVar1 != PROTOBUF_C_TYPE_BYTES) goto LAB_08016804;
          if (((__src[1] == 0) ||
              ((pvVar4 != (void *)0x0 && (__src[1] == *(int *)((int)pvVar4 + 4))))) ||
             ((__dest[1] != 0 &&
              ((pvVar4 == (void *)0x0 || (__dest[1] != *(int *)((int)pvVar4 + 4)))))))
          {
            bVar2 = false;
          }
          else
          {
            bVar2 = true;
          }
        }
      }
      else
      {
LAB_08016804:
        if ((*piVar8 == 0) || (*piVar10 != 0))
        {
          bVar2 = false;
        }
        else
        {
          bVar2 = true;
        }
      }
      if (bVar2)
      {
        sVar3 = sizeof_elt_in_repeated_array(field->type);
        memcpy(__dest,__src,sVar3);
        memset(__src,0,sVar3);
        if (field->quantifier_offset != 0)
        {
          *piVar10 = *piVar8;
          *piVar8 = 0;
        }
      }
    }
LAB_08016860:
    i += 1;
  } while( true );
}



protobuf_c_boolean
count_packed_elements(ProtobufCType type,size_t len,uint8_t *data,size_t *count_out)
{
  size_t sVar1;
  protobuf_c_boolean pVar2;
  size_t *count_out_local;
  uint8_t *data_local;
  size_t len_local;
  ProtobufCType type_local;
  
  switch(type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_SINT32:
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_SINT64:
  case PROTOBUF_C_TYPE_UINT32:
  case PROTOBUF_C_TYPE_UINT64:
  case PROTOBUF_C_TYPE_ENUM:
    sVar1 = max_b128_numbers(len,data);
    *count_out = sVar1;
    pVar2 = 1;
    break;
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_FLOAT:
    if ((len & 3) == 0)
    {
      *count_out = len >> 2;
      pVar2 = 1;
    }
    else
    {
      pVar2 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_FIXED64:
  case PROTOBUF_C_TYPE_DOUBLE:
    if ((len & 7) == 0)
    {
      *count_out = len >> 3;
      pVar2 = 1;
    }
    else
    {
      pVar2 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_BOOL:
    *count_out = len;
    pVar2 = 1;
    break;
  default:
    pVar2 = 0;
  }
  return pVar2;
}



uint32_t parse_uint32(uint len,uint8_t *data)
{
  uint8_t *data_local;
  uint len_local;
  uint32_t rv;
  
  rv = *data & 0x7f;
  if ((((1 < len) && (rv = (data[1] & 0x7f) << 7 | rv, 2 < len)) &&
      (rv = (data[2] & 0x7f) << 0xe | rv, 3 < len)) && (rv = (data[3] & 0x7f) << 0x15 | rv, 4 < len)
     )
  {
    rv = (uint)data[4] << 0x1c | rv;
  }
  return rv;
}



uint32_t parse_int32(uint len,uint8_t *data)
{
  uint32_t uVar1;
  uint8_t *data_local;
  uint len_local;
  
  uVar1 = parse_uint32(len,data);
  return uVar1;
}



int32_t unzigzag32(uint32_t v)
{
  uint32_t v_local;
  
  return -(v & 1) ^ v >> 1;
}



uint32_t parse_fixed_uint32(uint8_t *data)
{
  uint8_t *data_local;
  uint32_t t;
  
  return *(uint32_t *)data;
}



uint64_t parse_uint64(uint len,uint8_t *data)
{
  uint uVar1;
  uint8_t *data_local;
  uint len_local;
  uint64_t rv;
  uint i;
  uint shift;
  
  if (len < 5)
  {
    rv._0_4_ = parse_uint32(len,data);
    rv._4_4_ = 0;
  }
  else
  {
    rv._0_4_ = *data & 0x7f | (data[1] & 0x7f) << 7 | (data[2] & 0x7f) << 0xe |
               (data[3] & 0x7f) << 0x15;
    rv._4_4_ = 0;
    shift = 0x1c;
    for (i = 4; i < len; i += 1)
    {
      uVar1 = data[i] & 0x7f;
      (uint32_t)rv |= uVar1 << (shift & 0xff);
      rv._4_4_ |= 0 << (shift & 0xff) | uVar1 << (shift - 0x20 & 0xff) |
                  uVar1 >> (0x20 - shift & 0xff);
      shift += 7;
    }
  }
  return CONCAT44(rv._4_4_,(uint32_t)rv);
}



int64_t unzigzag64(uint64_t v)
{
  uint64_t v_local;
  
  v_local._0_4_ = (uint)v;
  return CONCAT44((uint)((v >> 1) >> 0x20) ^ -(uint)((v & 1) != 0),
                  (uint)(v >> 1) ^ -((uint)v_local & 1));
}



uint64_t parse_fixed_uint64(uint8_t *data)
{
  uint8_t *data_local;
  uint64_t t;
  
  memcpy(&t,data,8);
  return t;
}



protobuf_c_boolean parse_boolean(uint len,uint8_t *data)
{
  uint8_t *data_local;
  uint len_local;
  uint i;
  
  i = 0;
  while( true )
  {
    if (len <= i)
    {
      return 0;
    }
    if ((data[i] & 0x7f) != 0) break;
    i += 1;
  }
  return 1;
}



protobuf_c_boolean
parse_required_member
          (ScannedMember *scanned_member,void *member,ProtobufCAllocator *allocator,
          protobuf_c_boolean maybe_clear)
{
  uint8_t uVar1;
  uint32_t uVar2;
  int32_t iVar3;
  uint len_00;
  uint8_t *data_00;
  uint uVar4;
  void *pvVar5;
  protobuf_c_boolean pVar6;
  int64_t iVar7;
  uint64_t uVar8;
  protobuf_c_boolean maybe_clear_local;
  ProtobufCAllocator *allocator_local;
  void *member_local;
  ScannedMember *scanned_member_local;
  char *def;
  uint pref_len;
  char **pstr;
  ProtobufCBinaryData *def_bd;
  uint pref_len_1;
  ProtobufCBinaryData *bd;
  ProtobufCMessage *def_mess;
  uint pref_len_2;
  ProtobufCMessage **pmessage;
  uint8_t wire_type;
  uint8_t *data;
  uint len;
  protobuf_c_boolean merge_successful;
  ProtobufCMessage *subm;
  
  len_00 = scanned_member->len;
  data_00 = scanned_member->data;
  uVar1 = scanned_member->wire_type;
  switch(scanned_member->field->type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_ENUM:
    if (uVar1 == '\0')
    {
      uVar2 = parse_int32(len_00,data_00);
      *(uint32_t *)member = uVar2;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_SINT32:
    if (uVar1 == '\0')
    {
      uVar2 = parse_uint32(len_00,data_00);
      iVar3 = unzigzag32(uVar2);
      *(int32_t *)member = iVar3;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_FLOAT:
    if (uVar1 == '\x05')
    {
      uVar2 = parse_fixed_uint32(data_00);
      *(uint32_t *)member = uVar2;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_UINT64:
    if (uVar1 == '\0')
    {
      uVar8 = parse_uint64(len_00,data_00);
      *(uint64_t *)member = uVar8;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_SINT64:
    if (uVar1 == '\0')
    {
      uVar8 = parse_uint64(len_00,data_00);
      iVar7 = unzigzag64(uVar8);
      *(int64_t *)member = iVar7;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_FIXED64:
  case PROTOBUF_C_TYPE_DOUBLE:
    if (uVar1 == '\x01')
    {
      uVar8 = parse_fixed_uint64(data_00);
      *(uint64_t *)member = uVar8;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_UINT32:
    if (uVar1 == '\0')
    {
      uVar2 = parse_uint32(len_00,data_00);
      *(uint32_t *)member = uVar2;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_BOOL:
    pVar6 = parse_boolean(len_00,data_00);
    *(protobuf_c_boolean *)member = pVar6;
    pVar6 = 1;
    break;
  case PROTOBUF_C_TYPE_STRING:
    uVar4 = (uint)scanned_member->length_prefix_len;
    if (uVar1 == '\x02')
    {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
      if ((((maybe_clear != 0) && (*member != 0)) && (*member != 0)) &&
         (scanned_member->field->default_value != *member))
      {
                    // WARNING: Load size is inaccurate
        do_free(allocator,*member);
      }
      pvVar5 = do_alloc(allocator,(len_00 - uVar4) + 1);
      *(void **)member = pvVar5;
                    // WARNING: Load size is inaccurate
      if (*member == 0)
      {
        pVar6 = 0;
      }
      else
      {
                    // WARNING: Load size is inaccurate
        memcpy(*member,data_00 + uVar4,len_00 - uVar4);
                    // WARNING: Load size is inaccurate
        *(undefined1 *)((len_00 - uVar4) + *member) = 0;
        pVar6 = 1;
      }
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_BYTES:
    uVar4 = (uint)scanned_member->length_prefix_len;
    if (uVar1 == '\x02')
    {
      pvVar5 = scanned_member->field->default_value;
      if (((maybe_clear != 0) && (*(int *)((int)member + 4) != 0)) &&
         ((pvVar5 == (void *)0x0 || (*(int *)((int)member + 4) != *(int *)((int)pvVar5 + 4)))))
      {
        do_free(allocator,*(void **)((int)member + 4));
      }
      if (uVar4 < len_00)
      {
        pvVar5 = do_alloc(allocator,len_00 - uVar4);
        *(void **)((int)member + 4) = pvVar5;
        if (*(int *)((int)member + 4) == 0)
        {
          return 0;
        }
        memcpy(*(void **)((int)member + 4),data_00 + uVar4,len_00 - uVar4);
      }
      else
      {
        *(undefined4 *)((int)member + 4) = 0;
      }
      *(uint *)member = len_00 - uVar4;
      pVar6 = 1;
    }
    else
    {
      pVar6 = 0;
    }
    break;
  case PROTOBUF_C_TYPE_MESSAGE:
    merge_successful = 1;
    uVar4 = (uint)scanned_member->length_prefix_len;
    if (uVar1 == '\x02')
    {
      pvVar5 = scanned_member->field->default_value;
      if (len_00 < uVar4)
      {
        subm = (ProtobufCMessage *)0x0;
      }
      else
      {
        subm = protobuf_c_message_unpack
                         ((ProtobufCMessageDescriptor *)scanned_member->field->descriptor,allocator,
                          len_00 - uVar4,data_00 + uVar4);
      }
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
      if (((maybe_clear != 0) && (*member != 0)) && (pvVar5 != *member))
      {
        if (subm != (ProtobufCMessage *)0x0)
        {
                    // WARNING: Load size is inaccurate
          merge_successful = merge_messages(*member,subm,allocator);
        }
                    // WARNING: Load size is inaccurate
        protobuf_c_message_free_unpacked(*member,allocator);
      }
      *(ProtobufCMessage **)member = subm;
      if ((subm == (ProtobufCMessage *)0x0) || (merge_successful == 0))
      {
        pVar6 = 0;
      }
      else
      {
        pVar6 = 1;
      }
    }
    else
    {
      pVar6 = 0;
    }
    break;
  default:
    pVar6 = 0;
  }
  return pVar6;
}



protobuf_c_boolean
parse_oneof_member(ScannedMember *scanned_member,void *member,ProtobufCMessage *message,
                  ProtobufCAllocator *allocator)
{
  ProtobufCType PVar1;
  int iVar2;
  size_t __n;
  protobuf_c_boolean pVar3;
  ProtobufCFieldDescriptor *pPVar4;
  uint32_t *puVar5;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessage *message_local;
  void *member_local;
  ScannedMember *scanned_member_local;
  char *def;
  char **pstr;
  ProtobufCBinaryData *def_bd;
  ProtobufCBinaryData *bd;
  ProtobufCMessage *def_mess;
  ProtobufCMessage **pmessage;
  size_t el_size;
  ProtobufCFieldDescriptor *old_field;
  int field_index;
  uint32_t *oneof_case;
  
  puVar5 = (uint32_t *)((int)&message->descriptor + scanned_member->field->quantifier_offset);
  if (*puVar5 != 0)
  {
    iVar2 = int_range_lookup(message->descriptor->n_field_ranges,message->descriptor->field_ranges,
                             *puVar5);
    if (iVar2 < 0)
    {
      return 0;
    }
    pPVar4 = message->descriptor->fields;
    __n = sizeof_elt_in_repeated_array(pPVar4[iVar2].type);
    PVar1 = pPVar4[iVar2].type;
    if (PVar1 == PROTOBUF_C_TYPE_MESSAGE)
    {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
      if ((*member != 0) && (pPVar4[iVar2].default_value != *member))
      {
                    // WARNING: Load size is inaccurate
        protobuf_c_message_free_unpacked(*member,allocator);
      }
    }
    else if (PVar1 < (PROTOBUF_C_TYPE_MESSAGE|PROTOBUF_C_TYPE_SINT32))
    {
      if (PVar1 == PROTOBUF_C_TYPE_STRING)
      {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
        if ((*member != 0) && (pPVar4[iVar2].default_value != *member))
        {
                    // WARNING: Load size is inaccurate
          do_free(allocator,*member);
        }
      }
      else if (((PVar1 == PROTOBUF_C_TYPE_BYTES) && (*(int *)((int)member + 4) != 0)) &&
              ((pPVar4[iVar2].default_value == (void *)0x0 ||
               (*(int *)((int)member + 4) != *(int *)((int)pPVar4[iVar2].default_value + 4)))))
      {
        do_free(allocator,*(void **)((int)member + 4));
      }
    }
    memset(member,0,__n);
  }
  pVar3 = parse_required_member(scanned_member,member,allocator,1);
  if (pVar3 != 0)
  {
    *puVar5 = scanned_member->tag;
  }
  return (uint)(pVar3 != 0);
}



protobuf_c_boolean
parse_optional_member
          (ScannedMember *scanned_member,void *member,ProtobufCMessage *message,
          ProtobufCAllocator *allocator)
{
  protobuf_c_boolean pVar1;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessage *message_local;
  void *member_local;
  ScannedMember *scanned_member_local;
  
  pVar1 = parse_required_member(scanned_member,member,allocator,1);
  if (pVar1 == 0)
  {
    pVar1 = 0;
  }
  else
  {
    if (scanned_member->field->quantifier_offset != 0)
    {
      *(undefined4 *)((int)&message->descriptor + scanned_member->field->quantifier_offset) = 1;
    }
    pVar1 = 1;
  }
  return pVar1;
}



protobuf_c_boolean
parse_repeated_member
          (ScannedMember *scanned_member,void *member,ProtobufCMessage *message,
          ProtobufCAllocator *allocator)
{
  size_t sVar1;
  protobuf_c_boolean pVar2;
  int *piVar3;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessage *message_local;
  void *member_local;
  ScannedMember *scanned_member_local;
  char *array;
  size_t siz;
  size_t *p_n;
  ProtobufCFieldDescriptor *field;
  
  piVar3 = (int *)((int)&message->descriptor + scanned_member->field->quantifier_offset);
  sVar1 = sizeof_elt_in_repeated_array(scanned_member->field->type);
                    // WARNING: Load size is inaccurate
  pVar2 = parse_required_member(scanned_member,(void *)(*member + sVar1 * *piVar3),allocator,0);
  if (pVar2 != 0)
  {
    *piVar3 = *piVar3 + 1;
  }
  return (uint)(pVar2 != 0);
}



uint scan_varint(uint len,uint8_t *data)
{
  uint uVar1;
  uint8_t *data_local;
  uint len_local;
  uint i;
  
  len_local = len;
  if (10 < len)
  {
    len_local = 10;
  }
  for (i = 0; (i < len_local && ((char)data[i] < '\0')); i += 1)
  {
  }
  if (i == len_local)
  {
    uVar1 = 0;
  }
  else
  {
    uVar1 = i + 1;
  }
  return uVar1;
}



protobuf_c_boolean
parse_packed_repeated_member(ScannedMember *scanned_member,void *member,ProtobufCMessage *message)
{
  size_t sVar1;
  uint uVar2;
  uint32_t uVar3;
  int32_t iVar4;
  protobuf_c_boolean pVar5;
  ProtobufCFieldDescriptor *pPVar6;
  int *piVar7;
  void *__dest;
  int64_t iVar8;
  uint64_t uVar9;
  ProtobufCMessage *message_local;
  void *member_local;
  ScannedMember *scanned_member_local;
  uint s;
  uint s_1;
  uint s_4;
  uint s_3;
  uint s_2;
  uint s_5;
  void *array;
  size_t siz;
  size_t *p_n;
  ProtobufCFieldDescriptor *field;
  size_t count;
  size_t rem;
  uint8_t *at;
  
  pPVar6 = scanned_member->field;
  piVar7 = (int *)((int)&message->descriptor + pPVar6->quantifier_offset);
  sVar1 = sizeof_elt_in_repeated_array(pPVar6->type);
                    // WARNING: Load size is inaccurate
  __dest = (void *)(sVar1 * *piVar7 + *member);
  at = scanned_member->data + scanned_member->length_prefix_len;
  rem = scanned_member->len - (uint)scanned_member->length_prefix_len;
  count = 0;
  switch(pPVar6->type)
  {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_ENUM:
    for (; rem != 0; rem -= uVar2)
    {
      uVar2 = scan_varint(rem,at);
      if (uVar2 == 0)
      {
        return 0;
      }
      uVar3 = parse_int32(uVar2,at);
      *(uint32_t *)(count * 4 + (int)__dest) = uVar3;
      at = at + uVar2;
      count = count + 1;
    }
    break;
  case PROTOBUF_C_TYPE_SINT32:
    for (; rem != 0; rem -= uVar2)
    {
      uVar2 = scan_varint(rem,at);
      if (uVar2 == 0)
      {
        return 0;
      }
      uVar3 = parse_uint32(uVar2,at);
      iVar4 = unzigzag32(uVar3);
      *(int32_t *)((int)__dest + count * 4) = iVar4;
      at = at + uVar2;
      count = count + 1;
    }
    break;
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_FLOAT:
    count = scanned_member->len - (uint)scanned_member->length_prefix_len >> 2;
    goto LAB_08017484;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_UINT64:
    for (; rem != 0; rem -= uVar2)
    {
      uVar2 = scan_varint(rem,at);
      if (uVar2 == 0)
      {
        return 0;
      }
      uVar9 = parse_uint64(uVar2,at);
      *(uint64_t *)((int)__dest + count * 8) = uVar9;
      at = at + uVar2;
      count = count + 1;
    }
    break;
  case PROTOBUF_C_TYPE_SINT64:
    for (; rem != 0; rem -= uVar2)
    {
      uVar2 = scan_varint(rem,at);
      if (uVar2 == 0)
      {
        return 0;
      }
      uVar9 = parse_uint64(uVar2,at);
      iVar8 = unzigzag64(uVar9);
      *(int64_t *)((int)__dest + count * 8) = iVar8;
      at = at + uVar2;
      count = count + 1;
    }
    break;
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_FIXED64:
  case PROTOBUF_C_TYPE_DOUBLE:
    count = scanned_member->len - (uint)scanned_member->length_prefix_len >> 3;
LAB_08017484:
    memcpy(__dest,at,sVar1 * count);
    *piVar7 = *piVar7 + count;
    return 1;
  case PROTOBUF_C_TYPE_UINT32:
    for (; rem != 0; rem -= uVar2)
    {
      uVar2 = scan_varint(rem,at);
      if (uVar2 == 0)
      {
        return 0;
      }
      uVar3 = parse_uint32(uVar2,at);
      *(uint32_t *)((int)__dest + count * 4) = uVar3;
      at = at + uVar2;
      count = count + 1;
    }
    break;
  case PROTOBUF_C_TYPE_BOOL:
    for (; rem != 0; rem -= uVar2)
    {
      uVar2 = scan_varint(rem,at);
      if (uVar2 == 0)
      {
        return 0;
      }
      pVar5 = parse_boolean(uVar2,at);
      *(protobuf_c_boolean *)((int)__dest + count * 4) = pVar5;
      at = at + uVar2;
      count = count + 1;
    }
    break;
  default:
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0xb2e,"parse_packed_repeated_member",
                  "0");
  }
  *piVar7 = *piVar7 + count;
  return 1;
}



protobuf_c_boolean is_packable_type(ProtobufCType type)
{
  protobuf_c_boolean pVar1;
  ProtobufCType type_local;
  
  if (((type == PROTOBUF_C_TYPE_STRING) || (type == PROTOBUF_C_TYPE_BYTES)) ||
     (type == PROTOBUF_C_TYPE_MESSAGE))
  {
    pVar1 = 0;
  }
  else
  {
    pVar1 = 1;
  }
  return pVar1;
}



protobuf_c_boolean
parse_member(ScannedMember *scanned_member,ProtobufCMessage *message,ProtobufCAllocator *allocator)
{
  uint8_t *puVar1;
  ProtobufCFieldDescriptor *pPVar2;
  uint uVar3;
  ProtobufCMessageUnknownField *pPVar4;
  protobuf_c_boolean pVar5;
  void *member_00;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessage *message_local;
  ScannedMember *scanned_member_local;
  ProtobufCMessageUnknownField *ufield;
  void *member;
  ProtobufCFieldDescriptor *field;
  
  pPVar2 = scanned_member->field;
  if (pPVar2 == (ProtobufCFieldDescriptor *)0x0)
  {
    uVar3 = message->n_unknown_fields;
    message->n_unknown_fields = uVar3 + 1;
    pPVar4 = message->unknown_fields + uVar3;
    pPVar4->tag = scanned_member->tag;
    pPVar4->wire_type = scanned_member->wire_type;
    pPVar4->len = scanned_member->len;
    puVar1 = (uint8_t *)do_alloc(allocator,scanned_member->len);
    pPVar4->data = puVar1;
    if (pPVar4->data == (uint8_t *)0x0)
    {
      pVar5 = 0;
    }
    else
    {
      memcpy(pPVar4->data,scanned_member->data,pPVar4->len);
      pVar5 = 1;
    }
  }
  else
  {
    member_00 = (void *)((int)&message->descriptor + pPVar2->offset);
    switch(pPVar2->label)
    {
    case PROTOBUF_C_LABEL_REQUIRED:
      pVar5 = parse_required_member(scanned_member,member_00,allocator,1);
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
    case PROTOBUF_C_LABEL_NONE:
      if ((pPVar2->flags & 4) == 0)
      {
        pVar5 = parse_optional_member(scanned_member,member_00,message,allocator);
      }
      else
      {
        pVar5 = parse_oneof_member(scanned_member,member_00,message,allocator);
      }
      break;
    case PROTOBUF_C_LABEL_REPEATED:
      if ((scanned_member->wire_type == '\x02') &&
         (((pPVar2->flags & 1) != 0 || (pVar5 = is_packable_type(pPVar2->type), pVar5 != 0))))
      {
        pVar5 = parse_packed_repeated_member(scanned_member,member_00,message);
      }
      else
      {
        pVar5 = parse_repeated_member(scanned_member,member_00,message,allocator);
      }
      break;
    default:
                    // WARNING: Subroutine does not return
      __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0xb75,"parse_member","0");
    }
  }
  return pVar5;
}



void message_init_generic(ProtobufCMessageDescriptor *desc,ProtobufCMessage *message)
{
  undefined4 *__dest;
  undefined4 *__src;
  ProtobufCMessage *message_local;
  ProtobufCMessageDescriptor *desc_local;
  void *dv;
  void *field;
  uint i;
  
  memset(message,0,desc->sizeof_message);
  message->descriptor = desc;
  for (i = 0; i < desc->n_fields; i += 1)
  {
    if ((desc->fields[i].default_value != (void *)0x0) &&
       (desc->fields[i].label != PROTOBUF_C_LABEL_REPEATED))
    {
      __dest = (undefined4 *)((int)&message->descriptor + desc->fields[i].offset);
      __src = (undefined4 *)desc->fields[i].default_value;
      switch(desc->fields[i].type)
      {
      case PROTOBUF_C_TYPE_INT32:
      case PROTOBUF_C_TYPE_SINT32:
      case PROTOBUF_C_TYPE_SFIXED32:
      case PROTOBUF_C_TYPE_UINT32:
      case PROTOBUF_C_TYPE_FIXED32:
      case PROTOBUF_C_TYPE_FLOAT:
      case PROTOBUF_C_TYPE_ENUM:
        *__dest = *__src;
        break;
      case PROTOBUF_C_TYPE_INT64:
      case PROTOBUF_C_TYPE_SINT64:
      case PROTOBUF_C_TYPE_SFIXED64:
      case PROTOBUF_C_TYPE_UINT64:
      case PROTOBUF_C_TYPE_FIXED64:
      case PROTOBUF_C_TYPE_DOUBLE:
        memcpy(__dest,__src,8);
        break;
      case PROTOBUF_C_TYPE_BOOL:
        *__dest = *__src;
        break;
      case PROTOBUF_C_TYPE_STRING:
      case PROTOBUF_C_TYPE_MESSAGE:
        *__dest = __src;
        break;
      case PROTOBUF_C_TYPE_BYTES:
        memcpy(__dest,__src,8);
      }
    }
  }
  return;
}



ProtobufCMessage *
protobuf_c_message_unpack
          (ProtobufCMessageDescriptor *desc,ProtobufCAllocator *allocator,size_t len,uint8_t *data)
{
  bool bVar1;
  ProtobufCMessage *message;
  size_t sVar2;
  void *pvVar3;
  ProtobufCMessageUnknownField *pPVar4;
  protobuf_c_boolean pVar5;
  uint uVar6;
  uint8_t *data_00;
  uint uVar7;
  int *piVar8;
  ProtobufCFieldDescriptor *pPVar9;
  int iVar10;
  ScannedMember *pSVar11;
  uint8_t *data_local;
  size_t len_local;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessageDescriptor *desc_local;
  size_t count;
  size_t pref_len;
  ScannedMember tmp;
  uint8_t wire_type;
  uint32_t tag;
  uchar required_fields_bitmap_stack [16];
  ScannedMember *scanned_member_slabs [23];
  ScannedMember first_member_slab [16];
  size_t *n;
  size_t size;
  uint max_len;
  int field_index;
  size_t used;
  void *a;
  uint n_1;
  size_t *n_ptr;
  size_t siz;
  ProtobufCFieldDescriptor *field_1;
  ScannedMember *slab;
  uint max;
  uint required_fields_bitmap_len;
  ProtobufCMessage *rv;
  uint i;
  ProtobufCFieldDescriptor *field;
  protobuf_c_boolean required_fields_bitmap_alloced;
  uchar *required_fields_bitmap;
  uint last_field_index;
  uint i_slab;
  uint j;
  uint f;
  size_t n_unknown;
  uint in_slab_index;
  uint which_slab;
  ProtobufCFieldDescriptor *last_field;
  uint8_t *at;
  size_t rem;
  
  last_field = desc->fields;
  which_slab = 0;
  in_slab_index = 0;
  n_unknown = 0;
  last_field_index = 0;
  required_fields_bitmap = required_fields_bitmap_stack;
  bVar1 = false;
  if (desc->magic != 0x28aaeef9)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0xbf2,"protobuf_c_message_unpack",
                  "(desc)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
  }
  allocator_local = allocator;
  if (allocator == (ProtobufCAllocator *)0x0)
  {
    allocator_local = &protobuf_c__allocator;
  }
  message = (ProtobufCMessage *)do_alloc(allocator_local,desc->sizeof_message);
  if (message == (ProtobufCMessage *)0x0)
  {
    return (ProtobufCMessage *)0x0;
  }
  scanned_member_slabs[0] = first_member_slab;
  uVar6 = desc->n_fields + 7 >> 3;
  if (0x10 < uVar6)
  {
    required_fields_bitmap = (uchar *)do_alloc(allocator_local,uVar6);
    if (required_fields_bitmap == (uchar *)0x0)
    {
      do_free(allocator_local,message);
      return (ProtobufCMessage *)0x0;
    }
    bVar1 = true;
  }
  memset(required_fields_bitmap,0,uVar6);
  at = data;
  rem = len;
  if (desc->message_init == (ProtobufCMessageInit)0x0)
  {
    message_init_generic(desc,message);
  }
  else
  {
    protobuf_c_message_init(desc,message);
  }
  while (rem != 0)
  {
    sVar2 = parse_tag_and_wiretype(rem,at,&tag,&wire_type);
    if (sVar2 == 0) goto LAB_08017f88;
    if ((last_field == (ProtobufCFieldDescriptor *)0x0) || (last_field->id != tag))
    {
      uVar6 = int_range_lookup(desc->n_field_ranges,desc->field_ranges,tag);
      if ((int)uVar6 < 0)
      {
        field = (ProtobufCFieldDescriptor *)0x0;
        n_unknown += 1;
      }
      else
      {
        field = desc->fields + uVar6;
        last_field_index = uVar6;
        last_field = field;
      }
    }
    else
    {
      field = last_field;
    }
    if ((field != (ProtobufCFieldDescriptor *)0x0) && (field->label == PROTOBUF_C_LABEL_REQUIRED))
    {
      required_fields_bitmap[last_field_index >> 3] =
           (byte)(1 << (last_field_index & 7)) | required_fields_bitmap[last_field_index >> 3];
    }
    data_00 = at + sVar2;
    uVar6 = rem - sVar2;
    tmp.tag = tag;
    tmp.field = field;
    tmp.length_prefix_len = '\0';
    tmp.wire_type = wire_type;
    tmp.data = data_00;
    if (false)
    {
code_r0x08017f74:
      goto LAB_08017f88;
    }
    switch(wire_type)
    {
    case '\0':
      uVar7 = uVar6;
      if (9 < uVar6)
      {
        uVar7 = 10;
      }
      for (i = 0; (i < uVar7 && ((char)data_00[i] < '\0')); i += 1)
      {
      }
      if (i == uVar7) goto LAB_08017f88;
      tmp.len = i + 1;
      break;
    case '\x01':
      if (uVar6 < 8) goto LAB_08017f88;
      tmp.len = 8;
      break;
    case '\x02':
      tmp.len = scan_length_prefixed_data(uVar6,data_00,&pref_len);
      if (tmp.len == 0) goto LAB_08017f88;
      tmp.length_prefix_len = (uint8_t)pref_len;
      break;
    default:
      goto code_r0x08017f74;
    case '\x05':
      if (uVar6 < 4) goto LAB_08017f88;
      tmp.len = 4;
    }
    if (in_slab_index == 1 << (which_slab + 4 & 0xff))
    {
      in_slab_index = 0;
      if (which_slab == 0x16) goto LAB_08017f88;
      uVar7 = which_slab + 1;
      pSVar11 = (ScannedMember *)do_alloc(allocator_local,0x14 << (which_slab + 5 & 0xff));
      scanned_member_slabs[uVar7] = pSVar11;
      which_slab = uVar7;
      if (scanned_member_slabs[uVar7] == (ScannedMember *)0x0) goto LAB_08017f88;
    }
    pSVar11 = scanned_member_slabs[which_slab] + in_slab_index;
    pSVar11->tag = tmp.tag;
    pSVar11->wire_type = tmp.wire_type;
    pSVar11->length_prefix_len = tmp.length_prefix_len;
    *(undefined2 *)&pSVar11->field_0x6 = tmp._6_2_;
    pSVar11->field = tmp.field;
    pSVar11->len = tmp.len;
    pSVar11->data = tmp.data;
    if ((field != (ProtobufCFieldDescriptor *)0x0) && (field->label == PROTOBUF_C_LABEL_REPEATED))
    {
      piVar8 = (int *)((int)&message->descriptor + field->quantifier_offset);
      if ((wire_type == '\x02') &&
         (((field->flags & 1) != 0 || (pVar5 = is_packable_type(field->type), pVar5 != 0))))
      {
        pVar5 = count_packed_elements
                          (field->type,tmp.len - tmp.length_prefix_len,
                           tmp.data + tmp.length_prefix_len,&count);
        if (pVar5 == 0)
        {
LAB_08017f88:
          do_free(allocator_local,message);
          for (j = 1; j <= which_slab; j += 1)
          {
            do_free(allocator_local,scanned_member_slabs[j]);
          }
          if (bVar1)
          {
            do_free(allocator_local,required_fields_bitmap);
          }
          return (ProtobufCMessage *)0x0;
        }
        *piVar8 = *piVar8 + count;
      }
      else
      {
        *piVar8 = *piVar8 + 1;
      }
    }
    at = data_00 + tmp.len;
    in_slab_index = in_slab_index + 1;
    rem = uVar6 - tmp.len;
  }
  for (f = 0; f < desc->n_fields; f += 1)
  {
    pPVar9 = desc->fields + f;
    if (pPVar9 != (ProtobufCFieldDescriptor *)0x0)
    {
      if (pPVar9->label == PROTOBUF_C_LABEL_REPEATED)
      {
        sVar2 = sizeof_elt_in_repeated_array(pPVar9->type);
        piVar8 = (int *)((int)&message->descriptor + pPVar9->quantifier_offset);
        if (*piVar8 != 0)
        {
          iVar10 = *piVar8;
          *piVar8 = 0;
          if (message->descriptor == (ProtobufCMessageDescriptor *)0x0)
          {
                    // WARNING: Subroutine does not return
            __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0xcaf,
                          "protobuf_c_message_unpack","rv->descriptor != NULL");
          }
          pvVar3 = do_alloc(allocator_local,iVar10 * sVar2);
          if (pvVar3 == (void *)0x0) goto LAB_08017d20;
          *(void **)((int)&message->descriptor + pPVar9->offset) = pvVar3;
        }
      }
      else if (((pPVar9->label == PROTOBUF_C_LABEL_REQUIRED) &&
               (pPVar9->default_value == (void *)0x0)) &&
              ((required_fields_bitmap[f >> 3] >> (f & 7) & 1) == 0)) goto LAB_08017dc6;
    }
  }
  if (n_unknown != 0)
  {
    pPVar4 = (ProtobufCMessageUnknownField *)do_alloc(allocator_local,n_unknown << 4);
    message->unknown_fields = pPVar4;
    if (message->unknown_fields == (ProtobufCMessageUnknownField *)0x0) goto LAB_08017f10;
  }
  i_slab = 0;
  do
  {
    if (which_slab < i_slab)
    {
      for (j = 1; j <= which_slab; j += 1)
      {
        do_free(allocator_local,scanned_member_slabs[j]);
      }
      if (!bVar1)
      {
        return message;
      }
      do_free(allocator_local,required_fields_bitmap);
      return message;
    }
    uVar6 = in_slab_index;
    if (i_slab != which_slab)
    {
      uVar6 = 1 << (i_slab + 4 & 0xff);
    }
    pSVar11 = scanned_member_slabs[i_slab];
    for (j = 0; j < uVar6; j += 1)
    {
      pVar5 = parse_member(pSVar11 + j,message,allocator_local);
      if (pVar5 == 0) goto LAB_08017f10;
    }
    i_slab += 1;
  } while( true );
LAB_08017d20:
  while (f += 1, f < desc->n_fields)
  {
    if (desc->fields[f].label == PROTOBUF_C_LABEL_REPEATED)
    {
      *(undefined4 *)((int)&message->descriptor + desc->fields[f].quantifier_offset) = 0;
    }
  }
  goto LAB_08017f10;
LAB_08017dc6:
  while (f += 1, f < desc->n_fields)
  {
    if (desc->fields[f].label == PROTOBUF_C_LABEL_REPEATED)
    {
      *(undefined4 *)((int)&message->descriptor + desc->fields[f].quantifier_offset) = 0;
    }
  }
LAB_08017f10:
  protobuf_c_message_free_unpacked(message,allocator_local);
  for (j = 1; j <= which_slab; j += 1)
  {
    do_free(allocator_local,scanned_member_slabs[j]);
  }
  if (bVar1)
  {
    do_free(allocator_local,required_fields_bitmap);
  }
  return (ProtobufCMessage *)0x0;
}



void protobuf_c_message_free_unpacked(ProtobufCMessage *message,ProtobufCAllocator *allocator)
{
  ProtobufCMessageDescriptor *pPVar1;
  uint uVar2;
  void *pvVar3;
  void *pvVar4;
  ProtobufCMessage *message_00;
  ProtobufCAllocator *allocator_local;
  ProtobufCMessage *message_local;
  void *arr;
  size_t n;
  char *str;
  ProtobufCBinaryData *default_bd;
  void *data;
  ProtobufCMessage *sm;
  ProtobufCMessageDescriptor *desc;
  uint i_2;
  uint i_1;
  uint i;
  uint f;
  
  if (message != (ProtobufCMessage *)0x0)
  {
    pPVar1 = message->descriptor;
    if (message->descriptor->magic != 0x28aaeef9)
    {
                    // WARNING: Subroutine does not return
      __assert_func("./libs/protobuf-c/protobuf-c/protobuf-c.c",0xd07,
                    "protobuf_c_message_free_unpacked",
                    "((message)->descriptor)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
    }
    allocator_local = allocator;
    if (allocator == (ProtobufCAllocator *)0x0)
    {
      allocator_local = &protobuf_c__allocator;
    }
    message->descriptor = (ProtobufCMessageDescriptor *)0x0;
    for (f = 0; f < pPVar1->n_fields; f += 1)
    {
      if (((pPVar1->fields[f].flags & 4) == 0) ||
         (pPVar1->fields[f].id ==
          *(uint32_t *)((int)&message->descriptor + pPVar1->fields[f].quantifier_offset)))
      {
        if (pPVar1->fields[f].label == PROTOBUF_C_LABEL_REPEATED)
        {
          uVar2 = *(uint *)((int)&message->descriptor + pPVar1->fields[f].quantifier_offset);
          pvVar3 = *(void **)((int)&message->descriptor + pPVar1->fields[f].offset);
          if (pvVar3 != (void *)0x0)
          {
            if (pPVar1->fields[f].type == PROTOBUF_C_TYPE_STRING)
            {
              for (i = 0; i < uVar2; i += 1)
              {
                do_free(allocator_local,*(void **)(i * 4 + (int)pvVar3));
              }
            }
            else if (pPVar1->fields[f].type == PROTOBUF_C_TYPE_BYTES)
            {
              for (i_1 = 0; i_1 < uVar2; i_1 += 1)
              {
                do_free(allocator_local,*(void **)((int)pvVar3 + i_1 * 8 + 4));
              }
            }
            else if (pPVar1->fields[f].type == PROTOBUF_C_TYPE_MESSAGE)
            {
              for (i_2 = 0; i_2 < uVar2; i_2 += 1)
              {
                protobuf_c_message_free_unpacked
                          (*(ProtobufCMessage **)(i_2 * 4 + (int)pvVar3),allocator_local);
              }
            }
            do_free(allocator_local,pvVar3);
          }
        }
        else if (pPVar1->fields[f].type == PROTOBUF_C_TYPE_STRING)
        {
          pvVar3 = *(void **)((int)&message->descriptor + pPVar1->fields[f].offset);
          if ((pvVar3 != (void *)0x0) && (pvVar3 != pPVar1->fields[f].default_value))
          {
            do_free(allocator_local,pvVar3);
          }
        }
        else if (pPVar1->fields[f].type == PROTOBUF_C_TYPE_BYTES)
        {
          pvVar3 = *(void **)((int)&message->n_unknown_fields + pPVar1->fields[f].offset);
          pvVar4 = pPVar1->fields[f].default_value;
          if ((pvVar3 != (void *)0x0) &&
             ((pvVar4 == (void *)0x0 || (pvVar3 != *(void **)((int)pvVar4 + 4)))))
          {
            do_free(allocator_local,pvVar3);
          }
        }
        else if (((pPVar1->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) &&
                 (message_00 = *(ProtobufCMessage **)
                                ((int)&message->descriptor + pPVar1->fields[f].offset),
                 message_00 != (ProtobufCMessage *)0x0)) &&
                (message_00 != (ProtobufCMessage *)pPVar1->fields[f].default_value))
        {
          protobuf_c_message_free_unpacked(message_00,allocator_local);
        }
      }
    }
    for (f = 0; f < message->n_unknown_fields; f += 1)
    {
      do_free(allocator_local,message->unknown_fields[f].data);
    }
    if (message->unknown_fields != (ProtobufCMessageUnknownField *)0x0)
    {
      do_free(allocator_local,message->unknown_fields);
    }
    do_free(allocator_local,message);
  }
  return;
}



void protobuf_c_message_init(ProtobufCMessageDescriptor *descriptor,void *message)
{
  void *message_local;
  ProtobufCMessageDescriptor *descriptor_local;
  
  (*descriptor->message_init)((ProtobufCMessage *)message);
  return;
}



void device_message__version_information__init(DeviceMessage__VersionInformation *message)
{
  DeviceMessage__VersionInformation *message_local;
  
  (message->base).descriptor = &device_message__version_information__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->build_date = "";
  message->code_version_date = "";
  message->code_version_tag = "";
  message->is_official = 0;
  return;
}



size_t device_message__version_information__get_packed_size
                 (DeviceMessage__VersionInformation *message)
{
  size_t sVar1;
  DeviceMessage__VersionInformation *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034518)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x13,
                  "device_message__version_information__get_packed_size",
                  "message->base.descriptor == &device_message__version_information__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__version_information__pack
                 (DeviceMessage__VersionInformation *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__VersionInformation *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034518)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x1a,"device_message__version_information__pack",
                  "message->base.descriptor == &device_message__version_information__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



void device_message__get_version_information__init(DeviceMessage__GetVersionInformation *message)
{
  DeviceMessage__GetVersionInformation *message_local;
  
  (message->base).descriptor = &device_message__get_version_information__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__log__init(DeviceMessage__Log *message)
{
  DeviceMessage__Log *message_local;
  
  (message->base).descriptor = &device_message__log__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->message = "";
  message->level = DEVICE_MESSAGE__LEVEL__SPECIAL;
  message->type = DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER;
  return;
}



size_t device_message__log__get_packed_size(DeviceMessage__Log *message)
{
  size_t sVar1;
  DeviceMessage__Log *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034630)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x6d,"device_message__log__get_packed_size",
                  "message->base.descriptor == &device_message__log__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__log__pack(DeviceMessage__Log *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__Log *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034630)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x74,"device_message__log__pack",
                  "message->base.descriptor == &device_message__log__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



void device_message__shields__init(DeviceMessage__Shields *message)
{
  DeviceMessage__Shields *message_local;
  
  (message->base).descriptor = &device_message__shields__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->n_shields = 0;
  message->shields = (DeviceMessage__ShieldValue *)0x0;
  return;
}



size_t device_message__shields__get_packed_size(DeviceMessage__Shields *message)
{
  size_t sVar1;
  DeviceMessage__Shields *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x80346ac)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x9a,"device_message__shields__get_packed_size",
                  "message->base.descriptor == &device_message__shields__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__shields__pack(DeviceMessage__Shields *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__Shields *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x80346ac)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0xa1,"device_message__shields__pack",
                  "message->base.descriptor == &device_message__shields__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



void device_message__configure_example__init(DeviceMessage__ConfigureExample *message)
{
  DeviceMessage__ConfigureExample *message_local;
  
  (message->base).descriptor = &device_message__configure_example__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->delay = 0;
  return;
}



void device_message__configure_per__init(DeviceMessage__ConfigurePer *message)
{
  DeviceMessage__ConfigurePer *message_local;
  
  (message->base).descriptor = &device_message__configure_per__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->nb_frames = 0;
  message->tx_to_tx_delay_in_ms = 0;
  message->rx_timeout_in_ms = 0;
  message->receiver = 0;
  return;
}



void device_message__configure_ping_pong__init(DeviceMessage__ConfigurePingPong *message)
{
  DeviceMessage__ConfigurePingPong *message_local;
  
  memset(message,0,0x20);
  (message->base).descriptor = &device_message__configure_ping_pong__descriptor;
  return;
}



void device_message__configure_static_mode__init(DeviceMessage__ConfigureStaticMode *message)
{
  DeviceMessage__ConfigureStaticMode *message_local;
  
  (message->base).descriptor = &device_message__configure_static_mode__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->static_mode = DEVICE_MESSAGE__STATIC_MODE__NOT_CONFIGURED;
  return;
}



void device_message__configure_radio__init(DeviceMessage__ConfigureRadio *message)
{
  DeviceMessage__ConfigureRadio *message_local;
  
  memset(message,0,0x38);
  (message->base).descriptor = &device_message__configure_radio__descriptor;
  return;
}



void device_message__configure_application__init(DeviceMessage__ConfigureApplication *message)
{
  DeviceMessage__ConfigureApplication *message_local;
  
  (message->base).descriptor = &device_message__configure_application__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->example = (DeviceMessage__ConfigureExample *)0x0;
  message->per = (DeviceMessage__ConfigurePer *)0x0;
  message->static_mode = (DeviceMessage__ConfigureStaticMode *)0x0;
  message->ping_pong = (DeviceMessage__ConfigurePingPong *)0x0;
  return;
}



void device_message__configuration__init(DeviceMessage__Configuration *message)
{
  DeviceMessage__Configuration *message_local;
  
  (message->base).descriptor = &device_message__configuration__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->appli_configuration = (DeviceMessage__ConfigureApplication *)0x0;
  message->radio_configuration = (DeviceMessage__ConfigureRadio *)0x0;
  return;
}



size_t device_message__configuration__get_packed_size(DeviceMessage__Configuration *message)
{
  size_t sVar1;
  DeviceMessage__Configuration *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034e00)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x1d5,
                  "device_message__configuration__get_packed_size",
                  "message->base.descriptor == &device_message__configuration__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__configuration__pack(DeviceMessage__Configuration *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__Configuration *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034e00)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x1dc,"device_message__configuration__pack",
                  "message->base.descriptor == &device_message__configuration__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



DeviceMessage__Configuration *
device_message__configuration__unpack(ProtobufCAllocator *allocator,size_t len,uint8_t *data)
{
  DeviceMessage__Configuration *pDVar1;
  uint8_t *data_local;
  size_t len_local;
  ProtobufCAllocator *allocator_local;
  
  pDVar1 = (DeviceMessage__Configuration *)
           protobuf_c_message_unpack(&device_message__configuration__descriptor,allocator,len,data);
  return pDVar1;
}



void device_message__configuration__free_unpacked
               (DeviceMessage__Configuration *message,ProtobufCAllocator *allocator)
{
  ProtobufCAllocator *allocator_local;
  DeviceMessage__Configuration *message_local;
  
  if (message != (DeviceMessage__Configuration *)0x0)
  {
    if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034e00)
    {
                    // WARNING: Subroutine does not return
      __assert_func("./generated/message.pb-c.c",0x1f6,
                    "device_message__configuration__free_unpacked",
                    "message->base.descriptor == &device_message__configuration__descriptor");
    }
    protobuf_c_message_free_unpacked(&message->base,allocator);
  }
  return;
}



void device_message__start_demo__init(DeviceMessage__StartDemo *message)
{
  DeviceMessage__StartDemo *message_local;
  
  (message->base).descriptor = &device_message__start_demo__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->demo = DEVICE_MESSAGE__DEMO__DEMO_TX_CW;
  return;
}



void device_message__stop_demo__init(DeviceMessage__StopDemo *message)
{
  DeviceMessage__StopDemo *message_local;
  
  (message->base).descriptor = &device_message__stop_demo__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__get_configuration__init(DeviceMessage__GetConfiguration *message)
{
  DeviceMessage__GetConfiguration *message_local;
  
  (message->base).descriptor = &device_message__get_configuration__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__shield__init(DeviceMessage__Shield *message)
{
  DeviceMessage__Shield *message_local;
  
  (message->base).descriptor = &device_message__shield__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->shield = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1DIS;
  return;
}



size_t device_message__shield__get_packed_size(DeviceMessage__Shield *message)
{
  size_t sVar1;
  DeviceMessage__Shield *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034f70)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x289,"device_message__shield__get_packed_size",
                  "message->base.descriptor == &device_message__shield__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__shield__pack(DeviceMessage__Shield *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__Shield *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8034f70)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x290,"device_message__shield__pack",
                  "message->base.descriptor == &device_message__shield__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



void device_message__get_shield__init(DeviceMessage__GetShield *message)
{
  DeviceMessage__GetShield *message_local;
  
  (message->base).descriptor = &device_message__get_shield__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__get_all_shields__init(DeviceMessage__GetAllShields *message)
{
  DeviceMessage__GetAllShields *message_local;
  
  (message->base).descriptor = &device_message__get_all_shields__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__identify__init(DeviceMessage__Identify *message)
{
  DeviceMessage__Identify *message_local;
  
  (message->base).descriptor = &device_message__identify__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__push_button__init(DeviceMessage__PushButton *message)
{
  DeviceMessage__PushButton *message_local;
  
  (message->base).descriptor = &device_message__push_button__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__store_current_config_in_nvm__init
               (DeviceMessage__StoreCurrentConfigInNvm *message)
{
  DeviceMessage__StoreCurrentConfigInNvm *message_local;
  
  (message->base).descriptor = &device_message__store_current_config_in_nvm__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->shield = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1DIS;
  message->demo = DEVICE_MESSAGE__DEMO__DEMO_TX_CW;
  return;
}



void device_message__factory_reset_nvm__init(DeviceMessage__FactoryResetNvm *message)
{
  DeviceMessage__FactoryResetNvm *message_local;
  
  (message->base).descriptor = &device_message__factory_reset_nvm__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__load_config_from_nvm__init(DeviceMessage__LoadConfigFromNvm *message)
{
  DeviceMessage__LoadConfigFromNvm *message_local;
  
  (message->base).descriptor = &device_message__load_config_from_nvm__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__set_running_mode__init(DeviceMessage__SetRunningMode *message)
{
  DeviceMessage__SetRunningMode *message_local;
  
  (message->base).descriptor = &device_message__set_running_mode__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->running_mode = DEVICE_MESSAGE__RUNNING_MODE_VALUE__RUNNING_MODE_CONNECTED;
  return;
}



void device_message__running_mode__init(DeviceMessage__RunningMode *message)
{
  DeviceMessage__RunningMode *message_local;
  
  (message->base).descriptor = &device_message__running_mode__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->running_mode = DEVICE_MESSAGE__RUNNING_MODE_VALUE__RUNNING_MODE_CONNECTED;
  return;
}



size_t device_message__running_mode__get_packed_size(DeviceMessage__RunningMode *message)
{
  size_t sVar1;
  DeviceMessage__RunningMode *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x803527c)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x41e,"device_message__running_mode__get_packed_size"
                  ,"message->base.descriptor == &device_message__running_mode__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__running_mode__pack(DeviceMessage__RunningMode *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__RunningMode *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x803527c)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x425,"device_message__running_mode__pack",
                  "message->base.descriptor == &device_message__running_mode__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



void device_message__get_running_mode__init(DeviceMessage__GetRunningMode *message)
{
  DeviceMessage__GetRunningMode *message_local;
  
  (message->base).descriptor = &device_message__get_running_mode__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__get_nvm_logs_size__init(DeviceMessage__GetNvmLogsSize *message)
{
  DeviceMessage__GetNvmLogsSize *message_local;
  
  (message->base).descriptor = &device_message__get_nvm_logs_size__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__nvm_logs_size__init(DeviceMessage__NvmLogsSize *message)
{
  DeviceMessage__NvmLogsSize *message_local;
  
  (message->base).descriptor = &device_message__nvm_logs_size__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->size = 0;
  return;
}



size_t device_message__nvm_logs_size__get_packed_size(DeviceMessage__NvmLogsSize *message)
{
  size_t sVar1;
  DeviceMessage__NvmLogsSize *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8035370)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x4a5,
                  "device_message__nvm_logs_size__get_packed_size",
                  "message->base.descriptor == &device_message__nvm_logs_size__descriptor");
  }
  sVar1 = protobuf_c_message_get_packed_size(&message->base);
  return sVar1;
}



size_t device_message__nvm_logs_size__pack(DeviceMessage__NvmLogsSize *message,uint8_t *out)
{
  size_t sVar1;
  uint8_t *out_local;
  DeviceMessage__NvmLogsSize *message_local;
  
  if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8035370)
  {
                    // WARNING: Subroutine does not return
    __assert_func("./generated/message.pb-c.c",0x4ac,"device_message__nvm_logs_size__pack",
                  "message->base.descriptor == &device_message__nvm_logs_size__descriptor");
  }
  sVar1 = protobuf_c_message_pack(&message->base,out);
  return sVar1;
}



void device_message__dump_nvm_logs__init(DeviceMessage__DumpNvmLogs *message)
{
  DeviceMessage__DumpNvmLogs *message_local;
  
  (message->base).descriptor = &device_message__dump_nvm_logs__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  return;
}



void device_message__to_device__init(DeviceMessage__ToDevice *message)
{
  DeviceMessage__ToDevice *message_local;
  
  (message->base).descriptor = &device_message__to_device__descriptor;
  (message->base).n_unknown_fields = 0;
  (message->base).unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  message->message_case = DEVICE_MESSAGE__TO_DEVICE__MESSAGE__NOT_SET;
  (message->field_2).start_demo = (DeviceMessage__StartDemo *)0x0;
  return;
}



DeviceMessage__ToDevice *
device_message__to_device__unpack(ProtobufCAllocator *allocator,size_t len,uint8_t *data)
{
  DeviceMessage__ToDevice *pDVar1;
  uint8_t *data_local;
  size_t len_local;
  ProtobufCAllocator *allocator_local;
  
  pDVar1 = (DeviceMessage__ToDevice *)
           protobuf_c_message_unpack(&device_message__to_device__descriptor,allocator,len,data);
  return pDVar1;
}



void device_message__to_device__free_unpacked
               (DeviceMessage__ToDevice *message,ProtobufCAllocator *allocator)
{
  ProtobufCAllocator *allocator_local;
  DeviceMessage__ToDevice *message_local;
  
  if (message != (DeviceMessage__ToDevice *)0x0)
  {
    if ((message->base).descriptor != (ProtobufCMessageDescriptor *)0x8035728)
    {
                    // WARNING: Subroutine does not return
      __assert_func("./generated/message.pb-c.c",0x54d,"device_message__to_device__free_unpacked",
                    "message->base.descriptor == &device_message__to_device__descriptor");
    }
    protobuf_c_message_free_unpacked(&message->base,allocator);
  }
  return;
}



void device_message__radio_defs__lora_parameters__init
               (DeviceMessage__RadioDefs__LoraParameters *message)
{
  DeviceMessage__RadioDefs__LoraParameters *message_local;
  
  memset(message,0,0x30);
  (message->base).descriptor = &device_message__radio_defs__lora_parameters__descriptor;
  return;
}



void device_message__radio_defs__fsk_parameters__init
               (DeviceMessage__RadioDefs__FskParameters *message)
{
  DeviceMessage__RadioDefs__FskParameters *message_local;
  
  memset(message,0,0x58);
  (message->base).descriptor = &device_message__radio_defs__fsk_parameters__descriptor;
  return;
}



void device_message__radio_defs__flrc_parameters__init
               (DeviceMessage__RadioDefs__FlrcParameters *message)
{
  DeviceMessage__RadioDefs__FlrcParameters *message_local;
  
  memset(message,0,0x3c);
  (message->base).descriptor = &device_message__radio_defs__flrc_parameters__descriptor;
  return;
}



void device_message__radio_defs_ook__ook_parameters__init
               (DeviceMessage__RadioDefsOok__OokParameters *message)
{
  DeviceMessage__RadioDefsOok__OokParameters *message_local;
  
  memset(message,0,0x74);
  (message->base).descriptor = &device_message__radio_defs_ook__ook_parameters__descriptor;
  return;
}



ral_status_t ral_set_sleep(ral_t *radio,_Bool retain_config)
{
  ral_status_t rVar1;
  _Bool retain_config_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_sleep)(radio->context,retain_config);
  return rVar1;
}



ral_status_t ral_cfg_rx_boosted(ral_t *radio,_Bool enable_boost_mode)
{
  ral_status_t rVar1;
  _Bool enable_boost_mode_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).cfg_rx_boosted)(radio->context,enable_boost_mode);
  return rVar1;
}



ral_status_t ral_set_tx_cfg(ral_t *radio,int8_t output_pwr_in_dbm,uint32_t rf_freq_in_hz)
{
  ral_status_t rVar1;
  uint32_t rf_freq_in_hz_local;
  int8_t output_pwr_in_dbm_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_tx_cfg)(radio->context,output_pwr_in_dbm,rf_freq_in_hz);
  return rVar1;
}



ral_status_t ral_set_pkt_type(ral_t *radio,ral_pkt_type_t pkt_type)
{
  ral_status_t rVar1;
  ral_pkt_type_t pkt_type_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_pkt_type)(radio->context,pkt_type);
  return rVar1;
}



lr11xx_system_rfswitch_cfg_t * smtc_shield_lr11xx_get_rf_switch_cfg(smtc_shield_lr11xx_t *shield)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  smtc_shield_lr11xx_t *shield_local;
  
  plVar1 = (*shield->get_rf_switch_cfg)();
  return plVar1;
}



lr11xx_system_reg_mode_t smtc_shield_lr11xx_get_reg_mode(smtc_shield_lr11xx_t *shield)
{
  lr11xx_system_reg_mode_t lVar1;
  smtc_shield_lr11xx_t *shield_local;
  
  lVar1 = (*shield->get_reg_mode)();
  return lVar1;
}



smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr11xx_get_xosc_cfg(smtc_shield_lr11xx_t *shield)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  smtc_shield_lr11xx_t *shield_local;
  
  psVar1 = (*shield->get_xosc_cfg)();
  return psVar1;
}



smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr11xx_get_lfclk_cfg(smtc_shield_lr11xx_t *shield)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  smtc_shield_lr11xx_t *shield_local;
  
  psVar1 = (*shield->get_lfclk_cfg)();
  return psVar1;
}



smtc_shield_lr11xx_pinout_t * smtc_shield_lr11xx_get_pinout(smtc_shield_lr11xx_t *shield)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  smtc_shield_lr11xx_t *shield_local;
  
  psVar1 = (*shield->get_pinout)();
  return psVar1;
}



lr11xx_shield_t *
lr11xx_shield_get_instance
          (lr11xx_shield_t *__return_storage_ptr__,smtc_shield_lr11xx_t lr11xx_shield_specific)
{
  lr11xx_shield_t lr11xx_shield;
  
  lr11xx_shield_specific.get_rf_switch_cfg = (smtc_shield_lr11xx_get_rf_switch_cfg_f)&lr11xx_shield;
  memset(lr11xx_shield_specific.get_rf_switch_cfg,0,0x1c0);
  lr11xx_shield_specific.get_reg_mode = lr11xx_shield_specific.get_reg_mode;
  lr11xx_shield.lr11xx_shield_instance.get_reg_mode = lr11xx_shield_specific.get_reg_mode;
  lr11xx_shield_specific.get_xosc_cfg = lr11xx_shield_specific.get_xosc_cfg;
  lr11xx_shield_specific.get_lfclk_cfg = lr11xx_shield_specific.get_lfclk_cfg;
  lr11xx_shield_specific.get_pinout = lr11xx_shield_specific.get_pinout;
  lr11xx_shield_specific.get_rttof_recommended_rx_tx_delay_indicator =
       lr11xx_shield_specific.get_rttof_recommended_rx_tx_delay_indicator;
  lr11xx_shield.lr11xx_shield_instance.get_xosc_cfg = lr11xx_shield_specific.get_xosc_cfg;
  lr11xx_shield.lr11xx_shield_instance.get_lfclk_cfg = lr11xx_shield_specific.get_lfclk_cfg;
  lr11xx_shield.lr11xx_shield_instance.get_pinout = lr11xx_shield_specific.get_pinout;
  lr11xx_shield.lr11xx_shield_instance.get_rttof_recommended_rx_tx_delay_indicator =
       lr11xx_shield_specific.get_rttof_recommended_rx_tx_delay_indicator;
  lr11xx_shield.base.vtable = &lr11xx_shield_get_instance::vtable;
  lr11xx_shield_specific.get_rf_switch_cfg = (smtc_shield_lr11xx_get_rf_switch_cfg_f)&lr11xx_shield;
  memcpy(__return_storage_ptr__,lr11xx_shield_specific.get_rf_switch_cfg,0x1c0);
  return __return_storage_ptr__;
}



shield_status_t lr11xx_shield_system_init(shield_t *self)
{
  lr11xx_status_t lVar1;
  lr11xx_system_reg_mode_t reg_mode;
  lr11xx_system_rfswitch_cfg_t *rf_switch_cfg;
  smtc_shield_lr11xx_xosc_cfg_t *psVar2;
  smtc_shield_lr11xx_lfclk_cfg_t *psVar3;
  shield_t *self_local;
  uint16_t errors;
  smtc_shield_lr11xx_t shield_instance;
  lr11xx_status_t status_9;
  lr11xx_status_t status_8;
  lr11xx_status_t status_7;
  lr11xx_status_t status_6;
  lr11xx_status_t status_5;
  lr11xx_status_t status_4;
  smtc_shield_lr11xx_lfclk_cfg_t *lfclk_cfg;
  lr11xx_status_t status_3;
  smtc_shield_lr11xx_xosc_cfg_t *tcxo_cfg;
  lr11xx_status_t status_2;
  lr11xx_system_rfswitch_cfg_t *rf_switch_setup;
  lr11xx_status_t status_1;
  lr11xx_system_reg_mode_t regulator;
  lr11xx_status_t status;
  lr11xx_shield_t *myself;
  
  shield_instance.get_pa_pwr_cfg = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)self[1].vtable;
  shield_instance.get_rssi_calibration_table =
       (smtc_shield_lr11xx_get_rssi_calibration_table_f)self[2].vtable;
  shield_instance.get_rf_switch_cfg = (smtc_shield_lr11xx_get_rf_switch_cfg_f)self[3].vtable;
  shield_instance.get_reg_mode = (smtc_shield_lr11xx_get_reg_mode_f)self[4].vtable;
  shield_instance.get_xosc_cfg = (smtc_shield_lr11xx_get_xosc_cfg_f)self[5].vtable;
  shield_instance.get_lfclk_cfg = (smtc_shield_lr11xx_get_lfclk_cfg_f)self[6].vtable;
  shield_instance.get_pinout = (smtc_shield_lr11xx_get_pinout_f)self[7].vtable;
  shield_instance.get_rttof_recommended_rx_tx_delay_indicator =
       (smtc_shield_lr11xx_get_rttof_recommended_rx_tx_delay_indicator_f)self[8].vtable;
  lVar1 = lr11xx_system_reset(self + 9);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xce,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xce,(uint)lVar1);
  }
  reg_mode = smtc_shield_lr11xx_get_reg_mode(&shield_instance);
  lVar1 = lr11xx_system_set_reg_mode(self + 9,reg_mode);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xd2,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xd2,(uint)lVar1);
  }
  rf_switch_cfg = smtc_shield_lr11xx_get_rf_switch_cfg(&shield_instance);
  lVar1 = lr11xx_system_set_dio_as_rf_switch(self + 9,rf_switch_cfg);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xd5,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xd5,(uint)lVar1);
  }
  psVar2 = smtc_shield_lr11xx_get_xosc_cfg(&shield_instance);
  if ((psVar2->has_tcxo != false) &&
     (lVar1 = lr11xx_system_set_tcxo_mode(self + 9,psVar2->supply,psVar2->startup_time_in_tick),
     lVar1 != LR11XX_STATUS_OK))
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xda,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xda,(uint)lVar1);
  }
  psVar3 = smtc_shield_lr11xx_get_lfclk_cfg(&shield_instance);
  lVar1 = lr11xx_system_cfg_lfclk(self + 9,psVar3->lf_clk_cfg,psVar3->wait_32k_ready);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xdf,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xdf,(uint)lVar1);
  }
  lVar1 = lr11xx_system_clear_errors(self + 9);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xe2,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xe2,(uint)lVar1);
  }
  lVar1 = lr11xx_system_calibrate(self + 9,'?');
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xe3,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xe3,(uint)lVar1);
  }
  lVar1 = lr11xx_system_get_errors(self + 9,&errors);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xe6,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xe6,(uint)lVar1);
  }
  lVar1 = lr11xx_system_clear_errors(self + 9);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xe7,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xe7,(uint)lVar1);
  }
  lVar1 = lr11xx_system_clear_irq_status(self + 9,0xbffcffc);
  if (lVar1 != LR11XX_STATUS_OK)
  {
    if (lVar1 == LR11XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80381dc,0xe8,0x8032dc4);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8032dd8,0x80381dc,0xe8,(uint)lVar1);
  }
  return SHIELD_STATUS_OK;
}



void lr11xx_shield_init(shield_t *self,_func_void_void_ptr *callback)
{
  smtc_hal_mcu_status_t sVar1;
  smtc_shield_lr11xx_pinout_t *psVar2;
  shield_interface_t *psVar3;
  _func_void_void_ptr *callback_local;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  smtc_shield_lr11xx_pinout_t *shield_pinout;
  lr11xx_shield_t *myself;
  
  psVar2 = smtc_shield_lr11xx_get_pinout((smtc_shield_lr11xx_t *)(self + 1));
  lr11xx_shield_init_context((lr11xx_hal_context_t *)(self + 9),callback);
  memset(self + 0x2a,0,0x118);
  self[0x2a].vtable = (shield_interface_t *)(self + 9);
  self[0x2b].vtable = (shield_interface_t *)0x8022fa9;
  self[0x2c].vtable = (shield_interface_t *)0x8022fe9;
  self[0x2d].vtable = (shield_interface_t *)0x8023001;
  self[0x2e].vtable = (shield_interface_t *)0x8023107;
  self[0x2f].vtable = (shield_interface_t *)0x802311f;
  self[0x30].vtable = (shield_interface_t *)0x802317d;
  self[0x31].vtable = (shield_interface_t *)0x80231bb;
  self[0x32].vtable = (shield_interface_t *)0x80231d3;
  self[0x33].vtable = (shield_interface_t *)0x80231ed;
  self[0x34].vtable = (shield_interface_t *)0x802322b;
  self[0x35].vtable = (shield_interface_t *)0x802324b;
  self[0x36].vtable = (shield_interface_t *)0x8023297;
  self[0x37].vtable = (shield_interface_t *)0x80232b7;
  self[0x38].vtable = (shield_interface_t *)0x80232d9;
  self[0x39].vtable = (shield_interface_t *)0x80232f1;
  self[0x3a].vtable = (shield_interface_t *)0x8023309;
  self[0x3b].vtable = (shield_interface_t *)0x8023321;
  self[0x3c].vtable = (shield_interface_t *)0x8023347;
  self[0x3d].vtable = (shield_interface_t *)0x80233b1;
  self[0x3e].vtable = (shield_interface_t *)0x80233d7;
  self[0x3f].vtable = (shield_interface_t *)0x8023441;
  self[0x40].vtable = (shield_interface_t *)0x8023485;
  self[0x41].vtable = (shield_interface_t *)0x80234a9;
  self[0x42].vtable = (shield_interface_t *)0x80234f3;
  self[0x43].vtable = (shield_interface_t *)0x8023519;
  self[0x44].vtable = (shield_interface_t *)0x802356f;
  self[0x45].vtable = (shield_interface_t *)0x80235bb;
  self[0x46].vtable = (shield_interface_t *)0x802360b;
  self[0x47].vtable = (shield_interface_t *)0x8023657;
  self[0x49].vtable = (shield_interface_t *)0x80236a3;
  self[0x4a].vtable = (shield_interface_t *)0x80236e3;
  self[0x4b].vtable = (shield_interface_t *)0x802372d;
  self[0x4c].vtable = (shield_interface_t *)0x802376d;
  self[0x4d].vtable = (shield_interface_t *)0x802378d;
  self[0x4e].vtable = (shield_interface_t *)0x80237a5;
  self[0x4f].vtable = (shield_interface_t *)0x80237bd;
  self[0x50].vtable = (shield_interface_t *)0x802388b;
  self[0x51].vtable = (shield_interface_t *)0x80238db;
  self[0x52].vtable = (shield_interface_t *)0x80238f3;
  self[0x53].vtable = (shield_interface_t *)0x8023921;
  self[0x54].vtable = (shield_interface_t *)0x802395d;
  self[0x55].vtable = (shield_interface_t *)0x8023999;
  self[0x56].vtable = (shield_interface_t *)0x80239b1;
  self[0x57].vtable = (shield_interface_t *)0x8023a05;
  self[0x58].vtable = (shield_interface_t *)0x8023a25;
  self[0x59].vtable = (shield_interface_t *)0x8023a41;
  self[0x5a].vtable = (shield_interface_t *)0x8023a61;
  self[0x5b].vtable = (shield_interface_t *)0x8023a79;
  self[0x5c].vtable = (shield_interface_t *)0x8023a99;
  self[0x5d].vtable = (shield_interface_t *)0x8023ab3;
  self[0x5e].vtable = (shield_interface_t *)0x8023b4b;
  self[0x5f].vtable = (shield_interface_t *)0x8023b65;
  self[0x60].vtable = (shield_interface_t *)0x8023b7f;
  self[0x61].vtable = (shield_interface_t *)0x8023bb9;
  self[0x62].vtable = (shield_interface_t *)0x8023beb;
  self[99].vtable = (shield_interface_t *)0x8023c27;
  self[100].vtable = (shield_interface_t *)0x8023c41;
  self[0x65].vtable = (shield_interface_t *)0x8023c8d;
  self[0x66].vtable = (shield_interface_t *)0x8023cbd;
  self[0x67].vtable = (shield_interface_t *)0x8023cf1;
  self[0x68].vtable = (shield_interface_t *)0x8023d3d;
  self[0x69].vtable = (shield_interface_t *)0x8023d53;
  self[0x6a].vtable = (shield_interface_t *)0x8023d69;
  self[0x6b].vtable = (shield_interface_t *)0x8024675;
  self[0x6c].vtable = (shield_interface_t *)0x80247b7;
  self[0x6d].vtable = (shield_interface_t *)0x8024695;
  self[0x6e].vtable = (shield_interface_t *)0x80246b1;
  self[0x6f].vtable = (shield_interface_t *)0x80246cd;
  if (psVar2->led_tx != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar3 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(psVar2->led_tx);
    self[0x1e].vtable = psVar3;
    *(undefined1 *)&self[0x1f].vtable = 0;
    *(undefined1 *)((int)&self[0x1f].vtable + 1) = 2;
    sVar1 = smtc_hal_mcu_gpio_init_output
                      ((smtc_hal_mcu_gpio_cfg_t)self[0x1e].vtable,
                       (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x1f),
                       (smtc_hal_mcu_gpio_inst_t *)(self + 0x20));
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80381f8,0xfb,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80381f8,0xfb,(uint)sVar1);
      }
    }
  }
  if (psVar2->led_rx != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar3 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(psVar2->led_rx);
    self[0x21].vtable = psVar3;
    *(undefined1 *)&self[0x22].vtable = 0;
    *(undefined1 *)((int)&self[0x22].vtable + 1) = 2;
    sVar1 = smtc_hal_mcu_gpio_init_output
                      ((smtc_hal_mcu_gpio_cfg_t)self[0x21].vtable,
                       (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x22),
                       (smtc_hal_mcu_gpio_inst_t *)(self + 0x23));
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80381f8,0x105,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80381f8,0x105,(uint)sVar1);
      }
    }
  }
  if (psVar2->led_scan != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar3 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(psVar2->led_scan);
    self[0x24].vtable = psVar3;
    *(undefined1 *)&self[0x25].vtable = 0;
    *(undefined1 *)((int)&self[0x25].vtable + 1) = 2;
    sVar1 = smtc_hal_mcu_gpio_init_output
                      ((smtc_hal_mcu_gpio_cfg_t)self[0x24].vtable,
                       (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x25),
                       (smtc_hal_mcu_gpio_inst_t *)(self + 0x26));
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80381f8,0x10f,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80381f8,0x10f,(uint)sVar1);
      }
    }
  }
  if (psVar2->lna != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar3 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(psVar2->lna);
    self[0x27].vtable = psVar3;
    *(undefined1 *)&self[0x28].vtable = 0;
    *(undefined1 *)((int)&self[0x28].vtable + 1) = 2;
    sVar1 = smtc_hal_mcu_gpio_init_output
                      ((smtc_hal_mcu_gpio_cfg_t)self[0x27].vtable,
                       (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x28),
                       (smtc_hal_mcu_gpio_inst_t *)(self + 0x29));
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80381f8,0x119,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80381f8,0x119,(uint)sVar1);
      }
    }
  }
  return;
}



void lr11xx_shield_deinit(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  smtc_shield_lr11xx_pinout_t *psVar2;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  smtc_shield_lr11xx_pinout_t *shield_pinout;
  lr11xx_shield_t *myself;
  
  psVar2 = smtc_shield_lr11xx_get_pinout((smtc_shield_lr11xx_t *)(self + 1));
  lr11xx_shield_deinit_context((lr11xx_hal_context_t *)(self + 9));
  if (((psVar2->led_tx != SMTC_SHIELD_PINOUT_NONE) &&
      (self[0x20].vtable != (shield_interface_t *)0x0)) &&
     (sVar1 = smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x20)),
     sVar1 != SMTC_HAL_MCU_STATUS_OK))
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x803820c,0x127,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x803820c,0x127,(uint)sVar1);
    }
  }
  if (((psVar2->led_rx != SMTC_SHIELD_PINOUT_NONE) &&
      (self[0x23].vtable != (shield_interface_t *)0x0)) &&
     (sVar1 = smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x23)),
     sVar1 != SMTC_HAL_MCU_STATUS_OK))
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x803820c,299,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x803820c,299,(uint)sVar1);
    }
  }
  if (((psVar2->led_scan != SMTC_SHIELD_PINOUT_NONE) &&
      (self[0x26].vtable != (shield_interface_t *)0x0)) &&
     (sVar1 = smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x26)),
     sVar1 != SMTC_HAL_MCU_STATUS_OK))
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x803820c,0x12f,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x803820c,0x12f,(uint)sVar1);
    }
  }
  if (((psVar2->lna != SMTC_SHIELD_PINOUT_NONE) && (self[0x29].vtable != (shield_interface_t *)0x0))
     && (sVar1 = smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x29)),
        sVar1 != SMTC_HAL_MCU_STATUS_OK))
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x803820c,0x133,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x803820c,0x133,(uint)sVar1);
    }
  }
  return;
}



void lr11xx_shield_init_context(lr11xx_hal_context_t *context,_func_void_void_ptr *callback)
{
  smtc_hal_mcu_status_t sVar1;
  smtc_hal_mcu_gpio_cfg_t psVar2;
  _func_void_void_ptr *callback_local;
  lr11xx_hal_context_t *context_local;
  smtc_hal_mcu_spi_cfg_app_t cfg;
  smtc_hal_mcu_status_t status_5;
  smtc_hal_mcu_status_t status_4;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  
  psVar2 = smtc_shield_pinout_mapping_get_gpio_cfg(SMTC_SHIELD_PINOUT_D3);
  (context->busy).cfg = psVar2;
  (context->busy).cfg_input.pull_mode = SMTC_HAL_MCU_GPIO_PULL_MODE_NONE;
  (context->busy).cfg_input.irq_mode = SMTC_HAL_MCU_GPIO_IRQ_MODE_OFF;
  (context->busy).cfg_input.callback = (_func_void_void_ptr *)0x0;
  psVar2 = smtc_shield_pinout_mapping_get_gpio_cfg(SMTC_SHIELD_PINOUT_D5);
  (context->irq).cfg = psVar2;
  (context->irq).cfg_input.pull_mode = SMTC_HAL_MCU_GPIO_PULL_MODE_NONE;
  (context->irq).cfg_input.irq_mode = SMTC_HAL_MCU_GPIO_IRQ_MODE_RISING;
  (context->irq).cfg_input.callback = callback;
  (context->irq).cfg_input.context = (void *)0x0;
  psVar2 = smtc_shield_pinout_mapping_get_gpio_cfg(SMTC_SHIELD_PINOUT_D7);
  (context->nss).cfg = psVar2;
  (context->nss).cfg_output.initial_state = SMTC_HAL_MCU_GPIO_STATE_HIGH;
  (context->nss).cfg_output.mode = SMTC_HAL_MCU_GPIO_OUTPUT_MODE_PUSH_PULL;
  psVar2 = smtc_shield_pinout_mapping_get_gpio_cfg(SMTC_SHIELD_PINOUT_A0);
  (context->reset).cfg = psVar2;
  (context->reset).cfg_output.initial_state = SMTC_HAL_MCU_GPIO_STATE_HIGH;
  (context->reset).cfg_output.mode = SMTC_HAL_MCU_GPIO_OUTPUT_MODE_PUSH_PULL;
  (context->spi).cfg.spi = (SPI_TypeDef *)&SPI1;
  sVar1 = smtc_hal_mcu_gpio_init_input
                    ((context->busy).cfg,&(context->busy).cfg_input,&(context->busy).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038224,0x14e,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038224,0x14e,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_init_input
                    ((context->irq).cfg,&(context->irq).cfg_input,&(context->irq).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038224,0x150,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038224,0x150,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_init_output
                    ((context->nss).cfg,&(context->nss).cfg_output,&(context->nss).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038224,0x152,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038224,0x152,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_init_output
                    ((context->reset).cfg,&(context->reset).cfg_output,&(context->reset).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038224,0x154,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038224,0x154,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_enable_irq((context->irq).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038224,0x157,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038224,0x157,(uint)sVar1);
    }
  }
  cfg.is_master = true;
  sVar1 = smtc_hal_mcu_spi_init((smtc_hal_mcu_spi_cfg_t)context,&cfg,&(context->spi).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038224,0x15b,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038224,0x15b,(uint)sVar1);
    }
  }
  return;
}



void lr11xx_shield_deinit_context(lr11xx_hal_context_t *context)
{
  smtc_hal_mcu_status_t sVar1;
  lr11xx_hal_context_t *context_local;
  smtc_hal_mcu_status_t status_5;
  smtc_hal_mcu_status_t status_4;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  
  sVar1 = smtc_hal_mcu_spi_deinit(&(context->spi).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038240,0x160,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038240,0x160,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_disable_irq((context->irq).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038240,0x161,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038240,0x161,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_deinit(&(context->busy).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038240,0x163,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038240,0x163,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_deinit(&(context->irq).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038240,0x164,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038240,0x164,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_deinit(&(context->nss).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038240,0x165,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038240,0x165,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_deinit(&(context->reset).inst);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038240,0x166,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038240,0x166,(uint)sVar1);
    }
  }
  return;
}



void lr11xx_shield_init_identification(shield_t *self)
{
  shield_t *self_local;
  lr11xx_shield_t *myself;
  
  self[0x1d].vtable = (shield_interface_t *)0x0;
  *(undefined2 *)&self[0x1b].vtable = 0xffff;
  self[0x1c].vtable = (shield_interface_t *)0x0;
  return;
}



ral_t * lr11xx_shield_get_ral_instance(shield_t *self)
{
  shield_t *self_local;
  lr11xx_shield_t *myself;
  
  return (ral_t *)(self + 0x2a);
}



void lr11xx_shield_handle_pre_rx(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_t *self_local;
  smtc_hal_mcu_status_t status;
  lr11xx_shield_t *myself;
  
  sVar1 = smtc_hal_mcu_gpio_set_state
                    ((smtc_hal_mcu_gpio_inst_t)self[0x23].vtable,SMTC_HAL_MCU_GPIO_STATE_HIGH);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x8038260,0x17b,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x8038260,0x17b,(uint)sVar1);
    }
  }
  return;
}



void lr11xx_shield_handle_post_rx(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_t *self_local;
  smtc_hal_mcu_status_t status;
  lr11xx_shield_t *myself;
  
  sVar1 = smtc_hal_mcu_gpio_set_state
                    ((smtc_hal_mcu_gpio_inst_t)self[0x23].vtable,SMTC_HAL_MCU_GPIO_STATE_LOW);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x803827c,0x181,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x803827c,0x181,(uint)sVar1);
    }
  }
  return;
}



void lr11xx_shield_handle_pre_tx(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_t *self_local;
  smtc_hal_mcu_status_t status;
  lr11xx_shield_t *myself;
  
  sVar1 = smtc_hal_mcu_gpio_set_state
                    ((smtc_hal_mcu_gpio_inst_t)self[0x20].vtable,SMTC_HAL_MCU_GPIO_STATE_HIGH);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x803829c,0x187,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x803829c,0x187,(uint)sVar1);
    }
  }
  return;
}



void lr11xx_shield_handle_post_tx(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_t *self_local;
  smtc_hal_mcu_status_t status;
  lr11xx_shield_t *myself;
  
  sVar1 = smtc_hal_mcu_gpio_set_state
                    ((smtc_hal_mcu_gpio_inst_t)self[0x20].vtable,SMTC_HAL_MCU_GPIO_STATE_LOW);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8032dd8,0x80382b8,0x18d,0x8032e14);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8032dd8,0x80382b8,0x18d,(uint)sVar1);
    }
  }
  return;
}



shield_status_t
lr11xx_shield_set_pkt_type(shield_t *self,ral_t *radio,shield_packet_type_t packet_type)
{
  ral_status_t rVar1;
  shield_status_t sVar2;
  shield_packet_type_t packet_type_local;
  ral_t *radio_local;
  shield_t *self_local;
  ral_status_t status;
  
  if (packet_type < SHIELD_PKT_TYPE_OOK)
  {
    rVar1 = ral_set_pkt_type(radio,packet_type);
    if (rVar1 != RAL_STATUS_OK)
    {
      if (rVar1 == RAL_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80382d8,0x199,0x8032e58);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80382d8,0x199,(uint)rVar1);
      }
    }
    sVar2 = SHIELD_STATUS_OK;
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, unsupported packet type");
    sVar2 = SHIELD_STATUS_ERROR;
  }
  return sVar2;
}



shield_status_t lr11xx_shield_set_chip_patch(shield_t *shield)
{
  shield_t *shield_local;
  
  return SHIELD_STATUS_OK;
}



shield_status_t lr11xx_shield_set_ook_detection_level(shield_t *shield,int16_t threshold_level_db)
{
  int16_t threshold_level_db_local;
  shield_t *shield_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, shield_set_ook_detection_level not supported for lr11xx");
  return SHIELD_STATUS_ERROR;
}



// WARNING: Variable defined which should be unmapped: inst_rssi_local
// WARNING: Variable defined which should be unmapped: self_local

shield_status_t lr11xx_shield_configure_and_get_inst_rssi(shield_t *self,int16_t *inst_rssi)
{
  int16_t *inst_rssi_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, shield_configure_and_get_inst_rssi not supported for lr11xx",
                      inst_rssi,self);
  return SHIELD_STATUS_ERROR;
}



shield_status_t
lr11xx_shield_set_flrc_syncword
          (shield_t *self,uint8_t *syncword,uint8_t syncword_index,uint8_t syncword_len)
{
  uint8_t syncword_len_local;
  uint8_t syncword_index_local;
  uint8_t *syncword_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_flrc_syncword not supported");
  return SHIELD_STATUS_ERROR;
}



// WARNING: Variable defined which should be unmapped: flrc_pkt_params_local
// WARNING: Variable defined which should be unmapped: self_local

shield_status_t
lr11xx_shield_set_flrc_pkt_params(shield_t *self,shield_flrc_pkt_params_t *flrc_pkt_params)
{
  shield_flrc_pkt_params_t *flrc_pkt_params_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_flrc_pkt_params not supported",flrc_pkt_params,self);
  return SHIELD_STATUS_ERROR;
}



// WARNING: Variable defined which should be unmapped: flrc_mod_params_local
// WARNING: Variable defined which should be unmapped: self_local

shield_status_t
lr11xx_shield_set_flrc_mod_params(shield_t *self,shield_flrc_mod_params_t *flrc_mod_params)
{
  shield_flrc_mod_params_t *flrc_mod_params_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_flrc_mod_params not supported",flrc_mod_params,self);
  return SHIELD_STATUS_ERROR;
}



shield_status_t
lr11xx_shield_set_ook_pkt_params
          (shield_t *self,shield_ook_pkt_params_t *ook_pkt_params,_Bool apply_workaround)
{
  _Bool apply_workaround_local;
  shield_ook_pkt_params_t *ook_pkt_params_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_pkt_params not supported");
  return SHIELD_STATUS_ERROR;
}



// WARNING: Variable defined which should be unmapped: ook_mod_params_local
// WARNING: Variable defined which should be unmapped: self_local

shield_status_t
lr11xx_shield_set_ook_mod_params(shield_t *self,shield_ook_mod_params_t *ook_mod_params)
{
  shield_ook_mod_params_t *ook_mod_params_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_mod_params not supported",ook_mod_params,self);
  return SHIELD_STATUS_ERROR;
}



shield_status_t lr11xx_shield_set_ook_crc_params(shield_t *self,uint32_t polynomial,uint32_t seed)
{
  uint32_t seed_local;
  uint32_t polynomial_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_crc_params not supported");
  return SHIELD_STATUS_ERROR;
}



shield_status_t
lr11xx_shield_set_ook_set_syncword
          (shield_t *self,uint8_t *syncword,uint8_t sync_len,uint8_t sync_len_bits,
          shield_ook_syncword_bit_order_t bit_order)
{
  uint8_t sync_len_bits_local;
  uint8_t sync_len_local;
  uint8_t *syncword_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_set_syncword not supported");
  return SHIELD_STATUS_ERROR;
}



shield_status_t
lr11xx_shield_set_ook_set_addresses(shield_t *self,uint32_t node_address,uint32_t broadcast_address)
{
  uint32_t broadcast_address_local;
  uint32_t node_address_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_set_addresses not supported");
  return SHIELD_STATUS_ERROR;
}



// WARNING: Variable defined which should be unmapped: whitening_params_local
// WARNING: Variable defined which should be unmapped: self_local

shield_status_t
lr11xx_shield_set_ook_set_whitening_params
          (shield_t *self,shield_ook_whitening_params_t *whitening_params)
{
  shield_ook_whitening_params_t *whitening_params_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_set_whitening_params not supported",whitening_params,
                      self);
  return SHIELD_STATUS_ERROR;
}



// WARNING: Variable defined which should be unmapped: rx_detector_params_local
// WARNING: Variable defined which should be unmapped: self_local

shield_status_t
lr11xx_shield_set_ook_rx_detector(shield_t *self,shield_ook_rx_detector_t *rx_detector_params)
{
  shield_ook_rx_detector_t *rx_detector_params_local;
  shield_t *self_local;
  
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                      "Shield Error, set_ook_set_rx_detector not supported",rx_detector_params,self)
  ;
  return SHIELD_STATUS_ERROR;
}



void lr11xx_shield_identify(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_interface_t *psVar2;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_5;
  smtc_hal_mcu_status_t status_4;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  uint32_t now_ms;
  lr11xx_shield_t *myself;
  
  psVar2 = (shield_interface_t *)support_timing_get_time();
  if ((self[0x23].vtable == (shield_interface_t *)0x0) ||
     (self[0x20].vtable == (shield_interface_t *)0x0))
  {
    lr11xx_shield_init(self,(_func_void_void_ptr *)0x0);
  }
  if (self[0x1d].vtable == (shield_interface_t *)0x0)
  {
    self[0x1c].vtable = psVar2;
    *(undefined2 *)&self[0x1b].vtable = 10;
    sVar1 = smtc_hal_mcu_gpio_get_state
                      ((smtc_hal_mcu_gpio_inst_t)self[0x23].vtable,
                       &lr11xx_shield_identify::previous_rx_led_state);
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80382f4,0x206,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80382f4,0x206,(uint)sVar1);
      }
    }
    sVar1 = smtc_hal_mcu_gpio_get_state
                      ((smtc_hal_mcu_gpio_inst_t)self[0x20].vtable,
                       &lr11xx_shield_identify::previous_tx_led_state);
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80382f4,0x207,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80382f4,0x207,(uint)sVar1);
      }
    }
  }
  if (((psVar2 < &self[0x1d].vtable[1].shield_set_ook_set_addresses) &&
      (self[0x1d].vtable != (shield_interface_t *)0x0)) || (*(short *)&self[0x1b].vtable < 0))
  {
    if (*(short *)&self[0x1b].vtable < 0)
    {
      self[0x1d].vtable = (shield_interface_t *)0x0;
      sVar1 = smtc_hal_mcu_gpio_set_state
                        ((smtc_hal_mcu_gpio_inst_t)self[0x20].vtable,
                         lr11xx_shield_identify::previous_tx_led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8032dd8,0x80382f4,0x21c,0x8032e14);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8032dd8,0x80382f4,0x21c,(uint)sVar1);
        }
      }
      sVar1 = smtc_hal_mcu_gpio_set_state
                        ((smtc_hal_mcu_gpio_inst_t)self[0x23].vtable,
                         lr11xx_shield_identify::previous_rx_led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8032dd8,0x80382f4,0x21d,0x8032e14);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8032dd8,0x80382f4,0x21d,(uint)sVar1);
        }
      }
    }
  }
  else
  {
    sVar1 = smtc_hal_mcu_gpio_set_state
                      ((smtc_hal_mcu_gpio_inst_t)self[0x20].vtable,lr11xx_shield_identify::led_state
                      );
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80382f4,0x20e,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80382f4,0x20e,(uint)sVar1);
      }
    }
    sVar1 = smtc_hal_mcu_gpio_set_state
                      ((smtc_hal_mcu_gpio_inst_t)self[0x23].vtable,lr11xx_shield_identify::led_state
                      );
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8032dd8,0x80382f4,0x20f,0x8032e14);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x8032dd8,0x80382f4,0x20f,(uint)sVar1);
      }
    }
    lr11xx_shield_identify::led_state ^= SMTC_HAL_MCU_GPIO_STATE_HIGH;
    *(short *)&self[0x1b].vtable = *(short *)&self[0x1b].vtable + -1;
    self[0x1d].vtable = psVar2;
  }
  return;
}



_Bool lr11xx_is_identification_running(shield_t *self)
{
  undefined1 uVar1;
  shield_interface_t *psVar2;
  bool bVar3;
  shield_t *self_local;
  lr11xx_shield_t *myself;
  
  psVar2 = self[0x1d].vtable;
  bVar3 = psVar2 != (shield_interface_t *)0x0;
  if (bVar3)
  {
    psVar2 = (shield_interface_t *)0x1;
  }
  uVar1 = SUB41(psVar2,0);
  if (!bVar3)
  {
    uVar1 = 0;
  }
  return (_Bool)uVar1;
}



void lr11xx_shield_runtime(shield_t *self)
{
  _Bool _Var1;
  uint32_t uVar2;
  shield_t *self_local;
  uint32_t now_ms;
  lr11xx_shield_t *myself;
  
  _Var1 = lr11xx_is_identification_running(self);
  if (_Var1)
  {
    uVar2 = support_timing_get_time();
    if (uVar2 - (int)self[0x1c].vtable < 0x2711)
    {
      lr11xx_shield_identify(self);
    }
    else
    {
      lr11xx_shield_init_identification(self);
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          true,"Maximum identification duration time reached");
    }
  }
  return;
}



shield_status_t
lr11xx_shield_set_tx_cfg(shield_t *self,int32_t power_in_half_dbm,uint32_t frequency)
{
  ral_status_t rVar1;
  uint32_t frequency_local;
  int32_t power_in_half_dbm_local;
  shield_t *self_local;
  lr11xx_shield_t *myself;
  
  rVar1 = ral_set_tx_cfg((ral_t *)(self + 0x2a),(int8_t)(power_in_half_dbm / 2),frequency);
  return rVar1 != RAL_STATUS_OK;
}



shield_status_t lr11xx_shield_set_rx_boost_mode(shield_t *shield,_Bool rx_boost,uint32_t frequency)
{
  ral_status_t rVar1;
  uint32_t frequency_local;
  _Bool rx_boost_local;
  shield_t *shield_local;
  lr11xx_shield_t *myself;
  
  rVar1 = ral_cfg_rx_boosted((ral_t *)(shield + 0x2a),rx_boost);
  return rVar1 != RAL_STATUS_OK;
}



shield_status_t lr11xx_shield_set_sleep(shield_t *self,_Bool retain_data,_Bool retain_rtc)
{
  ral_status_t rVar1;
  _Bool retain_rtc_local;
  _Bool retain_data_local;
  shield_t *self_local;
  lr11xx_shield_t *myself;
  
  rVar1 = ral_set_sleep((ral_t *)(self + 0x2a),retain_data);
  return rVar1 != RAL_STATUS_OK;
}



ral_status_t ral_set_pkt_type(ral_t *radio,ral_pkt_type_t pkt_type)
{
  ral_status_t rVar1;
  ral_pkt_type_t pkt_type_local;
  ral_t *radio_local;
  
  rVar1 = (*(radio->driver).set_pkt_type)(radio->context,pkt_type);
  return rVar1;
}



smtc_shield_lr20xx_pa_pwr_cfg_t *
smtc_shield_lr20xx_get_pa_pwr_cfg
          (smtc_shield_lr20xx_t *shield,uint32_t rf_freq_in_hz,
          int8_t expected_output_pwr_in_half_dbm)
{
  smtc_shield_lr20xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_half_dbm_local;
  uint32_t rf_freq_in_hz_local;
  smtc_shield_lr20xx_t *shield_local;
  
  psVar1 = (*shield->get_pa_pwr_cfg)(rf_freq_in_hz,expected_output_pwr_in_half_dbm);
  return psVar1;
}



lr20xx_system_dio_rf_switch_cfg_t *
smtc_shield_lr20xx_get_rf_switch_cfg(smtc_shield_lr20xx_t *shield,lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_rf_switch_cfg_t *plVar1;
  lr20xx_system_dio_t dio_local;
  smtc_shield_lr20xx_t *shield_local;
  
  plVar1 = (*shield->get_rf_switch_cfg)(dio);
  return plVar1;
}



lr20xx_system_dio_drive_t
smtc_shield_lr20xx_get_dio_sleep_drive(smtc_shield_lr20xx_t *shield,lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_drive_t *plVar1;
  lr20xx_system_dio_t dio_local;
  smtc_shield_lr20xx_t *shield_local;
  lr20xx_system_dio_drive_t *dio_sleep_drive;
  
  plVar1 = (*shield->get_dio_sleep_drive)(dio);
  return *plVar1;
}



lr20xx_system_dio_func_t
smtc_shield_lr20xx_get_dio_function(smtc_shield_lr20xx_t *shield,lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_func_t *plVar1;
  lr20xx_system_dio_t dio_local;
  smtc_shield_lr20xx_t *shield_local;
  lr20xx_system_dio_func_t *dio_func;
  
  plVar1 = (*shield->get_dio_function)(dio);
  return *plVar1;
}



smtc_shield_lr20xx_xosc_cfg_t * smtc_shield_lr20xx_get_xosc_cfg(smtc_shield_lr20xx_t *shield)
{
  smtc_shield_lr20xx_xosc_cfg_t *psVar1;
  smtc_shield_lr20xx_t *shield_local;
  
  psVar1 = (*shield->get_xosc_cfg)();
  return psVar1;
}



lr20xx_system_lfclk_cfg_t smtc_shield_lr20xx_get_lfclk_cfg(smtc_shield_lr20xx_t *shield)
{
  lr20xx_system_lfclk_cfg_t *plVar1;
  smtc_shield_lr20xx_t *shield_local;
  lr20xx_system_lfclk_cfg_t *lfclk_cfg;
  
  plVar1 = (*shield->get_lfclk_cfg)();
  return *plVar1;
}



smtc_shield_lr20xx_pinout_t * smtc_shield_lr20xx_get_pinout(smtc_shield_lr20xx_t *shield)
{
  smtc_shield_lr20xx_pinout_t *psVar1;
  smtc_shield_lr20xx_t *shield_local;
  
  psVar1 = (*shield->get_pinout)();
  return psVar1;
}



lr20xx_shield_t *
lr20xx_shield_get_instance
          (lr20xx_shield_t *__return_storage_ptr__,smtc_shield_lr20xx_t lr20xx_shield_specific)
{
  lr20xx_shield_t lr20xx_shield;
  
  lr20xx_shield_specific.get_rf_switch_cfg = (smtc_shield_lr20xx_get_rf_switch_cfg_f)&lr20xx_shield;
  memset(lr20xx_shield_specific.get_rf_switch_cfg,0,0x1c8);
  lr20xx_shield_specific.get_dio_sleep_drive = lr20xx_shield_specific.get_dio_sleep_drive;
  lr20xx_shield.lr20xx_shield_instance.get_dio_sleep_drive =
       lr20xx_shield_specific.get_dio_sleep_drive;
  lr20xx_shield_specific.get_dio_function = lr20xx_shield_specific.get_dio_function;
  lr20xx_shield_specific.get_dio_irq_mask = lr20xx_shield_specific.get_dio_irq_mask;
  lr20xx_shield_specific.get_reg_mode = lr20xx_shield_specific.get_reg_mode;
  lr20xx_shield_specific.get_xosc_cfg = lr20xx_shield_specific.get_xosc_cfg;
  lr20xx_shield.lr20xx_shield_instance.get_dio_function = lr20xx_shield_specific.get_dio_function;
  lr20xx_shield.lr20xx_shield_instance.get_dio_irq_mask = lr20xx_shield_specific.get_dio_irq_mask;
  lr20xx_shield.lr20xx_shield_instance.get_reg_mode = lr20xx_shield_specific.get_reg_mode;
  lr20xx_shield.lr20xx_shield_instance.get_xosc_cfg = lr20xx_shield_specific.get_xosc_cfg;
  lr20xx_shield_specific.get_lfclk_cfg = lr20xx_shield_specific.get_lfclk_cfg;
  lr20xx_shield_specific.get_pinout = lr20xx_shield_specific.get_pinout;
  lr20xx_shield_specific.get_irq_dio = lr20xx_shield_specific.get_irq_dio;
  lr20xx_shield_specific.get_rttof_recommended_rx_tx_delay_indicator =
       lr20xx_shield_specific.get_rttof_recommended_rx_tx_delay_indicator;
  lr20xx_shield.lr20xx_shield_instance.get_lfclk_cfg = lr20xx_shield_specific.get_lfclk_cfg;
  lr20xx_shield.lr20xx_shield_instance.get_pinout = lr20xx_shield_specific.get_pinout;
  lr20xx_shield.lr20xx_shield_instance.get_irq_dio = lr20xx_shield_specific.get_irq_dio;
  lr20xx_shield.lr20xx_shield_instance.get_rttof_recommended_rx_tx_delay_indicator =
       lr20xx_shield_specific.get_rttof_recommended_rx_tx_delay_indicator;
  lr20xx_shield.base.vtable = &lr20xx_shield_get_instance::vtable;
  lr20xx_shield.regulator_mode = SHIELD_REG_MODE_SIMO_OFF;
  lr20xx_shield_specific.get_rf_switch_cfg = (smtc_shield_lr20xx_get_rf_switch_cfg_f)&lr20xx_shield;
  memcpy(__return_storage_ptr__,lr20xx_shield_specific.get_rf_switch_cfg,0x1c8);
  return __return_storage_ptr__;
}



lr20xx_status_t lr20xx_shield_check_chip_version(lr20xx_shield_t *shield)
{
  lr20xx_status_t lVar1;
  undefined4 uVar2;
  lr20xx_shield_t *shield_local;
  lr20xx_system_version_t version;
  lr20xx_status_t status;
  
  lVar1 = lr20xx_system_get_version(&shield->context,&version);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    if (lVar1 == LR20XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8033158,0x8038380,0xd1,0x8033144);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8033158,0x8038380,0xd1,(uint)lVar1);
  }
  if ((version.major == '\x01') && (version.minor == '\x18'))
  {
    lVar1 = LR20XX_STATUS_OK;
  }
  else
  {
    if (version.minor == '\r')
    {
      uVar2 = 0x41;
    }
    else if (version.minor == '\x10')
    {
      uVar2 = 0x42;
    }
    else if (version.minor == '\x18')
    {
      uVar2 = 0x45;
    }
    else
    {
      uVar2 = 0x3f;
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "Unsupported LR20XX chip version: v%d%c\r\n",(uint)version.major,uVar2);
    lVar1 = LR20XX_STATUS_ERROR;
  }
  return lVar1;
}



shield_status_t lr20xx_shield_system_init(shield_t *self)
{
  lr20xx_status_t lVar1;
  lr20xx_system_lfclk_cfg_t lfclock_cfg;
  byte bVar2;
  _Bool _Var3;
  lr20xx_system_dio_func_t func;
  lr20xx_system_dio_drive_t drive;
  smtc_shield_lr20xx_xosc_cfg_t *psVar4;
  lr20xx_system_dio_rf_switch_cfg_t *plVar5;
  shield_status_t sVar6;
  shield_t *self_local;
  lr20xx_system_dio_t dio;
  uint16_t errors;
  smtc_shield_lr20xx_t shield_instance;
  lr20xx_system_dio_rf_switch_cfg_t *rf_switch_cfg;
  lr20xx_system_dio_drive_t dio_drive;
  lr20xx_system_dio_func_t dio_function;
  uint8_t dio_count;
  lr20xx_status_t status_6;
  lr20xx_status_t status_5;
  lr20xx_status_t status_4;
  lr20xx_status_t status_3;
  smtc_shield_lr20xx_xosc_cfg_t *tcxo_cfg;
  lr20xx_status_t status_2;
  lr20xx_system_lfclk_cfg_t lfclk_cfg;
  lr20xx_status_t status_1;
  lr20xx_status_t status;
  lr20xx_shield_t *myself;
  uint8_t dio_nth;
  
  shield_instance.get_pa_pwr_cfg = (smtc_shield_lr20xx_get_pa_pwr_cfg_f)self[1].vtable;
  shield_instance.get_rssi_calibration_table =
       (smtc_shield_lr20xx_get_rssi_calibration_table_f)self[2].vtable;
  shield_instance.get_rf_switch_cfg = (smtc_shield_lr20xx_get_rf_switch_cfg_f)self[3].vtable;
  shield_instance.get_dio_sleep_drive = (smtc_shield_lr20xx_get_dio_sleep_drive_f)self[4].vtable;
  shield_instance.get_dio_function = (smtc_shield_lr20xx_get_dio_function_f)self[5].vtable;
  shield_instance.get_dio_irq_mask = (smtc_shield_lr20xx_get_dio_irq_mask_f)self[6].vtable;
  shield_instance.get_reg_mode = (smtc_shield_lr20xx_get_reg_mode_f)self[7].vtable;
  shield_instance.get_xosc_cfg = (smtc_shield_lr20xx_get_xosc_cfg_f)self[8].vtable;
  shield_instance.get_lfclk_cfg = (smtc_shield_lr20xx_get_lfclk_cfg_f)self[9].vtable;
  shield_instance.get_pinout = (smtc_shield_lr20xx_get_pinout_f)self[10].vtable;
  shield_instance.get_irq_dio = (smtc_shield_lr20xx_get_irq_dio_f)self[0xb].vtable;
  shield_instance.get_rttof_recommended_rx_tx_delay_indicator =
       (smtc_shield_lr20xx_rttof_recommended_rx_tx_delay_indicator_f)self[0xc].vtable;
  lVar1 = lr20xx_system_reset(self + 0xd);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    if (lVar1 == LR20XX_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xe6,0x8033144);
    }
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                        "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xe6,(uint)lVar1);
  }
  lVar1 = lr20xx_shield_check_chip_version((lr20xx_shield_t *)self);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_system_set_reg_mode(self + 0xd,*(lr20xx_system_reg_mode_t *)&self[0x71].vtable);
    if (lVar1 != LR20XX_STATUS_OK)
    {
      if (lVar1 == LR20XX_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xee,0x8033144);
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xee,(uint)lVar1);
    }
    lfclock_cfg = smtc_shield_lr20xx_get_lfclk_cfg(&shield_instance);
    lVar1 = lr20xx_system_cfg_lfclk(self + 0xd,lfclock_cfg);
    if (lVar1 != LR20XX_STATUS_OK)
    {
      if (lVar1 == LR20XX_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xf1,0x8033144);
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xf1,(uint)lVar1);
    }
    psVar4 = smtc_shield_lr20xx_get_xosc_cfg(&shield_instance);
    if ((psVar4->has_tcxo != false) &&
       (lVar1 = lr20xx_system_set_tcxo_mode(self + 0xd,psVar4->supply,psVar4->startup_time_in_tick),
       lVar1 != LR20XX_STATUS_OK))
    {
      if (lVar1 == LR20XX_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xf6,0x8033144);
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xf6,(uint)lVar1);
    }
    lVar1 = lr20xx_system_get_errors(self + 0xd,&errors);
    if (lVar1 != LR20XX_STATUS_OK)
    {
      if (lVar1 == LR20XX_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xfb,0x8033144);
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xfb,(uint)lVar1);
    }
    lVar1 = lr20xx_system_clear_errors(self + 0xd);
    if (lVar1 != LR20XX_STATUS_OK)
    {
      if (lVar1 == LR20XX_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xfc,0x8033144);
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xfc,(uint)lVar1);
    }
    lVar1 = lr20xx_system_clear_irq_status(self + 0xd,0xffff07ff);
    if (lVar1 != LR20XX_STATUS_OK)
    {
      if (lVar1 == LR20XX_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x8033158,0x80383a4,0xfd,0x8033144);
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x8033158,0x80383a4,0xfd,(uint)lVar1);
    }
    bVar2 = lr20xx_system_dio_get_count();
    for (dio_nth = '\0'; dio_nth < bVar2; dio_nth += '\x01')
    {
      _Var3 = lr20xx_system_dio_get_nth(dio_nth,&dio);
      if (!_Var3)
      {
        return SHIELD_STATUS_ERROR;
      }
      func = smtc_shield_lr20xx_get_dio_function(&shield_instance,dio);
      drive = smtc_shield_lr20xx_get_dio_sleep_drive(&shield_instance,dio);
      if (func == LR20XX_SYSTEM_DIO_FUNC_HF_CLK_OUT)
      {
        lr20xx_system_cfg_clk_output(self + 0xd,LR20XX_SYSTEM_HF_CLK_SCALING_31250_HZ);
      }
      lr20xx_system_set_dio_function(self + 0xd,dio,func,drive);
      if (func == LR20XX_SYSTEM_DIO_FUNC_RF_SWITCH)
      {
        plVar5 = smtc_shield_lr20xx_get_rf_switch_cfg(&shield_instance,dio);
        lr20xx_system_set_dio_rf_switch_cfg(self + 0xd,dio,*plVar5);
      }
    }
    sVar6 = SHIELD_STATUS_OK;
  }
  else
  {
    sVar6 = SHIELD_STATUS_ERROR;
  }
  return sVar6;
}



void lr20xx_shield_init(shield_t *self,_func_void_void_ptr *callback)
{
  smtc_shield_lr20xx_pinout_t *shield_pinout_00;
  shield_interface_t *psVar1;
  _func_void_void_ptr *callback_local;
  shield_t *self_local;
  smtc_shield_lr20xx_pinout_t *shield_pinout;
  lr20xx_shield_t *myself;
  
  shield_pinout_00 = smtc_shield_lr20xx_get_pinout((smtc_shield_lr20xx_t *)(self + 1));
  lr20xx_shield_init_context((lr20xx_hal_context_t *)(self + 0xd),shield_pinout_00,callback);
  self[0x2b].vtable = (shield_interface_t *)(self + 0xd);
  self[0x2c].vtable = (shield_interface_t *)0x802751d;
  self[0x2d].vtable = (shield_interface_t *)0x8027545;
  self[0x2e].vtable = (shield_interface_t *)0x8027575;
  self[0x2f].vtable = (shield_interface_t *)0x802755d;
  self[0x30].vtable = (shield_interface_t *)0x8027791;
  self[0x31].vtable = (shield_interface_t *)0x80277bd;
  self[0x32].vtable = (shield_interface_t *)0x80277fb;
  self[0x33].vtable = (shield_interface_t *)0x8027813;
  self[0x34].vtable = (shield_interface_t *)0x802782d;
  self[0x35].vtable = (shield_interface_t *)0x8027871;
  self[0x36].vtable = (shield_interface_t *)0x802788b;
  self[0x37].vtable = (shield_interface_t *)0x80278d7;
  self[0x38].vtable = (shield_interface_t *)0x80278f7;
  self[0x39].vtable = (shield_interface_t *)0x8027919;
  self[0x3a].vtable = (shield_interface_t *)0x8027931;
  self[0x3b].vtable = (shield_interface_t *)0x802794b;
  self[0x3c].vtable = (shield_interface_t *)0x8027969;
  self[0x3d].vtable = (shield_interface_t *)0x80279e9;
  self[0x3e].vtable = (shield_interface_t *)0x8027a65;
  self[0x3f].vtable = (shield_interface_t *)0x8027a89;
  self[0x40].vtable = (shield_interface_t *)0x8027aeb;
  self[0x41].vtable = (shield_interface_t *)0x8027b31;
  self[0x42].vtable = (shield_interface_t *)0x8027b55;
  self[0x43].vtable = (shield_interface_t *)0x8027b9f;
  self[0x44].vtable = (shield_interface_t *)0x8027c5f;
  self[0x45].vtable = (shield_interface_t *)0x8027ca1;
  self[0x46].vtable = (shield_interface_t *)0x8027cfd;
  self[0x47].vtable = (shield_interface_t *)0x8027d5b;
  self[0x48].vtable = (shield_interface_t *)0x8027da7;
  self[0x49].vtable = (shield_interface_t *)0x8027df3;
  self[0x4a].vtable = (shield_interface_t *)0x8027e19;
  self[0x4b].vtable = (shield_interface_t *)0x8027e59;
  self[0x4c].vtable = (shield_interface_t *)0x8027ea3;
  self[0x4d].vtable = (shield_interface_t *)0x8027ee3;
  self[0x4e].vtable = (shield_interface_t *)0x8027f05;
  self[0x4f].vtable = (shield_interface_t *)0x8027f1d;
  self[0x50].vtable = (shield_interface_t *)0x8027f35;
  self[0x51].vtable = (shield_interface_t *)0x8027f7d;
  self[0x52].vtable = (shield_interface_t *)0x8027fcd;
  self[0x53].vtable = (shield_interface_t *)0x8027fe5;
  self[0x54].vtable = (shield_interface_t *)0x8028003;
  self[0x55].vtable = (shield_interface_t *)0x802803f;
  self[0x56].vtable = (shield_interface_t *)0x802807d;
  self[0x57].vtable = (shield_interface_t *)0x8028095;
  self[0x58].vtable = (shield_interface_t *)0x8028115;
  self[0x59].vtable = (shield_interface_t *)0x8028135;
  self[0x5a].vtable = (shield_interface_t *)0x8028151;
  self[0x5b].vtable = (shield_interface_t *)0x8028171;
  self[0x5c].vtable = (shield_interface_t *)0x8028189;
  self[0x5d].vtable = (shield_interface_t *)0x80281ab;
  self[0x5e].vtable = (shield_interface_t *)0x80281c5;
  self[0x5f].vtable = (shield_interface_t *)0x802825d;
  self[0x60].vtable = (shield_interface_t *)0x8028277;
  self[0x61].vtable = (shield_interface_t *)0x802840d;
  self[0x62].vtable = (shield_interface_t *)0x802846b;
  self[99].vtable = (shield_interface_t *)0x8028447;
  self[100].vtable = (shield_interface_t *)0x802830b;
  self[0x65].vtable = (shield_interface_t *)0x8028355;
  self[0x66].vtable = (shield_interface_t *)0x80283a3;
  self[0x67].vtable = (shield_interface_t *)0x80283d3;
  self[0x68].vtable = (shield_interface_t *)0x8028291;
  self[0x69].vtable = (shield_interface_t *)0x80282df;
  self[0x6a].vtable = (shield_interface_t *)0x80282f5;
  self[0x6b].vtable = (shield_interface_t *)0x802849d;
  self[0x6c].vtable = (shield_interface_t *)0x8028c0d;
  self[0x6d].vtable = (shield_interface_t *)0x8028c3b;
  self[0x6e].vtable = (shield_interface_t *)0x8028c5f;
  self[0x6f].vtable = (shield_interface_t *)0x8028c7b;
  self[0x70].vtable = (shield_interface_t *)0x8028c97;
  if (shield_pinout_00->led_tx != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar1 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout_00->led_tx)
    ;
    self[0x22].vtable = psVar1;
    *(undefined1 *)&self[0x23].vtable = 0;
    *(undefined1 *)((int)&self[0x23].vtable + 1) = 2;
    smtc_hal_mcu_gpio_init_output
              ((smtc_hal_mcu_gpio_cfg_t)self[0x22].vtable,
               (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x23),
               (smtc_hal_mcu_gpio_inst_t *)(self + 0x24));
  }
  if (shield_pinout_00->led_rx != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar1 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout_00->led_rx)
    ;
    self[0x25].vtable = psVar1;
    *(undefined1 *)&self[0x26].vtable = 0;
    *(undefined1 *)((int)&self[0x26].vtable + 1) = 2;
    smtc_hal_mcu_gpio_init_output
              ((smtc_hal_mcu_gpio_cfg_t)self[0x25].vtable,
               (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x26),
               (smtc_hal_mcu_gpio_inst_t *)(self + 0x27));
  }
  if (shield_pinout_00->lna != SMTC_SHIELD_PINOUT_NONE)
  {
    psVar1 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout_00->lna);
    self[0x28].vtable = psVar1;
    *(undefined1 *)&self[0x29].vtable = 0;
    *(undefined1 *)((int)&self[0x29].vtable + 1) = 2;
    smtc_hal_mcu_gpio_init_output
              ((smtc_hal_mcu_gpio_cfg_t)self[0x28].vtable,
               (smtc_hal_mcu_gpio_output_cfg_t *)(self + 0x29),
               (smtc_hal_mcu_gpio_inst_t *)(self + 0x2a));
  }
  board_init_leds((smtc_hal_mcu_gpio_inst_t *)(self + 0x27),
                  (smtc_hal_mcu_gpio_inst_t *)(self + 0x24));
  return;
}



void lr20xx_shield_deinit(shield_t *self)
{
  smtc_shield_lr20xx_pinout_t *psVar1;
  shield_t *self_local;
  smtc_shield_lr20xx_pinout_t *shield_pinout;
  lr20xx_shield_t *myself;
  
  psVar1 = smtc_shield_lr20xx_get_pinout((smtc_shield_lr20xx_t *)(self + 1));
  lr20xx_shield_deinit_context((lr20xx_hal_context_t *)(self + 0xd));
  if ((psVar1->led_tx != SMTC_SHIELD_PINOUT_NONE) &&
     (self[0x24].vtable != (shield_interface_t *)0x0))
  {
    smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x24));
  }
  if ((psVar1->led_rx != SMTC_SHIELD_PINOUT_NONE) &&
     (self[0x27].vtable != (shield_interface_t *)0x0))
  {
    smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x27));
  }
  if ((psVar1->lna != SMTC_SHIELD_PINOUT_NONE) && (self[0x2a].vtable != (shield_interface_t *)0x0))
  {
    smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 0x2a));
  }
  return;
}



void lr20xx_shield_init_context
               (lr20xx_hal_context_t *context,smtc_shield_lr20xx_pinout_t *shield_pinout,
               _func_void_void_ptr *callback)
{
  smtc_hal_mcu_gpio_cfg_t psVar1;
  _func_void_void_ptr *callback_local;
  smtc_shield_lr20xx_pinout_t *shield_pinout_local;
  lr20xx_hal_context_t *context_local;
  
  psVar1 = smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout->busy);
  (context->busy).cfg = psVar1;
  (context->busy).cfg_input.pull_mode = SMTC_HAL_MCU_GPIO_PULL_MODE_NONE;
  (context->busy).cfg_input.irq_mode = SMTC_HAL_MCU_GPIO_IRQ_MODE_OFF;
  (context->busy).cfg_input.callback = (_func_void_void_ptr *)0x0;
  psVar1 = smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout->irq);
  (context->irq).cfg = psVar1;
  (context->irq).cfg_input.pull_mode = SMTC_HAL_MCU_GPIO_PULL_MODE_NONE;
  (context->irq).cfg_input.irq_mode = SMTC_HAL_MCU_GPIO_IRQ_MODE_RISING;
  (context->irq).cfg_input.callback = callback;
  (context->irq).cfg_input.context = (void *)0x0;
  psVar1 = smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout->nss);
  (context->nss).cfg = psVar1;
  (context->nss).cfg_output.initial_state = SMTC_HAL_MCU_GPIO_STATE_HIGH;
  (context->nss).cfg_output.mode = SMTC_HAL_MCU_GPIO_OUTPUT_MODE_PUSH_PULL;
  psVar1 = smtc_shield_pinout_mapping_get_gpio_cfg(shield_pinout->reset);
  (context->reset).cfg = psVar1;
  (context->reset).cfg_output.initial_state = SMTC_HAL_MCU_GPIO_STATE_HIGH;
  (context->reset).cfg_output.mode = SMTC_HAL_MCU_GPIO_OUTPUT_MODE_PUSH_PULL;
  smtc_hal_mcu_gpio_init_input((context->busy).cfg,&(context->busy).cfg_input,&(context->busy).inst)
  ;
  smtc_hal_mcu_gpio_init_input((context->irq).cfg,&(context->irq).cfg_input,&(context->irq).inst);
  smtc_hal_mcu_gpio_init_output((context->nss).cfg,&(context->nss).cfg_output,&(context->nss).inst);
  smtc_hal_mcu_gpio_init_output
            ((context->reset).cfg,&(context->reset).cfg_output,&(context->reset).inst);
  smtc_hal_mcu_gpio_enable_irq((context->irq).inst);
  support_spi_init(&(context->spi).inst,shield_pinout);
  return;
}



void lr20xx_shield_deinit_context(lr20xx_hal_context_t *context)
{
  lr20xx_hal_context_t *context_local;
  
  smtc_hal_mcu_spi_deinit(&(context->spi).inst);
  smtc_hal_mcu_gpio_disable_irq((context->irq).inst);
  smtc_hal_mcu_gpio_deinit(&(context->busy).inst);
  smtc_hal_mcu_gpio_deinit(&(context->irq).inst);
  smtc_hal_mcu_gpio_deinit(&(context->nss).inst);
  smtc_hal_mcu_gpio_deinit(&(context->reset).inst);
  return;
}



void lr20xx_shield_init_identification(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  self[0x21].vtable = (shield_interface_t *)0x0;
  *(undefined2 *)&self[0x1f].vtable = 0xffff;
  self[0x20].vtable = (shield_interface_t *)0x0;
  return;
}



ral_t * lr20xx_shield_get_ral_instance(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  return (ral_t *)(self + 0x2b);
}



void lr20xx_shield_handle_pre_rx(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  board_pre_rx_led_trigger((smtc_hal_mcu_gpio_inst_t)self[0x27].vtable);
  return;
}



void lr20xx_shield_handle_post_rx(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  board_post_rx_led_trigger((smtc_hal_mcu_gpio_inst_t)self[0x27].vtable);
  return;
}



void lr20xx_shield_handle_pre_tx(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  board_pre_tx_led_trigger((smtc_hal_mcu_gpio_inst_t)self[0x24].vtable);
  return;
}



void lr20xx_shield_handle_post_tx(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  board_post_tx_led_trigger((smtc_hal_mcu_gpio_inst_t)self[0x24].vtable);
  return;
}



shield_status_t lr20xx_shield_set_chip_patch(shield_t *self)
{
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  lr20xx_system_clear_errors(self + 0xd);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_flrc_syncword
          (shield_t *self,uint8_t *syncword,uint8_t syncword_index,uint8_t syncword_len)
{
  lr20xx_status_t lVar1;
  uint8_t syncword_len_local;
  uint8_t syncword_index_local;
  uint8_t *syncword_local;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  lVar1 = lr20xx_radio_flrc_set_syncword(self + 0xd,syncword_index,syncword);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, could not set FLRC sync word at index %u",
                        (uint)syncword_index);
  }
  return lVar1 != LR20XX_STATUS_OK;
}



shield_status_t lr20xx_shield_set_ook_detection_level(shield_t *shield,int16_t threshold_level_db)
{
  int16_t threshold_level_db_local;
  shield_t *shield_local;
  lr20xx_shield_t *myself;
  
  lr20xx_workarounds_ook_set_detection_threshold_level(shield + 0xd,threshold_level_db);
  return SHIELD_STATUS_OK;
}



shield_status_t lr20xx_shield_configure_and_get_inst_rssi(shield_t *self,int16_t *inst_rssi)
{
  uint uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  int16_t *inst_rssi_local;
  shield_t *self_local;
  uint8_t half_dbm_count;
  int16_t rssi_in_dbm;
  lr20xx_radio_common_rx_path_boost_mode_t boost_mode;
  lr20xx_radio_common_rx_path_t rx_path;
  radio_parameters_t *radio_parameters;
  lr20xx_shield_t *myself;
  
  myself = (lr20xx_shield_t *)self;
  radio_parameters = common_radio_get_parameters();
  rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
  boost_mode = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_NONE;
  lr20xx_system_set_standby_mode(&myself->context,LR20XX_SYSTEM_STANDBY_MODE_XOSC);
  lr20xx_radio_common_set_pkt_type(&myself->context,LR20XX_RADIO_COMMON_PKT_TYPE_FSK);
  lr20xx_radio_common_set_rf_freq(&myself->context,(radio_parameters->rf_freq_in_hz).val);
  ral_lr20xx_bsp_get_rx_cfg
            (&myself->context,(radio_parameters->rf_freq_in_hz).val,&rx_path,&boost_mode);
  lr20xx_radio_common_set_rx_path(&myself->context,rx_path,boost_mode);
  lr20xx_shield_configure_and_get_inst_rssi::fsk_mod_params.br =
       (radio_parameters->ook_parameters).ook_bitrate.val;
  lr20xx_shield_configure_and_get_inst_rssi::fsk_mod_params.fdev_in_hz =
       (radio_parameters->rf_freq_in_hz).val;
  lr20xx_shield_configure_and_get_inst_rssi::fsk_mod_params.pulse_shape =
       LR20XX_RADIO_FSK_PULSE_SHAPE_DISABLED;
  lr20xx_shield_configure_and_get_inst_rssi::fsk_mod_params.bw =
       (lr20xx_radio_fsk_common_bw_t)(radio_parameters->ook_parameters).ook_bandwidth.val;
  lr20xx_radio_fsk_set_modulation_params
            (&myself->context,&lr20xx_shield_configure_and_get_inst_rssi::fsk_mod_params);
  lr20xx_radio_fsk_set_packet_params
            (&myself->context,&lr20xx_shield_configure_and_get_inst_rssi::fsk_pkt_params);
  lr20xx_radio_common_set_rx(&myself->context,0);
  smtc_hal_mcu_wait_ms(1);
  rssi_in_dbm = 0;
  half_dbm_count = '\0';
  lr20xx_radio_common_get_rssi_inst(&myself->context,&rssi_in_dbm,&half_dbm_count);
  uVar2 = __aeabi_i2d((int)rssi_in_dbm);
  uVar3 = __aeabi_i2d((uint)half_dbm_count);
  uVar3 = __muldf3((uint)uVar3,(uint)(uVar3 >> 0x20),0,0x3fe00000);
  uVar2 = __subdf3((uint)uVar2,(uint)(uVar2 >> 0x20),(uint)uVar3,(uint)(uVar3 >> 0x20));
  uVar1 = __aeabi_d2iz((uint)uVar2,(uint)(uVar2 >> 0x20));
  *inst_rssi = (int16_t)uVar1;
  lr20xx_system_set_standby_mode(&myself->context,LR20XX_SYSTEM_STANDBY_MODE_RC);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_flrc_pkt_params(shield_t *self,shield_flrc_pkt_params_t *flrc_pkt_params)
{
  lr20xx_status_t lVar1;
  shield_flrc_pkt_params_t *flrc_pkt_params_local;
  shield_t *self_local;
  lr20xx_radio_flrc_pkt_params_t lr20xx_flrc_pkt_params;
  lr20xx_shield_t *myself;
  
  lr20xx_flrc_pkt_params.preamble_len = flrc_pkt_params->preamble_len;
  lr20xx_flrc_pkt_params.sync_word_len = flrc_pkt_params->sync_word_len_bytes;
  lr20xx_flrc_pkt_params.tx_syncword = flrc_pkt_params->tx_sync_word;
  lr20xx_flrc_pkt_params.match_sync_word = flrc_pkt_params->match_sync_word;
  lr20xx_flrc_pkt_params.header_type = flrc_pkt_params->header_type;
  lr20xx_flrc_pkt_params.pld_len_in_bytes = flrc_pkt_params->pld_len_in_bytes;
  lr20xx_flrc_pkt_params.crc_type = flrc_pkt_params->crc_type;
  lVar1 = lr20xx_radio_flrc_set_pkt_params(self + 0xd,&lr20xx_flrc_pkt_params);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, could not set FLRC packet params");
  }
  return lVar1 != LR20XX_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_flrc_mod_params(shield_t *self,shield_flrc_mod_params_t *flrc_mod_params)
{
  lr20xx_status_t lVar1;
  shield_flrc_mod_params_t *flrc_mod_params_local;
  shield_t *self_local;
  lr20xx_radio_flrc_mod_params_t lr20xx_flrc_mod_params;
  lr20xx_shield_t *myself;
  
  lr20xx_flrc_mod_params.br_bw = flrc_mod_params->br_bw;
  lr20xx_flrc_mod_params.cr = flrc_mod_params->cr;
  lr20xx_flrc_mod_params.shape = flrc_mod_params->shape;
  lVar1 = lr20xx_radio_flrc_set_modulation_params(self + 0xd,&lr20xx_flrc_mod_params);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, could not set FLRC mod params");
  }
  return lVar1 != LR20XX_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_ook_pkt_params
          (shield_t *self,shield_ook_pkt_params_t *ook_pkt_params,_Bool apply_workaround)
{
  _Bool apply_workaround_local;
  shield_ook_pkt_params_t *ook_pkt_params_local;
  shield_t *self_local;
  lr20xx_radio_ook_pkt_params_t *lr20xx_ook_pkt_params;
  lr20xx_shield_t *myself;
  
  lr20xx_radio_ook_set_packet_params(self + 0xd,(lr20xx_radio_ook_pkt_params_t *)ook_pkt_params);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_ook_mod_params(shield_t *self,shield_ook_mod_params_t *ook_mod_params)
{
  lr20xx_status_t lVar1;
  shield_ook_mod_params_t *ook_mod_params_local;
  shield_t *self_local;
  ral_status_t status;
  lr20xx_radio_ook_mod_params_t *lr20xx_ook_mod_params;
  lr20xx_shield_t *myself;
  
  lVar1 = lr20xx_radio_fsk_get_rx_bandwidth(ook_mod_params->bw,&ook_mod_params->field_0x6);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lr20xx_radio_ook_set_modulation_params
              (self + 0xd,(lr20xx_radio_ook_mod_params_t *)ook_mod_params);
  }
  return lVar1 != LR20XX_STATUS_OK;
}



shield_status_t lr20xx_shield_set_ook_crc_params(shield_t *self,uint32_t polynomial,uint32_t seed)
{
  uint32_t seed_local;
  uint32_t polynomial_local;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  lr20xx_radio_ook_set_crc_params(self + 0xd,polynomial,seed);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_ook_set_syncword
          (shield_t *self,uint8_t *syncword,uint8_t sync_len,uint8_t sync_len_bits,
          shield_ook_syncword_bit_order_t bit_order)
{
  uint8_t sync_len_bits_local;
  uint8_t sync_len_local;
  uint8_t *syncword_local;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  lr20xx_radio_ook_set_syncword(self + 0xd,syncword,sync_len_bits,bit_order);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_ook_set_addresses(shield_t *self,uint32_t node_address,uint32_t broadcast_address)
{
  uint32_t broadcast_address_local;
  uint32_t node_address_local;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  lr20xx_radio_ook_set_addresses(self + 0xd,(uint8_t)node_address,(uint8_t)broadcast_address);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_ook_set_whitening_params
          (shield_t *self,shield_ook_whitening_params_t *whitening_params)
{
  shield_ook_whitening_params_t *whitening_params_local;
  shield_t *self_local;
  lr20xx_radio_ook_whitening_params_t *lr20xx_ook_whitening_params;
  lr20xx_shield_t *myself;
  
  lr20xx_radio_ook_set_whitening_params
            (self + 0xd,(lr20xx_radio_ook_whitening_params_t *)whitening_params);
  return SHIELD_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_ook_rx_detector(shield_t *self,shield_ook_rx_detector_t *rx_detector_params)
{
  shield_ook_rx_detector_t *rx_detector_params_local;
  shield_t *self_local;
  lr20xx_radio_ook_rx_detector_t *lr20xx_rx_detector_params;
  lr20xx_shield_t *myself;
  
  lr20xx_radio_ook_set_rx_detector(self + 0xd,(lr20xx_radio_ook_rx_detector_t *)rx_detector_params);
  return SHIELD_STATUS_OK;
}



lr20xx_radio_common_pkt_type_t
shield_pkt_type_to_lr20xx_pkt_type(shield_packet_type_t shield_pkt_type)
{
  lr20xx_radio_common_pkt_type_t lVar1;
  shield_packet_type_t shield_pkt_type_local;
  
  switch(shield_pkt_type)
  {
  case SHIELD_PKT_TYPE_GFSK:
    lVar1 = LR20XX_RADIO_COMMON_PKT_TYPE_FSK;
    break;
  case SHIELD_PKT_TYPE_LORA:
    lVar1 = LR20XX_RADIO_COMMON_PKT_TYPE_LORA;
    break;
  case SHIELD_PKT_TYPE_FLRC:
    lVar1 = LR20XX_RADIO_COMMON_PKT_TYPE_FLRC;
    break;
  case SHIELD_PKT_TYPE_OOK:
    lVar1 = LR20XX_RADIO_COMMON_PKT_TYPE_OOK;
    break;
  default:
    lVar1 = ~LR20XX_RADIO_COMMON_PKT_TYPE_LORA;
  }
  return lVar1;
}



void lr20xx_shield_identify(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_interface_t *psVar2;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_5;
  smtc_hal_mcu_status_t status_4;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  uint32_t now_ms;
  lr20xx_shield_t *myself;
  
  psVar2 = (shield_interface_t *)support_timing_get_time();
  if ((((self[0x27].vtable == (shield_interface_t *)0x0) ||
       (self[0x24].vtable == (shield_interface_t *)0x0)) &&
      (lr20xx_shield_init(self,(_func_void_void_ptr *)0x0),
      self[0x27].vtable == (shield_interface_t *)0x0)) &&
     (self[0x24].vtable == (shield_interface_t *)0x0))
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"Selected Shield has no LED, identify cannot work properly");
  }
  else
  {
    if (self[0x21].vtable == (shield_interface_t *)0x0)
    {
      self[0x20].vtable = psVar2;
      *(undefined2 *)&self[0x1f].vtable = 10;
      sVar1 = smtc_hal_mcu_gpio_get_state
                        ((smtc_hal_mcu_gpio_inst_t)self[0x27].vtable,
                         &lr20xx_shield_identify::previous_rx_led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8033158,0x80383c0,0x29e,0x8033290);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8033158,0x80383c0,0x29e,(uint)sVar1);
        }
      }
      sVar1 = smtc_hal_mcu_gpio_get_state
                        ((smtc_hal_mcu_gpio_inst_t)self[0x24].vtable,
                         &lr20xx_shield_identify::previous_tx_led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8033158,0x80383c0,0x29f,0x8033290);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8033158,0x80383c0,0x29f,(uint)sVar1);
        }
      }
    }
    if (((psVar2 < &self[0x21].vtable[1].shield_set_ook_set_addresses) &&
        (self[0x21].vtable != (shield_interface_t *)0x0)) || (*(short *)&self[0x1f].vtable < 0))
    {
      if (*(short *)&self[0x1f].vtable < 0)
      {
        self[0x21].vtable = (shield_interface_t *)0x0;
        sVar1 = smtc_hal_mcu_gpio_set_state
                          ((smtc_hal_mcu_gpio_inst_t)self[0x24].vtable,
                           lr20xx_shield_identify::previous_tx_led_state);
        if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
        {
          if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                                "In %s - %s (line %d): %s",0x8033158,0x80383c0,0x2b4,0x8033290);
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true
                                ,"In %s - %s (line %d): %d",0x8033158,0x80383c0,0x2b4,(uint)sVar1);
          }
        }
        sVar1 = smtc_hal_mcu_gpio_set_state
                          ((smtc_hal_mcu_gpio_inst_t)self[0x27].vtable,
                           lr20xx_shield_identify::previous_rx_led_state);
        if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
        {
          if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                                "In %s - %s (line %d): %s",0x8033158,0x80383c0,0x2b5,0x8033290);
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true
                                ,"In %s - %s (line %d): %d",0x8033158,0x80383c0,0x2b5,(uint)sVar1);
          }
        }
      }
    }
    else
    {
      sVar1 = smtc_hal_mcu_gpio_set_state
                        ((smtc_hal_mcu_gpio_inst_t)self[0x24].vtable,
                         lr20xx_shield_identify::led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8033158,0x80383c0,0x2a6,0x8033290);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8033158,0x80383c0,0x2a6,(uint)sVar1);
        }
      }
      sVar1 = smtc_hal_mcu_gpio_set_state
                        ((smtc_hal_mcu_gpio_inst_t)self[0x27].vtable,
                         lr20xx_shield_identify::led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8033158,0x80383c0,0x2a7,0x8033290);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8033158,0x80383c0,0x2a7,(uint)sVar1);
        }
      }
      lr20xx_shield_identify::led_state ^= SMTC_HAL_MCU_GPIO_STATE_HIGH;
      *(short *)&self[0x1f].vtable = *(short *)&self[0x1f].vtable + -1;
      self[0x21].vtable = psVar2;
    }
  }
  return;
}



_Bool lr20xx_is_identification_running(shield_t *self)
{
  undefined1 uVar1;
  shield_interface_t *psVar2;
  bool bVar3;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  psVar2 = self[0x21].vtable;
  bVar3 = psVar2 != (shield_interface_t *)0x0;
  if (bVar3)
  {
    psVar2 = (shield_interface_t *)0x1;
  }
  uVar1 = SUB41(psVar2,0);
  if (!bVar3)
  {
    uVar1 = 0;
  }
  return (_Bool)uVar1;
}



shield_status_t
lr20xx_shield_set_pkt_type(shield_t *self,ral_t *radio,shield_packet_type_t packet_type)
{
  ral_status_t rVar1;
  lr20xx_radio_common_pkt_type_t pkt_type_00;
  shield_status_t sVar2;
  shield_packet_type_t packet_type_local;
  ral_t *radio_local;
  shield_t *self_local;
  ral_status_t status;
  lr20xx_shield_t *myself;
  lr20xx_radio_common_pkt_type_t pkt_type;
  
  if (packet_type < SHIELD_PKT_TYPE_SUPPORTED_NUM)
  {
    if (packet_type < SHIELD_PKT_TYPE_OOK)
    {
      rVar1 = ral_set_pkt_type(radio,packet_type);
      if (rVar1 != RAL_STATUS_OK)
      {
        if (rVar1 == RAL_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x8033158,0x80383d8,0x2ce,0x80332d4);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x8033158,0x80383d8,0x2ce,(uint)rVar1);
        }
      }
      sVar2 = SHIELD_STATUS_OK;
    }
    else
    {
      pkt_type_00 = shield_pkt_type_to_lr20xx_pkt_type(packet_type);
      lr20xx_radio_common_set_pkt_type(self + 0xd,pkt_type_00);
      sVar2 = SHIELD_STATUS_OK;
    }
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, unsupported packet type");
    sVar2 = SHIELD_STATUS_ERROR;
  }
  return sVar2;
}



void lr20xx_shield_runtime(shield_t *self)
{
  _Bool _Var1;
  uint32_t uVar2;
  shield_t *self_local;
  uint32_t now_ms;
  lr20xx_shield_t *myself;
  
  _Var1 = lr20xx_is_identification_running(self);
  if (_Var1)
  {
    uVar2 = support_timing_get_time();
    if (uVar2 - (int)self[0x20].vtable < 0x2711)
    {
      lr20xx_shield_identify(self);
    }
    else
    {
      lr20xx_shield_init_identification(self);
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          true,"Maximum identification duration time reached");
    }
  }
  return;
}



shield_status_t
lr20xx_shield_set_tx_cfg(shield_t *self,int32_t output_power_in_half_dbm,uint32_t frequency)
{
  lr20xx_status_t lVar1;
  smtc_shield_lr20xx_pa_pwr_cfg_t *psVar2;
  shield_status_t sVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint32_t frequency_local;
  int32_t output_power_in_half_dbm_local;
  shield_t *self_local;
  lr20xx_radio_common_front_end_calibration_value_t calibration;
  lr20xx_radio_common_rx_path_t rx_path;
  smtc_shield_lr20xx_pa_pwr_cfg_t *pa_cfg;
  lr20xx_shield_t *myself;
  lr20xx_status_t status;
  int8_t tx_pwr_params_cfg;
  
  psVar2 = smtc_shield_lr20xx_get_pa_pwr_cfg
                     ((smtc_shield_lr20xx_t *)(self + 1),frequency,(int8_t)output_power_in_half_dbm)
  ;
  if (psVar2 == (smtc_shield_lr20xx_pa_pwr_cfg_t *)0x0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, could not get PA config");
    sVar3 = SHIELD_STATUS_ERROR;
  }
  else
  {
    calibration.rx_path = (psVar2->pa_config).pa_sel == LR20XX_RADIO_COMMON_PA_SEL_HF;
    calibration.frequency_in_hertz = frequency;
    lVar1 = lr20xx_radio_common_calibrate_front_end_helper(self + 0xd,&calibration,'\x01');
    if (lVar1 == LR20XX_STATUS_OK)
    {
      lVar1 = lr20xx_radio_common_set_pa_cfg(self + 0xd,&psVar2->pa_config);
      iVar4 = (int)psVar2->power;
      uVar5 = (uint)(psVar2->pa_config).pa_lf_slices;
      uVar6 = (uint)(psVar2->pa_config).pa_lf_duty_cycle;
      uVar7 = (uint)(psVar2->pa_config).pa_hf_duty_cycle;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Tx power : %d, pa_slices = %d, pa_duty_cycle= %d, hf_duty_cyle = %d",
                          iVar4,uVar5,uVar6,uVar7);
      if (lVar1 == LR20XX_STATUS_OK)
      {
        tx_pwr_params_cfg = psVar2->power;
        if (tx_pwr_params_cfg == '\0')
        {
          tx_pwr_params_cfg = ',';
        }
        lVar1 = lr20xx_radio_common_set_tx_params
                          (self + 0xd,tx_pwr_params_cfg,LR20XX_RADIO_COMMON_RAMP_48_US);
        if (lVar1 == LR20XX_STATUS_OK)
        {
          sVar3 = SHIELD_STATUS_OK;
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              true,"Shield Error, could not set Tx params",iVar4,uVar5,uVar6,uVar7);
          sVar3 = SHIELD_STATUS_ERROR;
        }
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            true,"Shield Error, could not set PA config",iVar4,uVar5,uVar6,uVar7);
        sVar3 = SHIELD_STATUS_ERROR;
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                          ,"Shield Error, could not calibrate front end");
      sVar3 = SHIELD_STATUS_ERROR;
    }
  }
  return sVar3;
}



shield_status_t lr20xx_shield_set_sleep(shield_t *self,_Bool retain_data,_Bool retain_rtc)
{
  lr20xx_status_t lVar1;
  _Bool retain_rtc_local;
  _Bool retain_data_local;
  shield_t *self_local;
  lr20xx_system_sleep_cfg_t radio_sleep_cfg;
  lr20xx_shield_t *myself;
  lr20xx_status_t status;
  
  radio_sleep_cfg.is_clk_32k_enabled = retain_rtc;
  radio_sleep_cfg.is_ram_retention_enabled = retain_data;
  lVar1 = lr20xx_system_set_sleep_mode(self + 0xd,&radio_sleep_cfg,0);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, could not set Sleep mode");
  }
  return lVar1 != LR20XX_STATUS_OK;
}



shield_status_t
lr20xx_shield_set_rx_boost_mode(shield_t *shield,_Bool boost_mode_enable,uint32_t frequency)
{
  lr20xx_status_t lVar1;
  uint32_t frequency_local;
  _Bool boost_mode_enable_local;
  shield_t *shield_local;
  lr20xx_shield_t *myself;
  lr20xx_status_t status;
  lr20xx_radio_common_rx_path_boost_mode_t boost_mode;
  lr20xx_radio_common_rx_path_t rx_path;
  
  if (boost_mode_enable)
  {
    boost_mode = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_7;
  }
  else
  {
    boost_mode = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_NONE;
  }
  lVar1 = lr20xx_radio_common_set_rx_path(shield + 0xd,1899999999 < frequency,boost_mode);
  if (lVar1 != LR20XX_STATUS_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, could not set rx path");
  }
  return lVar1 != LR20XX_STATUS_OK;
}



shield_status_t lr20xx_shield_lr20xx_get_reg_mode(shield_t *self,shield_reg_mode_t *regulator_mode)
{
  shield_reg_mode_t *regulator_mode_local;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  if (regulator_mode != (shield_reg_mode_t *)0x0)
  {
    *regulator_mode = *(shield_reg_mode_t *)&self[0x71].vtable;
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Shield Error, NULL pointer");
  }
  return regulator_mode == (shield_reg_mode_t *)0x0;
}



shield_status_t lr20xx_shield_lr20xx_set_reg_mode(shield_t *self,shield_reg_mode_t regulator_mode)
{
  shield_reg_mode_t regulator_mode_local;
  shield_t *self_local;
  lr20xx_shield_t *myself;
  
  *(shield_reg_mode_t *)&self[0x71].vtable = regulator_mode;
  return SHIELD_STATUS_OK;
}



// WARNING: Unknown calling convention

radioless_shield_t * radioless_shield_get_instance(void)
{
  radioless_shield_t *in_r0;
  radioless_shield_t radioless_shield;
  
  memset(&radioless_shield,0,0x28);
  (in_r0->base).vtable = &radioless_shield_get_instance::vtable;
  (in_r0->identify).nb_iterations = radioless_shield.identify.nb_iterations;
  *(undefined2 *)&(in_r0->identify).field_0x2 = radioless_shield.identify._2_2_;
  (in_r0->identify).start_of_id_process = radioless_shield.identify.start_of_id_process;
  (in_r0->identify).last_trig_ms = radioless_shield.identify.last_trig_ms;
  (in_r0->led_tx).cfg = radioless_shield.led_tx.cfg;
  (in_r0->led_tx).cfg_output = radioless_shield.led_tx.cfg_output;
  *(undefined2 *)&(in_r0->led_tx).field_0x6 = radioless_shield.led_tx._6_2_;
  (in_r0->led_tx).inst = radioless_shield.led_tx.inst;
  (in_r0->led_rx).cfg = radioless_shield.led_rx.cfg;
  (in_r0->led_rx).cfg_output = radioless_shield.led_rx.cfg_output;
  *(undefined2 *)&(in_r0->led_rx).field_0x6 = radioless_shield.led_rx._6_2_;
  (in_r0->led_rx).inst = radioless_shield.led_rx.inst;
  return in_r0;
}



shield_status_t radioless_shield_system_init(shield_t *self)
{
  shield_t *self_local;
  
  return SHIELD_STATUS_OK;
}



// WARNING: Variable defined which should be unmapped: callback_local

void radioless_shield_init(shield_t *self,_func_void_void_ptr *callback)
{
  smtc_hal_mcu_status_t sVar1;
  shield_interface_t *psVar2;
  _func_void_void_ptr *callback_local;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  radioless_shield_t *myself;
  
  if (true)
  {
    psVar2 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(SMTC_SHIELD_PINOUT_A4);
    self[4].vtable = psVar2;
    *(undefined1 *)&self[5].vtable = 0;
    *(undefined1 *)((int)&self[5].vtable + 1) = 2;
    sVar1 = smtc_hal_mcu_gpio_init_output
                      ((smtc_hal_mcu_gpio_cfg_t)self[4].vtable,
                       (smtc_hal_mcu_gpio_output_cfg_t *)(self + 5),
                       (smtc_hal_mcu_gpio_inst_t *)(self + 6));
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80334a0,0x8038468,0x94,0x8033484,callback);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80334a0,0x8038468,0x94,(uint)sVar1,callback
                           );
      }
    }
  }
  if (true)
  {
    psVar2 = (shield_interface_t *)smtc_shield_pinout_mapping_get_gpio_cfg(SMTC_SHIELD_PINOUT_A5);
    self[7].vtable = psVar2;
    *(undefined1 *)&self[8].vtable = 0;
    *(undefined1 *)((int)&self[8].vtable + 1) = 2;
    sVar1 = smtc_hal_mcu_gpio_init_output
                      ((smtc_hal_mcu_gpio_cfg_t)self[7].vtable,
                       (smtc_hal_mcu_gpio_output_cfg_t *)(self + 8),
                       (smtc_hal_mcu_gpio_inst_t *)(self + 9));
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80334a0,0x8038468,0x9e,0x8033484,callback);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80334a0,0x8038468,0x9e,(uint)sVar1,callback
                           );
      }
    }
  }
  return;
}



void radioless_shield_deinit(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  radioless_shield_t *myself;
  
  if (((true) && (self[6].vtable != (shield_interface_t *)0x0)) &&
     (sVar1 = smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 6)),
     sVar1 != SMTC_HAL_MCU_STATUS_OK))
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80334a0,0x8038480,0xa8,0x8033484);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80334a0,0x8038480,0xa8,(uint)sVar1);
    }
  }
  if (((true) && (self[9].vtable != (shield_interface_t *)0x0)) &&
     (sVar1 = smtc_hal_mcu_gpio_deinit((smtc_hal_mcu_gpio_inst_t *)(self + 9)),
     sVar1 != SMTC_HAL_MCU_STATUS_OK))
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80334a0,0x8038480,0xac,0x8033484);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80334a0,0x8038480,0xac,(uint)sVar1);
    }
  }
  return;
}



void radioless_shield_identify(shield_t *self)
{
  smtc_hal_mcu_status_t sVar1;
  shield_interface_t *psVar2;
  shield_t *self_local;
  smtc_hal_mcu_status_t status_5;
  smtc_hal_mcu_status_t status_4;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  uint32_t now_ms;
  radioless_shield_t *myself;
  
  psVar2 = (shield_interface_t *)support_timing_get_time();
  if ((self[9].vtable == (shield_interface_t *)0x0) || (self[6].vtable == (shield_interface_t *)0x0)
     )
  {
    radioless_shield_init(self,(_func_void_void_ptr *)0x0);
  }
  if (self[3].vtable == (shield_interface_t *)0x0)
  {
    self[2].vtable = psVar2;
    *(undefined2 *)&self[1].vtable = 10;
    sVar1 = smtc_hal_mcu_gpio_get_state
                      ((smtc_hal_mcu_gpio_inst_t)self[9].vtable,
                       &radioless_shield_identify::previous_rx_led_state);
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80334a0,0x8038498,0xc4,0x8033484);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80334a0,0x8038498,0xc4,(uint)sVar1);
      }
    }
    sVar1 = smtc_hal_mcu_gpio_get_state
                      ((smtc_hal_mcu_gpio_inst_t)self[6].vtable,
                       &radioless_shield_identify::previous_tx_led_state);
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80334a0,0x8038498,0xc5,0x8033484);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80334a0,0x8038498,0xc5,(uint)sVar1);
      }
    }
  }
  if (((psVar2 < &self[3].vtable[1].shield_set_ook_set_addresses) &&
      (self[3].vtable != (shield_interface_t *)0x0)) || (*(short *)&self[1].vtable < 0))
  {
    if (*(short *)&self[1].vtable < 0)
    {
      self[3].vtable = (shield_interface_t *)0x0;
      sVar1 = smtc_hal_mcu_gpio_set_state
                        ((smtc_hal_mcu_gpio_inst_t)self[6].vtable,
                         radioless_shield_identify::previous_tx_led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x80334a0,0x8038498,0xda,0x8033484);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x80334a0,0x8038498,0xda,(uint)sVar1);
        }
      }
      sVar1 = smtc_hal_mcu_gpio_set_state
                        ((smtc_hal_mcu_gpio_inst_t)self[9].vtable,
                         radioless_shield_identify::previous_rx_led_state);
      if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
      {
        if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %s",0x80334a0,0x8038498,0xdb,0x8033484);
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                              "In %s - %s (line %d): %d",0x80334a0,0x8038498,0xdb,(uint)sVar1);
        }
      }
    }
  }
  else
  {
    sVar1 = smtc_hal_mcu_gpio_set_state
                      ((smtc_hal_mcu_gpio_inst_t)self[6].vtable,radioless_shield_identify::led_state
                      );
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80334a0,0x8038498,0xcc,0x8033484);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80334a0,0x8038498,0xcc,(uint)sVar1);
      }
    }
    sVar1 = smtc_hal_mcu_gpio_set_state
                      ((smtc_hal_mcu_gpio_inst_t)self[9].vtable,radioless_shield_identify::led_state
                      );
    if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
    {
      if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80334a0,0x8038498,0xcd,0x8033484);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80334a0,0x8038498,0xcd,(uint)sVar1);
      }
    }
    radioless_shield_identify::led_state ^= SMTC_HAL_MCU_GPIO_STATE_HIGH;
    *(short *)&self[1].vtable = *(short *)&self[1].vtable + -1;
    self[3].vtable = psVar2;
  }
  return;
}



void radioless_shield_init_identification(shield_t *self)
{
  shield_t *self_local;
  radioless_shield_t *myself;
  
  self[3].vtable = (shield_interface_t *)0x0;
  *(undefined2 *)&self[1].vtable = 0xffff;
  self[2].vtable = (shield_interface_t *)0x0;
  return;
}



_Bool dummy_is_identification_running(shield_t *self)
{
  undefined1 uVar1;
  shield_interface_t *psVar2;
  bool bVar3;
  shield_t *self_local;
  radioless_shield_t *myself;
  
  psVar2 = self[3].vtable;
  bVar3 = psVar2 != (shield_interface_t *)0x0;
  if (bVar3)
  {
    psVar2 = (shield_interface_t *)0x1;
  }
  uVar1 = SUB41(psVar2,0);
  if (!bVar3)
  {
    uVar1 = 0;
  }
  return (_Bool)uVar1;
}



void radioless_shield_runtime(shield_t *self)
{
  _Bool _Var1;
  uint32_t uVar2;
  shield_t *self_local;
  uint32_t now_ms;
  radioless_shield_t *myself;
  
  _Var1 = dummy_is_identification_running(self);
  if (_Var1)
  {
    uVar2 = support_timing_get_time();
    if (uVar2 - (int)self[2].vtable < 0x2711)
    {
      radioless_shield_identify(self);
    }
    else
    {
      radioless_shield_init_identification(self);
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          true,"Maximum identification duration time reached");
    }
  }
  return;
}



ral_t * radioless_shield_get_ral_instance(shield_t *self)
{
  shield_t *self_local;
  
  return (ral_t *)0x0;
}



void radioless_shield_handle_pre_rx(shield_t *self)
{
  shield_t *self_local;
  
  return;
}



void radioless_shield_handle_post_rx(shield_t *self)
{
  shield_t *self_local;
  
  return;
}



void radioless_shield_handle_pre_tx(shield_t *self)
{
  shield_t *self_local;
  
  return;
}



void radioless_shield_handle_post_tx(shield_t *self)
{
  shield_t *self_local;
  
  return;
}



shield_status_t
radioless_shield_set_tx_cfg(shield_t *self,int32_t power_in_half_dbm,uint32_t frquency)
{
  uint32_t frquency_local;
  int32_t power_in_half_dbm_local;
  shield_t *self_local;
  
  return SHIELD_STATUS_OK;
}



shield_status_t
radioless_shield_set_rx_boost_mode(shield_t *shield,_Bool rx_boost,uint32_t frequency)
{
  uint32_t frequency_local;
  _Bool rx_boost_local;
  shield_t *shield_local;
  
  return SHIELD_STATUS_OK;
}



shield_status_t radioless_shield_set_sleep(shield_t *shield,_Bool retain_data,_Bool retain_rtc)
{
  _Bool retain_rtc_local;
  _Bool retain_data_local;
  shield_t *shield_local;
  
  return SHIELD_STATUS_OK;
}



shield_status_t shield_system_init(shield_t *shield)
{
  shield_status_t sVar1;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_system_init)(shield);
  return sVar1;
}



void shield_init(shield_t *shield,_func_void_void_ptr *callback)
{
  _func_void_void_ptr *callback_local;
  shield_t *shield_local;
  
  (*shield->vtable->shield_init)(shield,callback);
  return;
}



void shield_deinit(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_deinit)(shield);
  return;
}



ral_t * shield_get_ral_instance(shield_t *shield)
{
  ral_t *prVar1;
  shield_t *shield_local;
  
  prVar1 = (*shield->vtable->shield_get_ral_instance)(shield);
  return prVar1;
}



void shield_handle_pre_rx(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_handle_pre_rx)(shield);
  return;
}



void shield_handle_post_rx(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_handle_post_rx)(shield);
  return;
}



void shield_handle_pre_tx(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_handle_pre_tx)(shield);
  return;
}



void shield_handle_post_tx(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_handle_post_tx)(shield);
  return;
}



void shield_identify(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_identify)(shield);
  return;
}



void shield_runtime(shield_t *shield)
{
  shield_t *shield_local;
  
  (*shield->vtable->shield_runtime)(shield);
  return;
}



shield_status_t shield_set_tx_cfg(shield_t *shield,int32_t power_in_half_dbm,uint32_t frequency)
{
  shield_status_t sVar1;
  uint32_t frequency_local;
  int32_t power_in_half_dbm_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_tx_cfg)(shield,power_in_half_dbm,frequency);
  return sVar1;
}



shield_status_t shield_set_sleep(shield_t *shield,_Bool retain_data,_Bool retain_rtc)
{
  shield_status_t sVar1;
  _Bool retain_rtc_local;
  _Bool retain_data_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_sleep)(shield,retain_data,retain_rtc);
  return sVar1;
}



shield_status_t shield_set_rx_boost_mode(shield_t *shield,_Bool rx_boost,uint32_t frequency)
{
  shield_status_t sVar1;
  uint32_t frequency_local;
  _Bool rx_boost_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_rx_boost_mode)(shield,rx_boost,frequency);
  return sVar1;
}



shield_status_t
shield_set_flrc_syncword
          (shield_t *shield,uint8_t *syncword,uint8_t syncword_index,uint8_t syncword_len)
{
  shield_status_t sVar1;
  uint8_t syncword_len_local;
  uint8_t syncword_index_local;
  uint8_t *syncword_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_flrc_syncword)(shield,syncword,syncword_index,syncword_len);
  return sVar1;
}



shield_status_t
shield_set_flrc_pkt_params(shield_t *shield,shield_flrc_pkt_params_t *flrc_pkt_params)
{
  shield_status_t sVar1;
  shield_flrc_pkt_params_t *flrc_pkt_params_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_flrc_pkt_params)(shield,flrc_pkt_params);
  return sVar1;
}



shield_status_t
shield_set_flrc_mod_params(shield_t *shield,shield_flrc_mod_params_t *flrc_mod_params)
{
  shield_status_t sVar1;
  shield_flrc_mod_params_t *flrc_mod_params_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_flrc_mod_params)(shield,flrc_mod_params);
  return sVar1;
}



shield_status_t
shield_set_ook_pkt_params
          (shield_t *shield,shield_ook_pkt_params_t *ook_pkt_params,_Bool apply_workaround)
{
  shield_status_t sVar1;
  _Bool apply_workaround_local;
  shield_ook_pkt_params_t *ook_pkt_params_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_pkt_params)(shield,ook_pkt_params,apply_workaround);
  return sVar1;
}



shield_status_t shield_set_ook_mod_params(shield_t *shield,shield_ook_mod_params_t *ook_mod_params)
{
  shield_status_t sVar1;
  shield_ook_mod_params_t *ook_mod_params_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_mod_params)(shield,ook_mod_params);
  return sVar1;
}



shield_status_t
shield_set_ook_syncword
          (shield_t *shield,uint8_t *syncword,uint8_t sync_len,uint8_t sync_len_bits,
          shield_ook_syncword_bit_order_t bit_order)
{
  shield_status_t sVar1;
  uint8_t sync_len_bits_local;
  uint8_t sync_len_local;
  uint8_t *syncword_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_syncword)
                    (shield,syncword,sync_len,sync_len_bits,bit_order);
  return sVar1;
}



shield_status_t
shield_set_ook_set_addresses(shield_t *shield,uint32_t node_address,uint32_t broadcast_address)
{
  shield_status_t sVar1;
  uint32_t broadcast_address_local;
  uint32_t node_address_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_set_addresses)(shield,node_address,broadcast_address);
  return sVar1;
}



shield_status_t
shield_set_ook_set_whitening_params
          (shield_t *shield,shield_ook_whitening_params_t *whitening_params)
{
  shield_status_t sVar1;
  shield_ook_whitening_params_t *whitening_params_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_set_whitening_params)(shield,whitening_params);
  return sVar1;
}



shield_status_t
shield_set_ook_rx_detector(shield_t *shield,shield_ook_rx_detector_t *rx_detector_params)
{
  shield_status_t sVar1;
  shield_ook_rx_detector_t *rx_detector_params_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_rx_detector)(shield,rx_detector_params);
  return sVar1;
}



shield_status_t shield_set_pkt_type(shield_t *shield,ral_t *radio,shield_packet_type_t packet_type)
{
  shield_status_t sVar1;
  shield_packet_type_t packet_type_local;
  ral_t *radio_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_pkt_type)(shield,radio,packet_type);
  return sVar1;
}



shield_status_t shield_configure_and_get_inst_rssi(shield_t *shield,int16_t *inst_rssi)
{
  shield_status_t sVar1;
  int16_t *inst_rssi_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_configure_and_get_inst_rssi)(shield,inst_rssi);
  return sVar1;
}



shield_status_t shield_set_ook_detection_level(shield_t *shield,int16_t threshold_level_db)
{
  shield_status_t sVar1;
  int16_t threshold_level_db_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_ook_detection_level)(shield,threshold_level_db);
  return sVar1;
}



shield_status_t shield_set_reg_mode(shield_t *shield,shield_reg_mode_t reg_mode)
{
  shield_status_t sVar1;
  shield_reg_mode_t reg_mode_local;
  shield_t *shield_local;
  
  sVar1 = (*shield->vtable->shield_set_reg_mode)(shield,reg_mode);
  return sVar1;
}



void shield_manager_init(hci_t *hci)
{
  hci_t *hci_local;
  
  local_hci = hci;
  shield_manager_register_shields();
  current_shield_item = shield_manager_get_shield_from_identifier(shield_RADIOLESS);
  return;
}



// WARNING: Unknown calling convention

shield_t * shield_manager_get_current_shield(void)
{
  return current_shield_item->shield;
}



// WARNING: Unknown calling convention

shield_name_t shield_manager_get_current_shield_name(void)
{
  return current_shield_item->identifier;
}



void shield_manager_change_to_new_shield(shield_name_t identifier)
{
  shield_manager_shield_registry_item_t *psVar1;
  shield_name_t identifier_local;
  shield_manager_shield_registry_item_t *new_shield_item;
  
  psVar1 = shield_manager_get_shield_from_identifier(identifier);
  if (psVar1 == (shield_manager_shield_registry_item_t *)0x0)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Failed to switch to new shield: unknown shield %d, keeping %d",
                        (uint)identifier,(uint)current_shield_item->identifier);
  }
  else
  {
    shield_deinit(current_shield_item->shield);
    current_shield_item = psVar1;
  }
  return;
}



void shield_manager_interpret_command(command_t *command)
{
  shield_name_t identifier;
  command_t *command_local;
  hci_datagram_t datagram;
  shield_name_t new_shield;
  
  if (true)
  {
    switch(command->type)
    {
    case COMMAND_TYPE_SET_SHIELD:
      identifier = (command->argument).store_in_nvm.shield_to_save;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Received SET SHIELD to %d",(uint)identifier);
      shield_manager_change_to_new_shield(identifier);
      break;
    case COMMAND_TYPE_GET_SHIELD:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Received GET SHIELD");
      memset(&datagram,0,0x804);
      datagram.tag = '\f';
      shield_manager_prepare_get_shield(datagram.data,&datagram.length,0x800);
      hci_send_datagram(local_hci,&datagram);
      break;
    case COMMAND_TYPE_GET_ALL_SHIELDS:
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                          "Received GET ALL SHIELDS");
      memset(&datagram,0,0x804);
      datagram.tag = '\r';
      shield_manager_prepare_get_shields(datagram.data,&datagram.length,0x800);
      hci_send_datagram(local_hci,&datagram);
      break;
    case COMMAND_TYPE_IDENTIFY:
      shield_identify(current_shield_item->shield);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void shield_manager_runtime(void)
{
  shield_runtime(current_shield_item->shield);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void shield_manager_restore_shield_from_nvm(void)
{
  uint8_t shield_id;
  config_manager_nvm_status_type_t status;
  
  status = config_manager_nvm_retrieve_shield(&shield_id);
  if (status != CONFIG_MANAGER_NVM_OK)
  {
    shield_id = get_fallback_default_shield(status);
  }
  shield_manager_change_to_new_shield(shield_id);
  return;
}



uint8_t get_fallback_default_shield(config_manager_nvm_status_type_t status)
{
  config_manager_nvm_status_type_t status_local;
  uint8_t shield_id;
  
  if (status == CONFIG_MANAGER_NVM_NOT_FOUND)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true
                        ,"Shield not found in NVM, setting up LR2021_ARDUINO_LEGACY as default");
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,true,
                        "Error while reading NVM to find shield, setting LR2021_ARDUINO_LEGACY as default"
                       );
  }
  return '\n';
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void shield_manager_register_shields(void)
{
  shield_manager_register_rigi_shields();
  shield_manager_register_lr11xx_shields();
  shield_manager_register_radioless_shield();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void shield_manager_register_lr11xx_shields(void)
{
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var18;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var19;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var20;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var21;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var22;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var23;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var24;
  smtc_shield_lr11xx_get_pa_pwr_cfg_f p_Var25;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var26;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var27;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var28;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var29;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var30;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var31;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var32;
  smtc_shield_lr11xx_get_rssi_calibration_table_f p_Var33;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var1;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var2;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var3;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var4;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var5;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var6;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var7;
  smtc_shield_lr11xx_get_rf_switch_cfg_f p_Var8;
  smtc_shield_lr11xx_t sVar9;
  undefined1 auVar10 [24];
  undefined1 auVar11 [24];
  undefined1 auVar12 [24];
  undefined1 auVar13 [24];
  undefined1 auVar14 [24];
  undefined1 auVar15 [24];
  undefined1 auVar16 [24];
  undefined1 auVar17 [24];
  undefined8 uVar34;
  undefined8 uVar35;
  undefined8 uVar36;
  undefined8 uVar37;
  undefined8 uVar38;
  undefined8 uVar39;
  undefined8 uVar40;
  undefined8 uVar41;
  undefined1 in_stack_00000000 [20];
  lr11xx_shield_t lStack_1f8;
  smtc_shield_lr11xx_t smtc_shield;
  
  p_Var1 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024815;
  auVar10 = CONCAT204(in_stack_00000000,p_Var1);
  p_Var18 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x80247db;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x80247fd;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar10,uVar34);
  smtc_shield.get_pa_pwr_cfg = (code *)0x80247db;
  smtc_shield.get_rssi_calibration_table = (code *)0x80247fd;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024815;
  smtc_shield.get_reg_mode = (code *)0x8024823;
  smtc_shield.get_xosc_cfg = (code *)0x8024831;
  smtc_shield.get_lfclk_cfg = (code *)0x802483f;
  smtc_shield.get_pinout = (code *)0x802484d;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020e35;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_0::shield,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1110MB1DIS,
             &shield_manager_register_lr11xx_shields::lexical_block_0::shield.base);
  p_Var2 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024895;
  auVar11 = CONCAT204(in_stack_00000000,p_Var2);
  p_Var19 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x802485b;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x802487d;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar11,uVar35);
  smtc_shield.get_pa_pwr_cfg = (code *)0x802485b;
  smtc_shield.get_rssi_calibration_table = (code *)0x802487d;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024895;
  smtc_shield.get_reg_mode = (code *)0x80248a3;
  smtc_shield.get_xosc_cfg = (code *)0x80248b1;
  smtc_shield.get_lfclk_cfg = (code *)0x80248bf;
  smtc_shield.get_pinout = (code *)0x80248cd;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020e35;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_1::shield_1,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1110MB1DJS,
             &shield_manager_register_lr11xx_shields::lexical_block_1::shield_1.base);
  p_Var3 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024915;
  auVar12 = CONCAT204(in_stack_00000000,p_Var3);
  p_Var20 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x80248db;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x80248fd;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar12,uVar36);
  smtc_shield.get_pa_pwr_cfg = (code *)0x80248db;
  smtc_shield.get_rssi_calibration_table = (code *)0x80248fd;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024915;
  smtc_shield.get_reg_mode = (code *)0x8024923;
  smtc_shield.get_xosc_cfg = (code *)0x8024931;
  smtc_shield.get_lfclk_cfg = (code *)0x802493f;
  smtc_shield.get_pinout = (code *)0x802494d;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020e35;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_2::shield_2,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1110MB1GIS,
             &shield_manager_register_lr11xx_shields::lexical_block_2::shield_2.base);
  p_Var4 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024995;
  auVar13 = CONCAT204(in_stack_00000000,p_Var4);
  p_Var21 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x802495b;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x802497d;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar13,uVar37);
  smtc_shield.get_pa_pwr_cfg = (code *)0x802495b;
  smtc_shield.get_rssi_calibration_table = (code *)0x802497d;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024995;
  smtc_shield.get_reg_mode = (code *)0x80249a3;
  smtc_shield.get_xosc_cfg = (code *)0x80249b1;
  smtc_shield.get_lfclk_cfg = (code *)0x80249bf;
  smtc_shield.get_pinout = (code *)0x80249cd;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020e35;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_3::shield_3,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1110MB1GJS,
             &shield_manager_register_lr11xx_shields::lexical_block_3::shield_3.base);
  p_Var5 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024a15;
  auVar14 = CONCAT204(in_stack_00000000,p_Var5);
  p_Var22 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x80249db;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x80249fd;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar14,uVar38);
  smtc_shield.get_pa_pwr_cfg = (code *)0x80249db;
  smtc_shield.get_rssi_calibration_table = (code *)0x80249fd;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024a15;
  smtc_shield.get_reg_mode = (code *)0x8024a23;
  smtc_shield.get_xosc_cfg = (code *)0x8024a31;
  smtc_shield.get_lfclk_cfg = (code *)0x8024a3f;
  smtc_shield.get_pinout = (code *)0x8024a4d;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020e35;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_4::shield_4,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1120MB1DIS,
             &shield_manager_register_lr11xx_shields::lexical_block_4::shield_4.base);
  p_Var6 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024a95;
  auVar15 = CONCAT204(in_stack_00000000,p_Var6);
  p_Var23 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x8024a5b;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x8024a7d;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar15,uVar39);
  smtc_shield.get_pa_pwr_cfg = (code *)0x8024a5b;
  smtc_shield.get_rssi_calibration_table = (code *)0x8024a7d;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024a95;
  smtc_shield.get_reg_mode = (code *)0x8024aa3;
  smtc_shield.get_xosc_cfg = (code *)0x8024ab1;
  smtc_shield.get_lfclk_cfg = (code *)0x8024abf;
  smtc_shield.get_pinout = (code *)0x8024acd;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020e35;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_5::shield_5,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1120MB1DJS,
             &shield_manager_register_lr11xx_shields::lexical_block_5::shield_5.base);
  p_Var7 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024bad;
  auVar16 = CONCAT204(in_stack_00000000,p_Var7);
  p_Var24 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x8024add;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x8024b95;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar16,uVar40);
  smtc_shield.get_pa_pwr_cfg = (code *)0x8024add;
  smtc_shield.get_rssi_calibration_table = (code *)0x8024b95;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024bad;
  smtc_shield.get_reg_mode = (code *)0x8024bbb;
  smtc_shield.get_xosc_cfg = (code *)0x8024bc9;
  smtc_shield.get_lfclk_cfg = (code *)0x8024bd7;
  smtc_shield.get_pinout = (code *)0x8024be5;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020f61;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_6::shield_6,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1121MB1DIS,
             &shield_manager_register_lr11xx_shields::lexical_block_6::shield_6.base);
  p_Var8 = (smtc_shield_lr11xx_get_rf_switch_cfg_f)0x8024cc5;
  auVar17 = CONCAT204(in_stack_00000000,p_Var8);
  p_Var25 = (smtc_shield_lr11xx_get_pa_pwr_cfg_f)0x8024bf5;
  register0x00000028 = (smtc_shield_lr11xx_get_rssi_calibration_table_f)0x8024cad;
  sVar9 = (smtc_shield_lr11xx_t)CONCAT248(auVar17,uVar41);
  smtc_shield.get_pa_pwr_cfg = (code *)0x8024bf5;
  smtc_shield.get_rssi_calibration_table = (code *)0x8024cad;
  smtc_shield.get_rf_switch_cfg = (code *)0x8024cc5;
  smtc_shield.get_reg_mode = (code *)0x8024cd3;
  smtc_shield.get_xosc_cfg = (code *)0x8024ce1;
  smtc_shield.get_lfclk_cfg = (code *)0x8024cef;
  smtc_shield.get_pinout = (code *)0x8024cfd;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8020f61;
  lr11xx_shield_get_instance(&lStack_1f8,sVar9);
  memcpy(&shield_manager_register_lr11xx_shields::lexical_block_7::shield_7,&lStack_1f8,0x1c0);
  shield_manager_register_shield
            (shield_LR1121MB1GIS,
             &shield_manager_register_lr11xx_shields::lexical_block_7::shield_7.base);
  return;
}



_Bool shield_manager_register_shield(shield_name_t identifier,shield_t *shield)
{
  bool bVar1;
  uint uVar2;
  shield_t *shield_local;
  shield_name_t identifier_local;
  
  bVar1 = n_shield_registry < 0xd;
  if (bVar1)
  {
    uVar2 = (uint)n_shield_registry;
    SHIELD_REGISTRY[uVar2].identifier = identifier;
    SHIELD_REGISTRY[uVar2].shield = shield;
    n_shield_registry += '\x01';
  }
  return bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void shield_manager_register_rigi_shields(void)
{
  smtc_shield_lr20xx_get_pa_pwr_cfg_f p_Var8;
  smtc_shield_lr20xx_get_pa_pwr_cfg_f p_Var9;
  smtc_shield_lr20xx_get_pa_pwr_cfg_f p_Var10;
  smtc_shield_lr20xx_get_rssi_calibration_table_f p_Var11;
  smtc_shield_lr20xx_get_rssi_calibration_table_f p_Var12;
  smtc_shield_lr20xx_get_rssi_calibration_table_f p_Var13;
  smtc_shield_lr20xx_get_rf_switch_cfg_f p_Var1;
  smtc_shield_lr20xx_get_rf_switch_cfg_f p_Var2;
  smtc_shield_lr20xx_get_rf_switch_cfg_f p_Var3;
  smtc_shield_lr20xx_t sVar4;
  undefined1 auVar5 [40];
  undefined1 auVar6 [40];
  undefined1 auVar7 [40];
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined1 in_stack_00000000 [36];
  lr20xx_shield_t lStack_210;
  smtc_shield_lr20xx_t smtc_shield;
  
  p_Var1 = (smtc_shield_lr20xx_get_rf_switch_cfg_f)0x802913d;
  auVar5 = CONCAT364(in_stack_00000000,p_Var1);
  p_Var8 = (smtc_shield_lr20xx_get_pa_pwr_cfg_f)0x8028d61;
  register0x00000028 = (smtc_shield_lr20xx_get_rssi_calibration_table_f)0x80291eb;
  sVar4 = (smtc_shield_lr20xx_t)CONCAT408(auVar5,uVar14);
  smtc_shield.get_pa_pwr_cfg = (code *)0x8028d61;
  smtc_shield.get_rssi_calibration_table = (code *)0x80291eb;
  smtc_shield.get_rf_switch_cfg = (code *)0x802913d;
  smtc_shield.get_dio_sleep_drive = (code *)0x8029159;
  smtc_shield.get_dio_function = (code *)0x8029175;
  smtc_shield.get_dio_irq_mask = (code *)0x8029191;
  smtc_shield.get_reg_mode = (code *)0x80291ad;
  smtc_shield.get_xosc_cfg = (code *)0x80291bb;
  smtc_shield.get_lfclk_cfg = (code *)0x80291dd;
  smtc_shield.get_pinout = (code *)0x80291c9;
  smtc_shield.get_irq_dio = (code *)0x8028e89;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8028ed9;
  lr20xx_shield_get_instance(&lStack_210,sVar4);
  memcpy(&shield_manager_register_rigi_shields::lexical_block_0::shield,&lStack_210,0x1c8);
  shield_manager_register_shield
            (shield_LR2021_ARDUINO_LEGACY,
             &shield_manager_register_rigi_shields::lexical_block_0::shield.base);
  in_stack_00000000 = in_stack_00000000;
  p_Var2 = (smtc_shield_lr20xx_get_rf_switch_cfg_f)0x8029203;
  auVar6 = CONCAT364(in_stack_00000000,p_Var2);
  p_Var9 = (smtc_shield_lr20xx_get_pa_pwr_cfg_f)0x8028d61;
  register0x00000028 = (smtc_shield_lr20xx_get_rssi_calibration_table_f)0x80292ad;
  sVar4 = (smtc_shield_lr20xx_t)CONCAT408(auVar6,uVar15);
  smtc_shield.get_pa_pwr_cfg = (code *)0x8028d61;
  smtc_shield.get_rssi_calibration_table = (code *)0x80292ad;
  smtc_shield.get_rf_switch_cfg = (code *)0x8029203;
  smtc_shield.get_dio_sleep_drive = (code *)0x802921f;
  smtc_shield.get_dio_function = (code *)0x802923b;
  smtc_shield.get_dio_irq_mask = (code *)0x8029257;
  smtc_shield.get_reg_mode = (code *)0x8029273;
  smtc_shield.get_xosc_cfg = (code *)0x8029281;
  smtc_shield.get_lfclk_cfg = (code *)0x802929f;
  smtc_shield.get_pinout = (code *)0x802928f;
  smtc_shield.get_irq_dio = (code *)0x8028e89;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8028ed9;
  lr20xx_shield_get_instance(&lStack_210,sVar4);
  memcpy(&shield_manager_register_rigi_shields::lexical_block_1::shield_1,&lStack_210,0x1c8);
  shield_manager_register_shield
            (shield_LR2021EVK1XBS1_ARDUINO,
             &shield_manager_register_rigi_shields::lexical_block_1::shield_1.base);
  p_Var3 = (smtc_shield_lr20xx_get_rf_switch_cfg_f)0x8029203;
  auVar7 = CONCAT364(in_stack_00000000,p_Var3);
  p_Var10 = (smtc_shield_lr20xx_get_pa_pwr_cfg_f)0x8028d61;
  register0x00000028 = (smtc_shield_lr20xx_get_rssi_calibration_table_f)0x80292ad;
  sVar4 = (smtc_shield_lr20xx_t)CONCAT408(auVar7,uVar16);
  smtc_shield.get_pa_pwr_cfg = (code *)0x8028d61;
  smtc_shield.get_rssi_calibration_table = (code *)0x80292ad;
  smtc_shield.get_rf_switch_cfg = (code *)0x8029203;
  smtc_shield.get_dio_sleep_drive = (code *)0x802921f;
  smtc_shield.get_dio_function = (code *)0x802923b;
  smtc_shield.get_dio_irq_mask = (code *)0x8029257;
  smtc_shield.get_reg_mode = (code *)0x8029273;
  smtc_shield.get_xosc_cfg = (code *)0x8029281;
  smtc_shield.get_lfclk_cfg = (code *)0x802929f;
  smtc_shield.get_pinout = (code *)0x802928f;
  smtc_shield.get_irq_dio = (code *)0x8028e89;
  smtc_shield.get_rttof_recommended_rx_tx_delay_indicator = (code *)0x8028ed9;
  lr20xx_shield_get_instance(&lStack_210,sVar4);
  memcpy(&shield_manager_register_rigi_shields::lexical_block_2::shield_2,&lStack_210,0x1c8);
  shield_manager_register_shield
            (shield_LR2021EVK1XCS1_ARDUINO,
             &shield_manager_register_rigi_shields::lexical_block_2::shield_2.base);
  return;
}



shield_manager_shield_registry_item_t *
shield_manager_get_shield_from_identifier(shield_name_t identifier)
{
  shield_name_t identifier_local;
  shield_manager_shield_registry_item_t *local_item;
  uint32_t known_shield_index;
  
  known_shield_index = 0;
  while( true )
  {
    if (0xc < known_shield_index)
    {
      return (shield_manager_shield_registry_item_t *)0x0;
    }
    if (identifier == SHIELD_REGISTRY[known_shield_index].identifier) break;
    known_shield_index += 1;
  }
  return SHIELD_REGISTRY + known_shield_index;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void shield_manager_register_radioless_shield(void)
{
  shield_interface_t *local_38;
  radioless_shield_identify_t rStack_34;
  smtc_hal_mcu_gpio_cfg_t local_28;
  undefined4 uStack_24;
  smtc_hal_mcu_gpio_inst_t psStack_20;
  smtc_hal_mcu_gpio_cfg_t psStack_1c;
  undefined4 local_18;
  smtc_hal_mcu_gpio_inst_t psStack_14;
  
  radioless_shield_get_instance();
  shield_manager_register_radioless_shield::shield.base.vtable = local_38;
  shield_manager_register_radioless_shield::shield.identify._0_4_ = rStack_34._0_4_;
  shield_manager_register_radioless_shield::shield.identify.start_of_id_process =
       rStack_34.start_of_id_process;
  shield_manager_register_radioless_shield::shield.identify.last_trig_ms = rStack_34.last_trig_ms;
  shield_manager_register_radioless_shield::shield.led_tx.cfg = local_28;
  shield_manager_register_radioless_shield::shield.led_tx._4_4_ = uStack_24;
  shield_manager_register_radioless_shield::shield.led_tx.inst = psStack_20;
  shield_manager_register_radioless_shield::shield.led_rx.cfg = psStack_1c;
  shield_manager_register_radioless_shield::shield.led_rx._4_4_ = local_18;
  shield_manager_register_radioless_shield::shield.led_rx.inst = psStack_14;
  shield_manager_register_shield
            (shield_RADIOLESS,&shield_manager_register_radioless_shield::shield.base);
  return;
}



_Bool shield_manager_prepare_get_shield
                (uint8_t *buffer,uint16_t *packed_buffer_length,uint16_t max_length)
{
  _Bool _Var1;
  size_t sVar2;
  uint16_t max_length_local;
  uint16_t *packed_buffer_length_local;
  uint8_t *buffer_local;
  DeviceMessage__Shield shield;
  _Bool shield_value_convertion_success;
  
  shield.base.descriptor = &device_message__shield__descriptor;
  shield.base.n_unknown_fields = 0;
  shield.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  shield.shield = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1DIS;
  _Var1 = shield_manager_shield_name_to_proto_value(current_shield_item->identifier,&shield.shield);
  if (_Var1)
  {
    sVar2 = device_message__shield__get_packed_size(&shield);
    *packed_buffer_length = (uint16_t)sVar2;
    if (max_length < *packed_buffer_length)
    {
      _Var1 = false;
    }
    else
    {
      device_message__shield__pack(&shield,buffer);
      _Var1 = true;
    }
  }
  else
  {
    _Var1 = false;
  }
  return _Var1;
}



_Bool shield_manager_prepare_get_shields
                (uint8_t *buffer,uint16_t *packed_buffer_length,uint16_t max_length)
{
  ushort uVar1;
  _Bool _Var2;
  size_t sVar3;
  uint16_t max_length_local;
  uint16_t *packed_buffer_length_local;
  uint8_t *buffer_local;
  DeviceMessage__ShieldValue shield_list [13];
  DeviceMessage__Shields shields;
  _Bool shield_value_convertion_success;
  uint8_t known_shield_index;
  
  shields.base.descriptor = &device_message__shields__descriptor;
  shields.base.n_unknown_fields = 0;
  shields.base.unknown_fields = (ProtobufCMessageUnknownField *)0x0;
  shields.n_shields = 0;
  shields.shields = (DeviceMessage__ShieldValue *)0x0;
  memset(shield_list,0,0x34);
  known_shield_index = '\0';
  while( true )
  {
    if (n_shield_registry <= known_shield_index)
    {
      shields.n_shields = (size_t)n_shield_registry;
      shields.shields = shield_list;
      sVar3 = device_message__shields__get_packed_size(&shields);
      *packed_buffer_length = (uint16_t)sVar3;
      uVar1 = *packed_buffer_length;
      if (uVar1 <= max_length)
      {
        device_message__shields__pack(&shields,buffer);
      }
      return uVar1 <= max_length;
    }
    _Var2 = shield_manager_shield_name_to_proto_value
                      (SHIELD_REGISTRY[known_shield_index].identifier,
                       shield_list + known_shield_index);
    if (!_Var2) break;
    known_shield_index += '\x01';
  }
  return false;
}



_Bool shield_manager_shield_name_to_proto_value
                (shield_name_t shield_name,DeviceMessage__ShieldValue *value)
{
  _Bool _Var1;
  DeviceMessage__ShieldValue *value_local;
  shield_name_t shield_name_local;
  
  switch(shield_name)
  {
  case shield_LR1110MB1DIS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1DIS;
    _Var1 = true;
    break;
  case shield_LR1110MB1DJS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1DJS;
    _Var1 = true;
    break;
  case shield_LR1110MB1GIS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1GIS;
    _Var1 = true;
    break;
  case shield_LR1110MB1GJS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1110MB1GJS;
    _Var1 = true;
    break;
  case shield_LR1120MB1DIS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1120MB1DIS;
    _Var1 = true;
    break;
  case shield_LR1120MB1DJS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1120MB1DJS;
    _Var1 = true;
    break;
  case shield_LR1120MB1GIS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1120MB1GIS;
    _Var1 = true;
    break;
  case shield_LR1120MB1GJS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1120MB1GJS;
    _Var1 = true;
    break;
  case shield_LR1121MB1DIS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1121MB1DIS;
    _Var1 = true;
    break;
  case shield_LR1121MB1GIS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR1121MB1GIS;
    _Var1 = true;
    break;
  case shield_LR2021_ARDUINO_LEGACY:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR2021_ARDUINO_LEGACY;
    _Var1 = true;
    break;
  case shield_LR2021EVK1XBS1_ARDUINO:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR2021EVK1XBS1_ARDUINO;
    _Var1 = true;
    break;
  case shield_LR2021EVK1XCS1_ARDUINO:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR2021EVK1XCS1_ARDUINO;
    _Var1 = true;
    break;
  case shield_LR2021EVK1XBS1_XIAO:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR2021EVK1XBS1_XIAO;
    _Var1 = true;
    break;
  case shield_LR2021EVK1XCS1_XIAO:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_LR2021EVK1XCS1_XIAO;
    _Var1 = true;
    break;
  case shield_RADIOLESS:
    *value = DEVICE_MESSAGE__SHIELD_VALUE__SHIELD_RADIOLESS;
    _Var1 = true;
    break;
  default:
    _Var1 = false;
  }
  return _Var1;
}



lr11xx_hal_status_t lr11xx_hal_reset(void *context)
{
  smtc_hal_mcu_status_t sVar1;
  void *context_local;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  lr11xx_hal_context_t *lr11xx_context;
  
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x1c),SMTC_HAL_MCU_GPIO_STATE_LOW)
  ;
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384b4,0x5b,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384b4,0x5b,(uint)sVar1);
    }
  }
  smtc_hal_mcu_wait_ms(1);
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x1c),SMTC_HAL_MCU_GPIO_STATE_HIGH
                    );
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384b4,0x5d,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384b4,0x5d,(uint)sVar1);
    }
  }
  return LR11XX_HAL_STATUS_OK;
}



lr11xx_hal_status_t lr11xx_hal_wakeup(void *context)
{
  smtc_hal_mcu_status_t sVar1;
  void *context_local;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  lr11xx_hal_context_t *lr11xx_context;
  
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW)
  ;
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384c8,0x66,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384c8,0x66,(uint)sVar1);
    }
  }
  smtc_hal_mcu_wait_ms(1);
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH
                    );
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384c8,0x68,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384c8,0x68,(uint)sVar1);
    }
  }
  return LR11XX_HAL_STATUS_OK;
}



lr11xx_hal_status_t
lr11xx_hal_write(void *context,uint8_t *command,uint16_t command_length,uint8_t *data,
                uint16_t data_length)
{
  smtc_hal_mcu_status_t sVar1;
  uint8_t *data_local;
  uint16_t command_length_local;
  uint8_t *command_local;
  void *context_local;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  lr11xx_hal_context_t *lr11xx_context;
  
  lr11xx_hal_wait_on_busy(context);
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW)
  ;
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384dc,0x79,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384dc,0x79,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_spi_rw_buffer
                    (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),command,(uint8_t *)0x0,
                     command_length);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384dc,0x7a,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384dc,0x7a,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_spi_rw_buffer
                    (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),data,(uint8_t *)0x0,data_length)
  ;
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384dc,0x7b,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384dc,0x7b,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH
                    );
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384dc,0x7f,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384dc,0x7f,(uint)sVar1);
    }
  }
  return LR11XX_HAL_STATUS_OK;
}



lr11xx_hal_status_t
lr11xx_hal_read(void *context,uint8_t *command,uint16_t command_length,uint8_t *data,
               uint16_t data_length)
{
  uint8_t *data_local;
  uint16_t command_length_local;
  uint8_t *command_local;
  void *context_local;
  uint8_t dummy_byte_rx;
  uint8_t dummy_byte;
  smtc_hal_mcu_status_t status_6;
  smtc_hal_mcu_status_t status_5;
  smtc_hal_mcu_status_t status_4;
  smtc_hal_mcu_status_t status_3;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  lr11xx_hal_context_t *lr11xx_context;
  
  dummy_byte = '\0';
  dummy_byte_rx = '\0';
  lr11xx_context = (lr11xx_hal_context_t *)context;
  lr11xx_hal_wait_on_busy(context);
  status = smtc_hal_mcu_gpio_set_state((lr11xx_context->nss).inst,SMTC_HAL_MCU_GPIO_STATE_LOW);
  if (status != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0x91,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0x91,(uint)status);
    }
  }
  status_1 = smtc_hal_mcu_spi_rw_buffer
                       ((lr11xx_context->spi).inst,command,(uint8_t *)0x0,command_length);
  if (status_1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status_1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0x92,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0x92,(uint)status_1);
    }
  }
  status_2 = smtc_hal_mcu_gpio_set_state((lr11xx_context->nss).inst,SMTC_HAL_MCU_GPIO_STATE_HIGH);
  if (status_2 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status_2 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0x96,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0x96,(uint)status_2);
    }
  }
  lr11xx_hal_wait_on_busy(lr11xx_context);
  status_3 = smtc_hal_mcu_gpio_set_state((lr11xx_context->nss).inst,SMTC_HAL_MCU_GPIO_STATE_LOW);
  if (status_3 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status_3 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0x9a,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0x9a,(uint)status_3);
    }
  }
  status_4 = smtc_hal_mcu_spi_rw_buffer((lr11xx_context->spi).inst,&dummy_byte,&dummy_byte_rx,1);
  if (status_4 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status_4 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0x9b,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0x9b,(uint)status_4);
    }
  }
  status_5 = smtc_hal_mcu_spi_rw_buffer((lr11xx_context->spi).inst,(uint8_t *)0x0,data,data_length);
  if (status_5 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status_5 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0x9c,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0x9c,(uint)status_5);
    }
  }
  status_6 = smtc_hal_mcu_gpio_set_state((lr11xx_context->nss).inst,SMTC_HAL_MCU_GPIO_STATE_HIGH);
  if (status_6 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (status_6 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x80384f0,0xa1,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x80384f0,0xa1,(uint)status_6);
    }
  }
  return LR11XX_HAL_STATUS_OK;
}



lr11xx_hal_status_t lr11xx_hal_direct_read(void *radio,uint8_t *data,uint16_t data_length)
{
  smtc_hal_mcu_status_t sVar1;
  uint16_t data_length_local;
  uint8_t *data_local;
  void *radio_local;
  smtc_hal_mcu_status_t status_2;
  smtc_hal_mcu_status_t status_1;
  smtc_hal_mcu_status_t status;
  lr11xx_hal_context_t *lr11xx_context;
  
  lr11xx_hal_wait_on_busy(radio);
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)radio + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x8038500,0xb5,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x8038500,0xb5,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_spi_rw_buffer
                    (*(smtc_hal_mcu_spi_inst_t *)((int)radio + 4),(uint8_t *)0x0,data,data_length);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x8038500,0xb6,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x8038500,0xb6,(uint)sVar1);
    }
  }
  sVar1 = smtc_hal_mcu_gpio_set_state
                    (*(smtc_hal_mcu_gpio_inst_t *)((int)radio + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    if (sVar1 == SMTC_HAL_MCU_STATUS_ERROR)
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %s",0x80337d0,0x8038500,0xbb,0x80337b4);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                          "In %s - %s (line %d): %d",0x80337d0,0x8038500,0xbb,(uint)sVar1);
    }
  }
  return LR11XX_HAL_STATUS_OK;
}



void lr11xx_hal_wait_on_busy(void *radio)
{
  void *radio_local;
  smtc_hal_mcu_gpio_state_t gpio_state;
  smtc_hal_mcu_status_t status;
  lr11xx_hal_context_t *lr11xx_context;
  
  lr11xx_context = (lr11xx_hal_context_t *)radio;
  do
  {
    status = smtc_hal_mcu_gpio_get_state((lr11xx_context->busy).inst,&gpio_state);
    if (status != SMTC_HAL_MCU_STATUS_OK)
    {
      if (status == SMTC_HAL_MCU_STATUS_ERROR)
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %s",0x80337d0,0x8038518,0xd5,0x80337b4);
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__WARNING,DEVICE_MESSAGE__LOG_SOURCE__DEMO,true,
                            "In %s - %s (line %d): %d",0x80337d0,0x8038518,0xd5,(uint)status);
      }
    }
  } while (gpio_state == SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return;
}



void ral_lr11xx_bsp_get_reg_mode(void *context,lr11xx_system_reg_mode_t *reg_mode)
{
  lr11xx_system_reg_mode_t lVar1;
  shield_t *psVar2;
  lr11xx_system_reg_mode_t *reg_mode_local;
  void *context_local;
  lr11xx_shield_t *shield;
  
  psVar2 = shield_manager_get_current_shield();
  lVar1 = (*(code *)psVar2[4].vtable)();
  *reg_mode = lVar1;
  return;
}



void ral_lr11xx_bsp_get_rf_switch_cfg(void *context,lr11xx_system_rfswitch_cfg_t *rf_switch_cfg)
{
  shield_t *psVar1;
  uint8_t *puVar2;
  lr11xx_system_rfswitch_cfg_t *rf_switch_cfg_local;
  void *context_local;
  lr11xx_system_rfswitch_cfg_t *shield_rfswitch_cfg;
  lr11xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  puVar2 = (uint8_t *)(*(code *)psVar1[3].vtable)();
  rf_switch_cfg->enable = *puVar2;
  rf_switch_cfg->standby = puVar2[1];
  rf_switch_cfg->tx = puVar2[3];
  rf_switch_cfg->tx_hf = puVar2[5];
  rf_switch_cfg->tx_hp = puVar2[4];
  rf_switch_cfg->rx = puVar2[2];
  rf_switch_cfg->wifi = puVar2[7];
  rf_switch_cfg->gnss = puVar2[6];
  return;
}



void ral_lr11xx_bsp_get_tx_cfg
               (void *context,ral_lr11xx_bsp_tx_cfg_input_params_t *input_params,
               ral_lr11xx_bsp_tx_cfg_output_params_t *output_params)
{
  shield_t *psVar1;
  int8_t *piVar2;
  ral_lr11xx_bsp_tx_cfg_output_params_t *output_params_local;
  ral_lr11xx_bsp_tx_cfg_input_params_t *input_params_local;
  void *context_local;
  smtc_shield_lr11xx_pa_pwr_cfg_t *pa_pwr_cfg;
  lr11xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  piVar2 = (int8_t *)
           (*(code *)psVar1[1].vtable)
                     (input_params->freq_in_hz,(int)input_params->system_output_pwr_in_dbm);
  (output_params->pa_cfg).pa_reg_supply = piVar2[2];
  (output_params->pa_cfg).pa_sel = piVar2[1];
  (output_params->pa_cfg).pa_hp_sel = piVar2[4];
  (output_params->pa_cfg).pa_duty_cycle = piVar2[3];
  output_params->chip_output_pwr_in_dbm_configured = *piVar2;
  output_params->chip_output_pwr_in_dbm_expected = input_params->system_output_pwr_in_dbm;
  output_params->pa_ramp_time = LR11XX_RADIO_RAMP_304_US;
  return;
}



void ral_lr11xx_bsp_get_xosc_cfg
               (void *context,ral_xosc_cfg_t *xosc_cfg,
               lr11xx_system_tcxo_supply_voltage_t *supply_voltage,uint32_t *startup_time_in_tick)
{
  shield_t *psVar1;
  ral_xosc_cfg_t *prVar2;
  uint32_t *startup_time_in_tick_local;
  lr11xx_system_tcxo_supply_voltage_t *supply_voltage_local;
  ral_xosc_cfg_t *xosc_cfg_local;
  void *context_local;
  smtc_shield_lr11xx_xosc_cfg_t *shield_xosc_cfg;
  lr11xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  prVar2 = (ral_xosc_cfg_t *)(*(code *)psVar1[5].vtable)();
  *xosc_cfg = *prVar2;
  *supply_voltage = prVar2[1];
  *startup_time_in_tick = *(undefined4 *)(prVar2 + 4);
  return;
}



void ral_lr11xx_bsp_get_crc_state(void *context,_Bool *crc_is_activated)
{
  _Bool *crc_is_activated_local;
  void *context_local;
  
  *crc_is_activated = false;
  return;
}



void ral_lr11xx_bsp_get_rssi_calibration_table
               (void *context,uint32_t freq_in_hz,
               lr11xx_radio_rssi_calibration_table_t *rssi_calibration_table)
{
  shield_t *psVar1;
  uint8_t *puVar2;
  lr11xx_radio_rssi_calibration_table_t *rssi_calibration_table_local;
  uint32_t freq_in_hz_local;
  void *context_local;
  lr11xx_radio_rssi_calibration_table_t *table;
  lr11xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  puVar2 = (uint8_t *)(*(code *)psVar1[2].vtable)(freq_in_hz);
  rssi_calibration_table->gain_offset = *(int16_t *)(puVar2 + 0x12);
  (rssi_calibration_table->gain_tune).g11 = puVar2[7];
  (rssi_calibration_table->gain_tune).g10 = puVar2[6];
  (rssi_calibration_table->gain_tune).g9 = puVar2[5];
  (rssi_calibration_table->gain_tune).g8 = puVar2[4];
  (rssi_calibration_table->gain_tune).g7 = puVar2[3];
  (rssi_calibration_table->gain_tune).g6 = puVar2[2];
  (rssi_calibration_table->gain_tune).g5 = puVar2[1];
  (rssi_calibration_table->gain_tune).g4 = *puVar2;
  (rssi_calibration_table->gain_tune).g13hp6 = puVar2[0xf];
  (rssi_calibration_table->gain_tune).g13hp5 = puVar2[0xe];
  (rssi_calibration_table->gain_tune).g13hp4 = puVar2[0xd];
  (rssi_calibration_table->gain_tune).g13hp3 = puVar2[0xc];
  (rssi_calibration_table->gain_tune).g13hp2 = puVar2[0xb];
  (rssi_calibration_table->gain_tune).g13hp1 = puVar2[10];
  (rssi_calibration_table->gain_tune).g13 = puVar2[9];
  (rssi_calibration_table->gain_tune).g12 = puVar2[8];
  (rssi_calibration_table->gain_tune).g13hp7 = puVar2[0x10];
  return;
}



void ral_lr11xx_bsp_get_lora_cad_det_peak
               (void *context,ral_lora_sf_t sf,ral_lora_bw_t bw,ral_lora_cad_symbs_t nb_symbol,
               uint8_t *in_out_cad_det_peak)
{
  ral_lora_cad_symbs_t nb_symbol_local;
  ral_lora_bw_t bw_local;
  ral_lora_sf_t sf_local;
  void *context_local;
  
  return;
}



void ral_lr11xx_bsp_get_rx_boost_cfg(void *context,_Bool *rx_boost_is_activated)
{
  _Bool *rx_boost_is_activated_local;
  void *context_local;
  
  *rx_boost_is_activated = false;
  return;
}



void ral_lr11xx_bsp_get_lfclk_cfg_in_sleep(void *context,_Bool *lfclk_is_running)
{
  _Bool *lfclk_is_running_local;
  void *context_local;
  
  *lfclk_is_running = false;
  return;
}



ral_status_t
ral_lr11xx_bsp_get_instantaneous_tx_power_consumption
          (void *context,ral_lr11xx_bsp_tx_cfg_output_params_t *tx_cfg,
          lr11xx_system_reg_mode_t radio_reg_mode,uint32_t *pwr_consumption_in_ua)
{
  uint32_t *pwr_consumption_in_ua_local;
  lr11xx_system_reg_mode_t radio_reg_mode_local;
  ral_lr11xx_bsp_tx_cfg_output_params_t *tx_cfg_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_bsp_get_instantaneous_gfsk_rx_power_consumption
          (void *context,lr11xx_system_reg_mode_t radio_reg_mode,_Bool rx_boosted,
          uint32_t *pwr_consumption_in_ua)
{
  uint32_t *pwr_consumption_in_ua_local;
  _Bool rx_boosted_local;
  lr11xx_system_reg_mode_t radio_reg_mode_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_bsp_get_instantaneous_lora_rx_power_consumption
          (void *context,lr11xx_system_reg_mode_t radio_reg_mode,_Bool rx_boosted,
          uint32_t *pwr_consumption_in_ua)
{
  uint32_t *pwr_consumption_in_ua_local;
  _Bool rx_boosted_local;
  lr11xx_system_reg_mode_t radio_reg_mode_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



void ral_lr20xx_bsp_get_front_end_calibration_cfg
               (void *context,
               lr20xx_radio_common_front_end_calibration_value_t *front_end_calibration_structures)
{
  lr20xx_radio_common_front_end_calibration_value_t *front_end_calibration_structures_local;
  void *context_local;
  lr20xx_radio_common_rx_path_boost_mode_t dummy_rx_boost;
  uint32_t freq_in_hz_to_calibrate;
  radio_parameters_t *radio_parameters;
  
  radio_parameters = common_radio_get_parameters();
  freq_in_hz_to_calibrate = (radio_parameters->rf_freq_in_hz).val;
  dummy_rx_boost = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_NONE;
  front_end_calibration_structures->frequency_in_hertz = freq_in_hz_to_calibrate;
  ral_lr20xx_bsp_get_rx_cfg
            ((void *)0x0,freq_in_hz_to_calibrate,&front_end_calibration_structures->rx_path,
             &dummy_rx_boost);
  front_end_calibration_structures[1].frequency_in_hertz = freq_in_hz_to_calibrate;
  ral_lr20xx_bsp_get_rx_cfg
            ((void *)0x0,freq_in_hz_to_calibrate,&front_end_calibration_structures[1].rx_path,
             &dummy_rx_boost);
  front_end_calibration_structures[2].frequency_in_hertz = freq_in_hz_to_calibrate;
  ral_lr20xx_bsp_get_rx_cfg
            ((void *)0x0,freq_in_hz_to_calibrate,&front_end_calibration_structures[2].rx_path,
             &dummy_rx_boost);
  return;
}



void ral_lr20xx_bsp_get_tx_cfg
               (void *context,ral_lr20xx_bsp_tx_cfg_input_params_t *input_params,
               ral_lr20xx_bsp_tx_cfg_output_params_t *output_params)
{
  shield_t *psVar1;
  int iVar2;
  ral_lr20xx_bsp_tx_cfg_output_params_t *output_params_local;
  ral_lr20xx_bsp_tx_cfg_input_params_t *input_params_local;
  void *context_local;
  smtc_shield_lr20xx_pa_pwr_cfg_t *pa_cfg;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  iVar2 = (*(code *)psVar1[1].vtable)
                    (input_params->freq_in_hz,(int)input_params->system_output_pwr_in_dbm);
  output_params->chip_output_half_pwr_in_dbm_configured = input_params->system_output_pwr_in_dbm;
  output_params->chip_output_pwr_in_dbm_expected = input_params->system_output_pwr_in_dbm;
  (output_params->pa_cfg).pa_lf_mode = *(lr20xx_radio_common_pa_lf_mode_t *)(iVar2 + 2);
  (output_params->pa_cfg).pa_lf_duty_cycle = *(uint8_t *)(iVar2 + 3);
  (output_params->pa_cfg).pa_lf_slices = *(uint8_t *)(iVar2 + 4);
  (output_params->pa_cfg).pa_hf_duty_cycle = *(uint8_t *)(iVar2 + 5);
  output_params->pa_ramp_time = LR20XX_RADIO_COMMON_RAMP_48_US;
  (output_params->pa_cfg).pa_sel = *(lr20xx_radio_common_pa_selection_t *)(iVar2 + 1);
  return;
}



void ral_lr20xx_bsp_get_dio_rf_switch_cfg
               (void *context,lr20xx_system_dio_t dio,
               lr20xx_system_dio_rf_switch_cfg_t *rf_switch_cfg)
{
  shield_t *psVar1;
  lr20xx_system_dio_rf_switch_cfg_t *plVar2;
  lr20xx_system_dio_rf_switch_cfg_t *rf_switch_cfg_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  lr20xx_system_dio_rf_switch_cfg_t *rf_switch_cfg_p;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  plVar2 = (lr20xx_system_dio_rf_switch_cfg_t *)(*(code *)psVar1[3].vtable)(dio);
  *rf_switch_cfg = *plVar2;
  return;
}



void ral_lr20xx_bsp_get_reg_mode(void *context,lr20xx_system_reg_mode_t *reg_mode)
{
  shield_t *psVar1;
  lr20xx_system_reg_mode_t *plVar2;
  lr20xx_system_reg_mode_t *reg_mode_local;
  void *context_local;
  lr20xx_system_reg_mode_t *reg_mode_p;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  plVar2 = (lr20xx_system_reg_mode_t *)(*(code *)psVar1[7].vtable)();
  *reg_mode = *plVar2;
  return;
}



void ral_bsp_lr20xx_get_lfclk_cfg(void *context,lr20xx_system_lfclk_cfg_t *lfclk_cfg)
{
  shield_t *psVar1;
  lr20xx_system_lfclk_cfg_t *plVar2;
  lr20xx_system_lfclk_cfg_t *lfclk_cfg_local;
  void *context_local;
  lr20xx_system_lfclk_cfg_t *lfclk_cfg_p;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  plVar2 = (lr20xx_system_lfclk_cfg_t *)(*(code *)psVar1[9].vtable)();
  *lfclk_cfg = *plVar2;
  return;
}



void ral_lr20xx_bsp_get_xosc_cfg
               (void *context,ral_xosc_cfg_t *xosc_cfg,
               lr20xx_system_tcxo_supply_voltage_t *tcxo_supply_voltage,
               uint32_t *startup_time_in_tick)
{
  shield_t *psVar1;
  ral_xosc_cfg_t *prVar2;
  uint32_t *startup_time_in_tick_local;
  lr20xx_system_tcxo_supply_voltage_t *tcxo_supply_voltage_local;
  ral_xosc_cfg_t *xosc_cfg_local;
  void *context_local;
  smtc_shield_lr20xx_xosc_cfg_t *shield_xosc_cfg;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  prVar2 = (ral_xosc_cfg_t *)(*(code *)psVar1[8].vtable)();
  *xosc_cfg = *prVar2;
  *tcxo_supply_voltage = prVar2[1];
  *startup_time_in_tick = *(undefined4 *)(prVar2 + 4);
  return;
}



void ral_lr20xx_bsp_get_dio_function
               (void *context,lr20xx_system_dio_t dio,lr20xx_system_dio_func_t *function)
{
  shield_t *psVar1;
  lr20xx_system_dio_func_t *plVar2;
  lr20xx_system_dio_func_t *function_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  lr20xx_system_dio_func_t *function_p;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  plVar2 = (lr20xx_system_dio_func_t *)(*(code *)psVar1[5].vtable)(dio);
  *function = *plVar2;
  return;
}



void ral_lr20xx_bsp_get_dio_sleep_drive
               (void *context,lr20xx_system_dio_t dio,lr20xx_system_dio_drive_t *drive)
{
  shield_t *psVar1;
  lr20xx_system_dio_drive_t *plVar2;
  lr20xx_system_dio_drive_t *drive_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  lr20xx_system_dio_drive_t *drive_p;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  plVar2 = (lr20xx_system_dio_drive_t *)(*(code *)psVar1[4].vtable)(dio);
  *drive = *plVar2;
  return;
}



void ral_lr20xx_bsp_get_dio_irq_mask
               (void *context,lr20xx_system_dio_t dio,lr20xx_system_irq_mask_t *irq_mask)
{
  shield_t *psVar1;
  lr20xx_system_irq_mask_t *plVar2;
  lr20xx_system_irq_mask_t *irq_mask_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  lr20xx_system_irq_mask_t *irq_mask_p;
  lr20xx_shield_t *shield;
  
  psVar1 = shield_manager_get_current_shield();
  plVar2 = (lr20xx_system_irq_mask_t *)(*(code *)psVar1[6].vtable)(dio);
  *irq_mask = *plVar2;
  return;
}



void ral_lr20xx_bsp_get_dio_hf_clk_scaling_cfg
               (void *context,lr20xx_system_hf_clk_scaling_t *hf_clk_scaling)
{
  lr20xx_system_hf_clk_scaling_t *hf_clk_scaling_local;
  void *context_local;
  
  return;
}



void ral_lr20xx_bsp_get_rx_cfg
               (void *context,uint32_t freq_in_hz,lr20xx_radio_common_rx_path_t *rx_path,
               lr20xx_radio_common_rx_path_boost_mode_t *boost_mode)
{
  radio_parameters_t *prVar1;
  lr20xx_radio_common_rx_path_boost_mode_t *boost_mode_local;
  lr20xx_radio_common_rx_path_t *rx_path_local;
  uint32_t freq_in_hz_local;
  void *context_local;
  lr20xx_radio_common_front_end_calibration_value_t calibration;
  radio_parameters_t *shield_radio_parameters;
  
  prVar1 = common_radio_get_parameters();
  *rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
  if (1900000000 < freq_in_hz)
  {
    *rx_path = LR20XX_RADIO_COMMON_RX_PATH_HF;
  }
  calibration.rx_path = *rx_path;
  calibration.frequency_in_hertz = freq_in_hz;
  lr20xx_radio_common_calibrate_front_end_helper(context,&calibration,'\x01');
  if ((prVar1->enable_rx_boost_mode).val == false)
  {
    *boost_mode = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_NONE;
  }
  else
  {
    *boost_mode = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_7;
  }
  return;
}



void ral_lr20xx_bsp_get_lora_cad_det_peak
               (void *context,ral_lora_sf_t sf,ral_lora_cad_symbs_t nb_symbol,
               uint8_t *in_out_cad_det_peak)
{
  uint8_t *in_out_cad_det_peak_local;
  ral_lora_cad_symbs_t nb_symbol_local;
  ral_lora_sf_t sf_local;
  void *context_local;
  
  return;
}



ral_status_t
ral_lr20xx_bsp_get_instantaneous_lora_rx_power_consumption
          (void *context,lr20xx_system_reg_mode_t radio_reg_mode,ral_lora_bw_t bw,_Bool rx_boosted,
          uint32_t *pwr_consumption_in_ua)
{
  _Bool rx_boosted_local;
  ral_lora_bw_t bw_local;
  lr20xx_system_reg_mode_t radio_reg_mode_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_bsp_get_instantaneous_tx_power_consumption
          (void *context,ral_lr20xx_bsp_tx_cfg_output_params_t *tx_cfg,
          lr20xx_system_reg_mode_t radio_reg_mode,uint32_t *pwr_consumption_in_ua)
{
  uint32_t *pwr_consumption_in_ua_local;
  lr20xx_system_reg_mode_t radio_reg_mode_local;
  ral_lr20xx_bsp_tx_cfg_output_params_t *tx_cfg_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_bsp_get_instantaneous_gfsk_rx_power_consumption
          (void *context,lr20xx_system_reg_mode_t radio_reg_mode,_Bool rx_boosted,
          uint32_t *pwr_consumption_in_ua)
{
  uint32_t *pwr_consumption_in_ua_local;
  _Bool rx_boosted_local;
  lr20xx_system_reg_mode_t radio_reg_mode_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



lr20xx_hal_status_t lr20xx_hal_reset(void *context)
{
  void *context_local;
  lr20xx_hal_context_t *lr20xx_context;
  
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x1c),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_wait_ms(1);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x1c),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return LR20XX_HAL_STATUS_OK;
}



lr20xx_hal_status_t lr20xx_hal_wakeup(void *context)
{
  void *context_local;
  lr20xx_hal_context_t *lr20xx_context;
  
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_wait_ms(1);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return LR20XX_HAL_STATUS_OK;
}



lr20xx_hal_status_t
lr20xx_hal_write(void *context,uint8_t *command,uint16_t command_length,uint8_t *data,
                uint16_t data_length)
{
  uint8_t *data_local;
  uint16_t command_length_local;
  uint8_t *command_local;
  void *context_local;
  lr20xx_hal_context_t *lr20xx_context;
  
  lr20xx_hal_wait_on_busy(context);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),command,(uint8_t *)0x0,command_length);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),data,(uint8_t *)0x0,data_length);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return LR20XX_HAL_STATUS_OK;
}



lr20xx_hal_status_t
lr20xx_hal_read(void *context,uint8_t *command,uint16_t command_length,uint8_t *data,
               uint16_t data_length)
{
  uint8_t *data_local;
  uint16_t command_length_local;
  uint8_t *command_local;
  void *context_local;
  uint8_t dummy_byte_rx [2];
  uint8_t dummy_byte [2];
  lr20xx_hal_context_t *lr20xx_context;
  
  dummy_byte[0] = '\0';
  dummy_byte[1] = '\0';
  dummy_byte_rx[0] = '\0';
  dummy_byte_rx[1] = '\0';
  lr20xx_hal_wait_on_busy(context);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),command,(uint8_t *)0x0,command_length);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  lr20xx_hal_wait_on_busy(context);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),dummy_byte,dummy_byte_rx,2);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)context + 4),(uint8_t *)0x0,data,data_length);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)context + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return LR20XX_HAL_STATUS_OK;
}



lr20xx_hal_status_t
lr20xx_hal_direct_read_fifo
          (void *radio,uint8_t *command,uint16_t command_length,uint8_t *data,uint16_t data_length)
{
  uint8_t *data_local;
  uint16_t command_length_local;
  uint8_t *command_local;
  void *radio_local;
  lr20xx_hal_context_t *lr20xx_context;
  
  lr20xx_hal_wait_on_busy(radio);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)radio + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)radio + 4),command,(uint8_t *)0x0,command_length);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)radio + 4),(uint8_t *)0x0,data,data_length);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)radio + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return LR20XX_HAL_STATUS_OK;
}



lr20xx_hal_status_t lr20xx_hal_direct_read(void *radio,uint8_t *data,uint16_t data_length)
{
  uint16_t data_length_local;
  uint8_t *data_local;
  void *radio_local;
  lr20xx_hal_context_t *lr20xx_context;
  
  lr20xx_hal_wait_on_busy(radio);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)radio + 0x10),SMTC_HAL_MCU_GPIO_STATE_LOW);
  smtc_hal_mcu_spi_rw_buffer
            (*(smtc_hal_mcu_spi_inst_t *)((int)radio + 4),(uint8_t *)0x0,data,data_length);
  smtc_hal_mcu_gpio_set_state
            (*(smtc_hal_mcu_gpio_inst_t *)((int)radio + 0x10),SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return LR20XX_HAL_STATUS_OK;
}



void lr20xx_hal_wait_on_busy(void *radio)
{
  void *radio_local;
  smtc_hal_mcu_gpio_state_t gpio_state;
  lr20xx_hal_context_t *lr20xx_context;
  
  lr20xx_context = (lr20xx_hal_context_t *)radio;
  do
  {
    smtc_hal_mcu_gpio_get_state((lr20xx_context->busy).inst,&gpio_state);
  } while (gpio_state == SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return;
}



nvm_manager_status_type_t
nvm_manager_check_if_enough_free_space(smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t data_len)
{
  uint16_t data_len_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  uint16_t available_ids_num;
  uint16_t available_space;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  available_space = 0;
  available_ids_num = 0;
  status = nvm_manager_calc_free_space(nvm_instance,&available_space,&available_ids_num);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      if ((uint)available_space < data_len + 8)
      {
        status = NVM_MANAGER_INSUFFICIENT_SPACE_ERROR;
      }
      if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
         (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
      {
        if (status == NVM_MANAGER_OK)
        {
          if (available_ids_num == 0)
          {
            status = NVM_MANAGER_NO_MORE_IDS_ALLOWED_ERROR;
          }
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d",0x8033830,0x8038530,0x151,
                              (uint)status);
        }
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x8038530,0x14a,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_nvm_get_stored_data_size
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t *len,uint16_t *nb_files)
{
  nvm_manager_status_type_t nVar1;
  uint16_t *nb_files_local;
  uint32_t *len_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t memory_map_header;
  uint16_t found_nb_files;
  found_headers_with_addr_t found_headers_with_addr [64];
  nvm_manager_status_type_t status;
  uint16_t i;
  uint16_t occupied_space;
  
  memset(found_headers_with_addr,0xff,0x400);
  found_nb_files = 0;
  occupied_space = 0;
  nVar1 = nvm_manager_create_memory_map(nvm_instance,found_headers_with_addr,&found_nb_files);
  if ((nVar1 != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (nVar1 != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (nVar1 == NVM_MANAGER_OK)
    {
      for (i = 0; i < found_nb_files; i += 1)
      {
        if ((found_headers_with_addr[i].nvm_header.raw & 0x100000000) == 0)
        {
          memory_map_header.nvm_user_flash_header.len_in_bytes =
               (uint16_t)((uint)*(undefined4 *)&found_headers_with_addr[i].nvm_header >> 0x10);
          occupied_space += memory_map_header.nvm_user_flash_header.len_in_bytes;
        }
      }
      *len = (uint)occupied_space;
      *nb_files = found_nb_files;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x8038558,0x17f,(uint)nVar1);
    }
  }
  return nVar1;
}



nvm_manager_status_type_t
nvm_manager_nvm_read(smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint8_t *data,uint16_t *len)
{
  smtc_hal_mcu_status_t sVar1;
  uint16_t *len_local;
  uint8_t *data_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t data_header;
  uint32_t offset;
  uint16_t found_len;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  if (id == 0xffff)
  {
    status = NVM_MANAGER_READ_ERROR;
  }
  else
  {
    offset = 0;
    status = nvm_manager_find_file(nvm_instance,id,&offset);
    if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
       (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
    {
      if (status == NVM_MANAGER_OK)
      {
        data_header.raw._0_4_ = 0;
        data_header.raw._4_4_ = 0;
        status = nvm_manager_read_header(nvm_instance,offset,&data_header);
        if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
           (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
        {
          if (status == NVM_MANAGER_OK)
          {
            offset += 8;
            found_len = data_header.nvm_user_flash_header.len_in_bytes;
            sVar1 = smtc_hal_mcu_nvm_read
                              (nvm_instance,offset,data,
                               (uint)data_header.nvm_user_flash_header.len_in_bytes);
            if (sVar1 == SMTC_HAL_MCU_STATUS_OK)
            {
              status = nvm_manager_verify_checksum
                                 (data,found_len,data_header.nvm_user_flash_header.checksum);
              if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
                 (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
              {
                if (status == NVM_MANAGER_OK)
                {
                  *len = found_len;
                }
                else
                {
                  dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                      DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                      "In %s - %s (line %d): %d",0x8033830,0x8038580,0x1ae,
                                      (uint)status);
                }
              }
            }
            else
            {
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "HAL NVM read error : Offset = 0x%08X, found_len :%02X",offset,
                                  (uint)found_len);
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "In %s - %s (line %d): %d",0x8033830,0x8038580,0x1aa,3);
              status = NVM_MANAGER_READ_ERROR;
            }
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d",0x8033830,0x8038580,0x1a2,(uint)status);
          }
        }
      }
      else
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            false,"In %s - %s (line %d): %d",0x8033830,0x8038580,0x19d,(uint)status)
        ;
      }
    }
  }
  return status;
}



nvm_manager_status_type_t nvm_manager_nvm_factory_reset(smtc_hal_mcu_nvm_inst_t nvm_instance)
{
  smtc_hal_mcu_status_t sVar1;
  uint32_t length;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  length = nvm_manager_get_nvm_user_size(nvm_instance);
  sVar1 = smtc_hal_mcu_nvm_erase(nvm_instance,0,length);
  if (sVar1 != SMTC_HAL_MCU_STATUS_OK)
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                        "In %s - %s (line %d): %d",0x8033830,0x8038598,0x1ba,1);
  }
  return sVar1 != SMTC_HAL_MCU_STATUS_OK;
}



uint32_t nvm_manager_get_nvm_user_size(smtc_hal_mcu_nvm_inst_t nvm_instance)
{
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  return nvm_instance->end_address - nvm_instance->start_address;
}



nvm_manager_status_type_t
nvm_manager_nvm_replace(smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint8_t *data,uint16_t len)
{
  nvm_manager_status_type_t nVar1;
  uint8_t *data_local;
  uint16_t len_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  nVar1 = nvm_manager_nvm_write_replace(nvm_instance,id,data,len,true);
  return nVar1;
}



nvm_manager_status_type_t
nvm_manager_nvm_write(smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint8_t *data,uint16_t len)
{
  nvm_manager_status_type_t nVar1;
  uint8_t *data_local;
  uint16_t len_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  nVar1 = nvm_manager_nvm_write_replace(nvm_instance,id,data,len,false);
  return nVar1;
}



nvm_manager_status_type_t
nvm_manager_nvm_write_replace
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint8_t *data,uint16_t len,_Bool replace
          )
{
  _Bool _Var1;
  smtc_hal_mcu_status_t sVar2;
  uint8_t *data_local;
  uint16_t len_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  uint32_t next_file_addr;
  nvm_header_t header;
  nvm_header_t temp_header;
  uint32_t offset;
  uint16_t checksum;
  _Bool need_new_space;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  offset = 0;
  temp_header.raw._0_4_ = 0;
  temp_header.raw._4_4_ = 0;
  need_new_space = false;
  if (id == 0xffff)
  {
    status = NVM_MANAGER_INVALID_ID_ERROR;
  }
  if (0x800 < len)
  {
    status = NVM_MANAGER_WRITE_LEN_ERROR;
  }
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      header.nvm_user_flash_header.checksum = nvm_manager_calc_chksum(data,(uint)len);
      header.nvm_user_flash_header.flags = (anon_union_2_2_5f0640ad_for_flags)0x0;
      header.nvm_user_flash_header.id = id;
      header.nvm_user_flash_header.len_in_bytes = len;
      checksum = header.nvm_user_flash_header.checksum;
      if (replace)
      {
        status = nvm_manager_find_file(nvm_instance,id,&offset);
        if (status == NVM_MANAGER_OK)
        {
          status = nvm_manager_read_header(nvm_instance,offset,&temp_header);
          if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
          {
            return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
          }
          if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
          {
            return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
          }
          if (status != NVM_MANAGER_OK)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d",0x8033830,0x80385b8,499,(uint)status);
            return status;
          }
          if (temp_header.nvm_user_flash_header.len_in_bytes < len)
          {
            status = nvm_manager_get_next_file_relative_addr
                               (nvm_instance,
                                offset + temp_header.nvm_user_flash_header.len_in_bytes + 8,
                                &next_file_addr);
            if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
            {
              return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
            }
            if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
            {
              return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
            }
            if (status != NVM_MANAGER_OK)
            {
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "In %s - %s (line %d): %d",0x8033830,0x80385b8,0x1ff,(uint)status)
              ;
              return status;
            }
            if (next_file_addr <
                offset + ((uint)len - (uint)temp_header.nvm_user_flash_header.len_in_bytes) + 8)
            {
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "offset = 0x%08X, len to write = %08X, existing len %08X next file addr = %08X"
                                  ,offset,(uint)len,
                                  (uint)temp_header.nvm_user_flash_header.len_in_bytes,
                                  next_file_addr);
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "In %s - %s (line %d): %d",0x8033830,0x80385b8,0x209,9);
              return NVM_MANAGER_INSUFFICIENT_SPACE_ERROR;
            }
          }
          status = NVM_MANAGER_OK;
          status = nvm_manager_delete_nvm_page_if_not_empty(nvm_instance,offset);
          if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
          {
            return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
          }
          if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
          {
            return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
          }
          if (status != NVM_MANAGER_OK)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d",0x8033830,0x80385b8,0x20e,(uint)status);
            return status;
          }
        }
        else if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
        {
          need_new_space = true;
        }
      }
      else
      {
        _Var1 = nvm_manager_check_for_data_already_stored(nvm_instance,id,data,len);
        if (_Var1)
        {
          return NVM_MANAGER_ALREADY_PRESENT_INFO;
        }
        need_new_space = true;
      }
      if (need_new_space != false)
      {
        status = nvm_manager_check_if_enough_free_space(nvm_instance,len);
        if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
        {
          return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
        }
        if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
        {
          return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
        }
        if (status != NVM_MANAGER_OK)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d",0x8033830,0x80385b8,0x221,
                              (uint)status);
          return status;
        }
        status = nvm_manager_check_if_enough_trail_space(nvm_instance,len);
        if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
        {
          status = nvm_manager_nvm_defrag(nvm_instance);
          if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
          {
            return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
          }
          if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
          {
            return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
          }
          if (status != NVM_MANAGER_OK)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d",0x8033830,0x80385b8,0x228,(uint)status);
            return status;
          }
        }
        status = nvm_manager_get_first_available_relative_addr(nvm_instance,&offset);
        if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
        {
          return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
        }
        if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
        {
          return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
        }
        if (status != NVM_MANAGER_OK)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d",0x8033830,0x80385b8,0x22c,
                              (uint)status);
          return status;
        }
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__INFO,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false
                          ,"Trying to write : 0x%08X byte in file ID %08X at offset %08X",len + 8,
                          (uint)id,offset);
      status = nvm_manager_write_header(nvm_instance,&header,offset);
      if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
         (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
      {
        if (status == NVM_MANAGER_OK)
        {
          offset += 8;
          sVar2 = smtc_hal_mcu_nvm_write(nvm_instance,offset,data,(uint)len);
          if (sVar2 != SMTC_HAL_MCU_STATUS_OK)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d",0x8033830,0x80385b8,0x239,2);
            status = NVM_MANAGER_WRITE_ERROR;
          }
        }
        else
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d",0x8033830,0x80385b8,0x233,
                              (uint)status);
        }
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x80385b8,0x1e1,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_find_file(smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint32_t *offset)
{
  nvm_manager_status_type_t nVar1;
  uint32_t *offset_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t temp_header;
  
  temp_header.raw._0_4_ = 0;
  temp_header.raw._4_4_ = 0;
  nVar1 = nvm_manager_get_file(nvm_instance,id,offset,&temp_header);
  return nVar1;
}



nvm_manager_status_type_t
nvm_manager_nvm_init(smtc_hal_mcu_nvm_inst_t *nvm_instance,uint32_t start_addr,uint32_t end_addr)
{
  smtc_hal_mcu_status_t sVar1;
  uint32_t end_addr_local;
  uint32_t start_addr_local;
  smtc_hal_mcu_nvm_inst_t *nvm_instance_local;
  
  sVar1 = smtc_hal_mcu_nvm_init(start_addr,end_addr,nvm_instance);
  return sVar1 != SMTC_HAL_MCU_STATUS_OK;
}



uint16_t nvm_manager_calc_chksum(uint8_t *buf,uint32_t len)
{
  uint32_t len_local;
  uint8_t *buf_local;
  uint32_t i;
  uint16_t checksum;
  
  checksum = 0;
  buf_local = buf;
  for (i = 0; i < len; i += 1)
  {
    checksum += (ushort)*buf_local * (short)i;
    buf_local = buf_local + 1;
  }
  return checksum;
}



nvm_manager_status_type_t
nvm_manager_write_header(smtc_hal_mcu_nvm_inst_t nvm_instance,nvm_header_t *header,uint32_t offset)
{
  smtc_hal_mcu_status_t sVar1;
  nvm_manager_status_type_t nVar2;
  uint32_t offset_local;
  nvm_header_t *header_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  sVar1 = smtc_hal_mcu_nvm_write(nvm_instance,offset,(uint8_t *)&header->raw,8);
  if (sVar1 == SMTC_HAL_MCU_STATUS_OK)
  {
    nVar2 = NVM_MANAGER_OK;
  }
  else
  {
    dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                        "In %s - %s (line %d): %d",0x8033830,0x80385d8,0x28e,2);
    nVar2 = NVM_MANAGER_WRITE_ERROR;
  }
  return nVar2;
}



nvm_manager_status_type_t
nvm_manager_check_if_enough_trail_space(smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t len)
{
  uint16_t len_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  uint32_t trail_bytes_left;
  nvm_manager_status_type_t status;
  
  trail_bytes_left = 0;
  status = NVM_MANAGER_OK;
  status = nvm_manager_get_trail_space_left(nvm_instance,&trail_bytes_left);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      if (trail_bytes_left < len)
      {
        status = NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x80385f4,0x29a,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_get_trail_space_left(smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t *free_bytes_num)
{
  uint32_t uVar1;
  uint32_t *free_bytes_num_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  uint32_t offset;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  offset = 0;
  status = nvm_manager_get_first_available_relative_addr(nvm_instance,&offset);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      uVar1 = nvm_manager_get_nvm_user_size(nvm_instance);
      if (offset < uVar1)
      {
        uVar1 = nvm_manager_get_nvm_user_size(nvm_instance);
        *free_bytes_num = uVar1 - offset;
      }
      else
      {
        *free_bytes_num = 0;
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__DEBUG,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Trail size left in NVM : %08X",*free_bytes_num);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x803861c,0x2aa,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_calc_free_space
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t *free_space,uint16_t *available_ids_num)
{
  nvm_manager_status_type_t nVar1;
  uint32_t uVar2;
  uint16_t *available_ids_num_local;
  uint16_t *free_space_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t memory_map_header;
  uint16_t len;
  found_headers_with_addr_t found_headers_with_addr [64];
  nvm_manager_status_type_t status;
  uint16_t i;
  uint16_t used_ids;
  uint16_t occupied_space;
  
  memset(found_headers_with_addr,0xff,0x400);
  len = 0;
  occupied_space = 0;
  used_ids = 0;
  nVar1 = nvm_manager_create_memory_map(nvm_instance,found_headers_with_addr,&len);
  if ((nVar1 != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (nVar1 != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (nVar1 == NVM_MANAGER_OK)
    {
      for (i = 0; i < len; i += 1)
      {
        if ((found_headers_with_addr[i].nvm_header.raw & 0x100000000) == 0)
        {
          memory_map_header.nvm_user_flash_header.len_in_bytes =
               (uint16_t)((uint)*(undefined4 *)&found_headers_with_addr[i].nvm_header >> 0x10);
          uVar2 = nvm_manager_right_align_addr
                            ((uint)(ushort)(occupied_space +
                                            memory_map_header.nvm_user_flash_header.len_in_bytes + 8
                                           ));
          occupied_space = (uint16_t)uVar2;
          used_ids += 1;
        }
      }
      *available_ids_num = 0x40 - used_ids;
      uVar2 = nvm_manager_get_nvm_user_size(nvm_instance);
      *free_space = (short)uVar2 - occupied_space;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__DEBUG,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"Computed free space in NVM : %08X",(uint)*free_space);
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x8038640,0x2c4,(uint)nVar1);
    }
  }
  return nVar1;
}



nvm_manager_status_type_t nvm_manager_nvm_defrag(smtc_hal_mcu_nvm_inst_t nvm_instance)
{
  undefined2 uVar1;
  nvm_manager_status_type_t nVar2;
  smtc_hal_mcu_status_t sVar3;
  uint32_t uVar4;
  undefined4 uVar5;
  uint8_t auStack_1c50 [2048];
  undefined1 auStack_1450 [4080];
  undefined4 local_460;
  undefined4 local_45c;
  undefined4 local_458;
  uint local_454;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t memory_map_header;
  uint16_t len;
  found_headers_with_addr_t found_headers_with_addr [64];
  uint16_t data_len;
  uint32_t data_offset;
  uint32_t nvm_size;
  uint8_t_0_ *flash_dump;
  uint32_t flash_dump_size;
  uint16_t i;
  uint32_t nvm_offset;
  uint16_t flash_dump_index;
  nvm_manager_status_type_t status;
  
  nvm_instance_local = nvm_instance;
  memset(found_headers_with_addr,0xff,0x400);
  len = 0;
  flash_dump_index = 0;
  nvm_offset = 0;
  nVar2 = nvm_manager_create_memory_map(nvm_instance_local,found_headers_with_addr,&len);
  if ((nVar2 != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (nVar2 != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (nVar2 == NVM_MANAGER_OK)
    {
      memset(auStack_1c50,0,0x1800);
      for (i = 0; i < len; i += 1)
      {
        uVar5 = *(undefined4 *)&found_headers_with_addr[i].nvm_header;
        memory_map_header.raw._4_4_ = *(uint *)((int)&found_headers_with_addr[i].nvm_header + 4);
        memory_map_header.raw._0_4_ = uVar5;
        if ((memory_map_header.raw._4_4_ & 1) == 0)
        {
          uVar4 = found_headers_with_addr[i].header_offset;
          memory_map_header.nvm_user_flash_header.len_in_bytes = (uint16_t)((uint)uVar5 >> 0x10);
          uVar1 = memory_map_header.nvm_user_flash_header.len_in_bytes;
          memcpy(auStack_1c50 + flash_dump_index,&memory_map_header,8);
          sVar3 = smtc_hal_mcu_nvm_read
                            (nvm_instance_local,uVar4 + 8,
                             auStack_1c50 + (ushort)(flash_dump_index + 8),(uint)(ushort)uVar1);
          if (sVar3 != SMTC_HAL_MCU_STATUS_OK)
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d");
            return NVM_MANAGER_READ_ERROR;
          }
          uVar4 = nvm_manager_right_align_addr((uint)(ushort)(uVar1 + flash_dump_index + 8));
          flash_dump_index = (uint16_t)uVar4;
          if (0x7ff < flash_dump_index)
          {
            nVar2 = nvm_manager_delete_nvm_page_if_not_empty(nvm_instance_local,nvm_offset);
            if (nVar2 == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
            {
              return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
            }
            if (nVar2 == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
            {
              return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
            }
            if (nVar2 != NVM_MANAGER_OK)
            {
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "In %s - %s (line %d): %d");
              return nVar2;
            }
            sVar3 = smtc_hal_mcu_nvm_write(nvm_instance_local,nvm_offset,auStack_1c50,0x800);
            if (sVar3 != SMTC_HAL_MCU_STATUS_OK)
            {
              dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                  DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                  "In %s - %s (line %d): %d");
              return NVM_MANAGER_WRITE_ERROR;
            }
            memmove(auStack_1c50,auStack_1450,0x1000);
            flash_dump_index -= 0x800;
            nvm_offset += 0x800;
            memset(auStack_1c50 + flash_dump_index,0,0x1800 - flash_dump_index);
          }
        }
      }
      if (flash_dump_index != 0)
      {
        nVar2 = nvm_manager_delete_nvm_page_if_not_empty(nvm_instance_local,nvm_offset);
        if (nVar2 == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
        {
          return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
        }
        if (nVar2 == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
        {
          return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
        }
        if (nVar2 != NVM_MANAGER_OK)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d");
          return nVar2;
        }
        sVar3 = smtc_hal_mcu_nvm_write
                          (nvm_instance_local,nvm_offset,auStack_1c50,(uint)flash_dump_index);
        if (sVar3 != SMTC_HAL_MCU_STATUS_OK)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d");
          return NVM_MANAGER_WRITE_ERROR;
        }
        nvm_offset += 0x800;
      }
      uVar4 = nvm_manager_get_nvm_user_size(nvm_instance_local);
      while( true )
      {
        if (uVar4 <= nvm_offset)
        {
          return NVM_MANAGER_OK;
        }
        nVar2 = nvm_manager_delete_nvm_page_if_not_empty(nvm_instance_local,nvm_offset);
        if (nVar2 == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
        {
          return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
        }
        if (nVar2 == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
        {
          return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
        }
        if (nVar2 != NVM_MANAGER_OK) break;
        nvm_offset += 0x800;
      }
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d");
    }
    else
    {
      local_454 = (uint)nVar2;
      local_458 = 0x2e6;
      local_45c = 0x803865c;
      local_460 = 0x8033830;
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d");
    }
  }
  return nVar2;
}



nvm_manager_status_type_t
nvm_manager_delete_nvm_page_if_not_empty(smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t page_offset)
{
  smtc_hal_mcu_status_t sVar1;
  uint32_t page_offset_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  _Bool is_page_empty;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  is_page_empty = false;
  status = nvm_manager_is_nvm_page_empty(nvm_instance,page_offset,&is_page_empty);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      if ((is_page_empty != true) &&
         (sVar1 = smtc_hal_mcu_nvm_erase(nvm_instance,page_offset,0x7ff),
         sVar1 != SMTC_HAL_MCU_STATUS_OK))
      {
        dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                            false,"In %s - %s (line %d): %d",0x8033830,0x8038674,0x340,1);
        status = NVM_MANAGER_ERROR;
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x8038674,0x33a,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_is_nvm_page_empty
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t page_offset,_Bool *is_page_empty)
{
  undefined1 uVar1;
  bool bVar2;
  _Bool *is_page_empty_local;
  uint32_t page_offset_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t header;
  nvm_manager_status_type_t status;
  
  status = nvm_manager_read_header(nvm_instance,page_offset,&header);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      bVar2 = header.nvm_user_flash_header.id == 0xffff;
      if (bVar2)
      {
        header.nvm_user_flash_header.id = 1;
      }
      uVar1 = (undefined1)header.nvm_user_flash_header.id;
      if (!bVar2)
      {
        uVar1 = false;
      }
      *is_page_empty = (_Bool)uVar1;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x80386a0,0x34b,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_create_memory_map
          (smtc_hal_mcu_nvm_inst_t nvm_instance,found_headers_with_addr_t *found_headers_with_addr,
          uint16_t *len)
{
  _Bool _Var1;
  uint16_t *len_local;
  found_headers_with_addr_t *found_headers_with_addr_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  _Bool new_unique_stored;
  nvm_header_t temp_header;
  nvm_manager_status_type_t status;
  uint16_t found_addresses_len;
  uint32_t temp_offset;
  
  status = NVM_MANAGER_OK;
  temp_offset = 0;
  temp_header.raw._0_4_ = 0;
  temp_header.raw._4_4_ = 0;
  found_addresses_len = 0;
  status = nvm_manager_read_header(nvm_instance,0,&temp_header);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      do
      {
        if ((temp_header.nvm_user_flash_header.id == 0xffff) ||
           (_Var1 = nvm_manager_is_offset_within_bounds(nvm_instance,temp_offset + 8), !_Var1))
        break;
        new_unique_stored = false;
        status = nvm_manager_store_found_header
                           (&temp_header,found_headers_with_addr,temp_offset,&new_unique_stored);
        if (status == NVM_MANAGER_DATA_NOT_FOUND_ERROR)
        {
          return NVM_MANAGER_DATA_NOT_FOUND_ERROR;
        }
        if (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR)
        {
          return NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
        }
        if (status != NVM_MANAGER_OK)
        {
          dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                              false,"In %s - %s (line %d): %d",0x8033830,0x80386c0,0x364,
                              (uint)status);
          return status;
        }
        if (new_unique_stored != false)
        {
          found_addresses_len += 1;
        }
        temp_offset = temp_offset + ((uint)temp_header.raw._0_4_ >> 0x10) + 8;
        temp_offset = nvm_manager_right_align_addr(temp_offset);
        status = nvm_manager_read_header(nvm_instance,temp_offset,&temp_header);
      } while (status == NVM_MANAGER_OK);
      *len = found_addresses_len;
      status = NVM_MANAGER_OK;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x80386c0,0x35c,(uint)status);
    }
  }
  return status;
}



nvm_manager_status_type_t
nvm_manager_get_next_file_relative_addr
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t start_addr,uint32_t *offset)
{
  _Bool _Var1;
  uint32_t *offset_local;
  uint32_t start_addr_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t temp_header;
  uint32_t temp_offset;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  temp_header.raw._0_4_ = 0;
  temp_header.raw._4_4_ = 0;
  temp_offset = start_addr;
  while (_Var1 = nvm_manager_is_offset_within_bounds(nvm_instance,temp_offset + 8), _Var1)
  {
    temp_offset = nvm_manager_right_align_addr(temp_offset);
    status = nvm_manager_read_header(nvm_instance,temp_offset,&temp_header);
    if ((status == NVM_MANAGER_OK) && (temp_header.nvm_user_flash_header.id != 0xffff)) break;
    temp_offset += 1;
  }
  *offset = temp_offset;
  dynamic_log_message(DEVICE_MESSAGE__LEVEL__SPECIAL,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                      "Next file relative address : %08X, ID : %08x - Status = %d",*offset,
                      temp_header.raw._0_4_ & 0xffff,(uint)status);
  return status;
}



nvm_manager_status_type_t
nvm_manager_store_found_header
          (nvm_header_t *nvm_header,found_headers_with_addr_t *found_headers_with_addr,
          uint32_t offset,_Bool *new_stored)
{
  uint16_t uVar1;
  undefined4 uVar2;
  _Bool *new_stored_local;
  uint32_t offset_local;
  found_headers_with_addr_t *found_headers_with_addr_local;
  nvm_header_t *nvm_header_local;
  uint16_t id_to_store;
  uint16_t id;
  uint16_t i;
  
  *new_stored = false;
  i = 0;
  found_headers_with_addr_local = found_headers_with_addr;
  while( true )
  {
    if (0x3f < i)
    {
      return NVM_MANAGER_ERROR;
    }
    uVar1 = (found_headers_with_addr_local->nvm_header).nvm_user_flash_header.id;
    if ((uVar1 == (nvm_header->nvm_user_flash_header).id) || (uVar1 == 0xffff)) break;
    i += 1;
    found_headers_with_addr_local = found_headers_with_addr_local + 1;
  }
  found_headers_with_addr_local->header_offset = offset;
  uVar2 = *(undefined4 *)&(nvm_header->nvm_user_flash_header).flags;
  *(undefined4 *)&found_headers_with_addr_local->nvm_header = *(undefined4 *)nvm_header;
  *(undefined4 *)((int)&found_headers_with_addr_local->nvm_header + 4) = uVar2;
  if (uVar1 == 0xffff)
  {
    *new_stored = true;
  }
  return NVM_MANAGER_OK;
}



nvm_manager_status_type_t
nvm_manager_verify_checksum(uint8_t *data,uint16_t len,uint16_t read_checksum)
{
  uint16_t uVar1;
  uint16_t read_checksum_local;
  uint16_t len_local;
  uint8_t *data_local;
  uint16_t calc_chksum;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  uVar1 = nvm_manager_calc_chksum(data,(uint)len);
  if (read_checksum != uVar1)
  {
    status = NVM_MANAGER_CHECKSUM_ERROR;
  }
  return status;
}



_Bool nvm_manager_is_offset_within_bounds(smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t offset)
{
  uint32_t uVar1;
  undefined1 uVar2;
  bool bVar3;
  uint32_t offset_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  uVar1 = nvm_manager_get_nvm_user_size(nvm_instance);
  bVar3 = offset < uVar1;
  if (bVar3)
  {
    offset = 1;
  }
  uVar2 = (undefined1)offset;
  if (!bVar3)
  {
    uVar2 = 0;
  }
  return (_Bool)uVar2;
}



nvm_manager_status_type_t
nvm_manager_get_first_available_relative_addr
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t *last_addr)
{
  _Bool _Var1;
  uint32_t *last_addr_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t header;
  uint32_t offset;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  offset = 0;
  header.raw._0_4_ = 0;
  header.raw._4_4_ = 0;
  status = nvm_manager_read_header(nvm_instance,0,&header);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      do
      {
        if (header.nvm_user_flash_header.id == 0xffff) break;
        offset = offset + ((uint)header.raw._0_4_ >> 0x10) + 8;
        offset = nvm_manager_right_align_addr(offset);
        status = nvm_manager_read_header(nvm_instance,offset,&header);
      } while (status == NVM_MANAGER_OK);
      _Var1 = nvm_manager_is_offset_within_bounds(nvm_instance,offset);
      if (!_Var1)
      {
        status = NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR;
      }
      *last_addr = offset;
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x80386e0,0x3c3,(uint)status);
    }
  }
  return status;
}



_Bool nvm_manager_check_for_data_already_stored
                (smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint8_t *data,uint16_t len)
{
  int iVar1;
  _Bool _Var2;
  uint8_t *data_local;
  uint16_t len_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  uint8_t read_buf [2048];
  uint16_t file_len;
  uint32_t offset;
  nvm_manager_status_type_t status;
  
  status = NVM_MANAGER_OK;
  offset = 0;
  file_len = 0;
  status = nvm_manager_find_file(nvm_instance,id,&offset);
  if (status == NVM_MANAGER_OK)
  {
    read_buf[0] = '\0';
    read_buf[1] = '\0';
    read_buf[2] = '\0';
    read_buf[3] = '\0';
    memset(read_buf + 4,0,0x7fc);
    status = nvm_manager_nvm_read(nvm_instance,id,read_buf,&file_len);
    if ((status == NVM_MANAGER_DATA_NOT_FOUND_ERROR) ||
       (status == NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
    {
      _Var2 = status != NVM_MANAGER_OK;
    }
    else if (status == NVM_MANAGER_OK)
    {
      if (len == file_len)
      {
        iVar1 = memcmp(data,read_buf,(uint)len);
        if (iVar1 == 0)
        {
          _Var2 = true;
        }
        else
        {
          _Var2 = false;
        }
      }
      else
      {
        _Var2 = false;
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x8038710,1000,(uint)status);
      _Var2 = status != NVM_MANAGER_OK;
    }
  }
  else
  {
    _Var2 = false;
  }
  return _Var2;
}



uint32_t nvm_manager_right_align_addr(uint32_t offset)
{
  uint32_t uVar1;
  uint32_t offset_local;
  
  uVar1 = nvm_manager_64bits_right_align_addr(offset);
  return uVar1;
}



uint32_t nvm_manager_64bits_right_align_addr(uint32_t offset)
{
  uint32_t offset_local;
  uint32_t addr_64bits_align;
  
  addr_64bits_align = offset;
  if ((offset & 7) != 0)
  {
    addr_64bits_align = (offset & 0xfffffff8) + 8;
  }
  return addr_64bits_align;
}



nvm_manager_status_type_t
nvm_manager_read_header(smtc_hal_mcu_nvm_inst_t nvm_instance,uint32_t offset,nvm_header_t *header)
{
  smtc_hal_mcu_status_t sVar1;
  nvm_manager_status_type_t nVar2;
  nvm_header_t *header_local;
  uint32_t offset_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  
  sVar1 = smtc_hal_mcu_nvm_read(nvm_instance,offset,(uint8_t *)&header->raw,8);
  if (sVar1 == SMTC_HAL_MCU_STATUS_OK)
  {
    nVar2 = NVM_MANAGER_OK;
  }
  else
  {
    nVar2 = NVM_MANAGER_READ_ERROR;
  }
  return nVar2;
}



nvm_manager_status_type_t
nvm_manager_get_file
          (smtc_hal_mcu_nvm_inst_t nvm_instance,uint16_t id,uint32_t *offset,nvm_header_t *header)
{
  uint32_t uVar1;
  nvm_header_t *header_local;
  uint32_t *offset_local;
  uint16_t id_local;
  smtc_hal_mcu_nvm_inst_t nvm_instance_local;
  nvm_header_t temp_header;
  nvm_manager_status_type_t status;
  uint32_t found_header_offset;
  _Bool data_found;
  uint32_t temp_offset;
  
  status = NVM_MANAGER_OK;
  temp_offset = 0;
  data_found = false;
  temp_header.raw._0_4_ = 0;
  temp_header.raw._4_4_ = 0;
  found_header_offset = 0;
  status = nvm_manager_read_header(nvm_instance,0,&temp_header);
  if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
     (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
  {
    if (status == NVM_MANAGER_OK)
    {
      do
      {
        if ((temp_header.nvm_user_flash_header.id == 0xffff) ||
           (uVar1 = nvm_manager_get_nvm_user_size(nvm_instance), uVar1 <= temp_offset)) break;
        if ((uint)id == (temp_header.raw._0_4_ & 0xffff))
        {
          if ((temp_header.raw._4_4_ & 1) == 0)
          {
            data_found = true;
            found_header_offset = temp_offset;
          }
          else
          {
            data_found = false;
          }
        }
        temp_offset = temp_offset + ((uint)temp_header.raw._0_4_ >> 0x10) + 8;
        temp_offset = nvm_manager_right_align_addr(temp_offset);
        status = nvm_manager_read_header(nvm_instance,temp_offset,&temp_header);
      } while (status == NVM_MANAGER_OK);
      if (data_found == true)
      {
        *offset = found_header_offset;
        status = nvm_manager_read_header(nvm_instance,found_header_offset,header);
        if ((status != NVM_MANAGER_DATA_NOT_FOUND_ERROR) &&
           (status != NVM_MANAGER_INSUFFICIENT_NVM_TRAIL_SPACE_ERROR))
        {
          if (status == NVM_MANAGER_OK)
          {
            status = NVM_MANAGER_OK;
          }
          else
          {
            dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,
                                DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,false,
                                "In %s - %s (line %d): %d",0x8033830,0x803873c,0x441,(uint)status);
          }
        }
      }
      else
      {
        status = NVM_MANAGER_DATA_NOT_FOUND_ERROR;
      }
    }
    else
    {
      dynamic_log_message(DEVICE_MESSAGE__LEVEL__ERROR,DEVICE_MESSAGE__LOG_SOURCE__DEMO_MANAGER,
                          false,"In %s - %s (line %d): %d",0x8033830,0x803873c,0x423,(uint)status);
    }
  }
  return status;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void smtc_display_init(void)
{
  ssd1306_send_command(0xae);
  ssd1306_send_command(0xd5);
  ssd1306_send_command(0xf0);
  ssd1306_send_command(0xa8);
  ssd1306_send_command('?');
  ssd1306_send_command(0xd3);
  ssd1306_send_command('\0');
  ssd1306_send_command(0x8d);
  ssd1306_send_command('\x14');
  ssd1306_send_command('@');
  ssd1306_send_command(' ');
  ssd1306_send_command('\0');
  ssd1306_send_command(0xa1);
  ssd1306_send_command(200);
  ssd1306_send_command(0xda);
  ssd1306_send_command('\x12');
  ssd1306_send_command(0x81);
  ssd1306_send_command(0xff);
  ssd1306_send_command(0xd9);
  ssd1306_send_command(0xf1);
  ssd1306_send_command(0xdb);
  ssd1306_send_command(' ');
  ssd1306_send_command(0xa4);
  ssd1306_send_command(0xa6);
  ssd1306_send_command('.');
  ssd1306_send_command(0xaf);
  smtc_display_goto_x_y(0,0);
  __GLCD.Mode = GLCD_Non_Inverted;
  __GLCD.Font.Lines = '\0';
  __GLCD.Font.Height = '\0';
  __GLCD.Font.Width = '\0';
  __GLCD.y = '\0';
  __GLCD.x = '\0';
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void smtc_display_render(void)
{
  uint8_t loop;
  uint8_t i;
  
  ssd1306_send_command('!');
  ssd1306_send_command('\0');
  ssd1306_send_command('\x7f');
  ssd1306_send_command('\"');
  ssd1306_send_command('\0');
  ssd1306_send_command('\a');
  for (i = '\0'; i < 0x40; i += '\x01')
  {
    ssd1306_send('@',__GLCD_Buffer + (uint)i * 0x10,'\x10');
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void smtc_display_clear(void)
{
  smtc_display_fill_screen(0);
  return;
}



void smtc_display_set_x(uint16_t x)
{
  uint16_t x_local;
  
  if (x < 0x80)
  {
    __GLCD.x = (uint8_t)x;
  }
  return;
}



void smtc_display_set_y(uint16_t y)
{
  uint16_t y_local;
  
  if (y < 0x40)
  {
    __GLCD.y = (uint8_t)y;
  }
  return;
}



void smtc_display_goto_x_y(uint16_t x,uint16_t y)
{
  uint16_t y_local;
  uint16_t x_local;
  
  smtc_display_set_x(x);
  smtc_display_set_y(y);
  return;
}



// WARNING: Unknown calling convention

uint8_t GLCD_GetX(void)
{
  return __GLCD.x;
}



void smtc_display_set_pixels(uint16_t x1,uint16_t y1,uint16_t x2,uint16_t y2,uint32_t color)
{
  byte bVar1;
  byte bVar2;
  uint8_t uVar3;
  byte bVar4;
  byte bVar5;
  uint16_t y2_local;
  uint16_t x2_local;
  uint16_t y1_local;
  uint16_t x1_local;
  uint8_t data;
  uint8_t offset;
  uint8_t width;
  uint8_t height;
  uint8_t i;
  uint8_t h;
  uint8_t mask;
  
  if ((((x1 < 0x80) && (x2 < 0x80)) && (y1 < 0x40)) && (y2 < 0x40))
  {
    bVar1 = ((char)y2 - (byte)y1) + 1;
    bVar2 = ((char)x2 - (char)x1) + 1;
    bVar5 = (byte)y1 & 7;
    y1_local = y1 - bVar5;
    mask = 0xff;
    if ((int)(uint)bVar1 < (int)(8 - (uint)bVar5))
    {
      mask = (uint8_t)(0xff >> (8 - bVar1 & 0xff));
      h = bVar1;
    }
    else
    {
      h = '\b' - bVar5;
    }
    smtc_display_goto_x_y(x1,y1_local);
    for (i = '\0'; i < bVar2; i += '\x01')
    {
      bVar4 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
      uVar3 = __GLCD.x;
      if (color == 0xff)
      {
        bVar4 = mask << bVar5 | bVar4;
      }
      else
      {
        bVar4 &= ~(mask << bVar5);
      }
      __GLCD.x += '\x01';
      ssd1306_buffer_write(uVar3,__GLCD.y,bVar4);
    }
    while (h + 7 < (uint)bVar1)
    {
      h += '\b';
      y1_local += 8;
      smtc_display_goto_x_y(x1,y1_local);
      for (i = '\0'; uVar3 = __GLCD.x, i < bVar2; i += '\x01')
      {
        __GLCD.x += '\x01';
        ssd1306_buffer_write(uVar3,__GLCD.y,(uint8_t)color);
      }
    }
    if (h < bVar1)
    {
      bVar1 = (byte)(0xff << ((uint)bVar1 - (uint)h & 0xff));
      smtc_display_goto_x_y(x1,y1_local + 8);
      for (i = '\0'; i < bVar2; i += '\x01')
      {
        bVar5 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
        uVar3 = __GLCD.x;
        if (color == 0xff)
        {
          bVar5 = ~bVar1 | bVar5;
        }
        else
        {
          bVar5 &= bVar1;
        }
        __GLCD.x += '\x01';
        ssd1306_buffer_write(uVar3,__GLCD.y,bVar5);
      }
    }
  }
  return;
}



void smtc_display_draw_bitmap(uint8_t *bitmap,uint8_t Width,uint8_t Height,void *app_params)
{
  char cVar1;
  uint8_t uVar2;
  uint8_t x_00;
  uint8_t uVar3;
  char cVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  int iVar8;
  uint uVar9;
  void *app_params_local;
  uint8_t Height_local;
  uint8_t Width_local;
  uint8_t *bitmap_local;
  uint8_t y2;
  uint8_t x;
  uint8_t overflow;
  uint8_t dataPrev;
  PrintMode_t Mode;
  uint8_t data;
  uint8_t j;
  uint8_t i;
  uint8_t y;
  uint16_t bmpReadPrev;
  uint16_t bmpRead;
  uint16_t lines;
  
  uVar3 = __GLCD.y;
  uVar2 = __GLCD.x;
                    // WARNING: Load size is inaccurate
  cVar1 = *app_params;
  y = __GLCD.y;
  Width_local = Width;
  if ((char)(Width + __GLCD.x) < '\0')
  {
    Width_local = (Width - (Width + __GLCD.x)) + 0x80;
  }
  iVar8 = Height + 7;
  if (false)
  {
    iVar8 = Height + 0xe;
  }
  lines = (uint16_t)(iVar8 >> 3);
  bVar7 = (char)(iVar8 >> 3) + (__GLCD.y >> 3);
  if (8 < bVar7)
  {
    lines = (lines - bVar7) + 8;
  }
  bVar7 = __GLCD.y & 7;
  for (j = '\0'; j < lines; j += '\x01')
  {
    smtc_display_goto_x_y((ushort)uVar2,(ushort)y);
    bmpRead = (ushort)j * (ushort)Width_local;
    bmpReadPrev = bmpRead - Width_local;
    for (i = '\0'; i < Width_local; i += '\x01')
    {
      uVar9 = (uint)bmpRead;
      bmpRead += 1;
      cVar4 = pgm_read_byte((char *)(bitmap + uVar9));
      data = cVar4 << bVar7;
      if (j != '\0')
      {
        uVar9 = (uint)bmpReadPrev;
        bmpReadPrev += 1;
        bVar5 = pgm_read_byte((char *)(bitmap + uVar9));
        data = (byte)((int)(uint)bVar5 >> (8 - bVar7 & 0xff)) | data;
      }
      if (cVar1 == '\x01')
      {
        bVar5 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
        data |= bVar5;
      }
      x_00 = __GLCD.x;
      __GLCD.x += '\x01';
      ssd1306_buffer_write(x_00,__GLCD.y,data);
    }
    if (__GLCD.Font.Mode == GLCD_Overwrite)
    {
      data = '\0';
    }
    else
    {
      data = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
    }
    ssd1306_buffer_write(__GLCD.x,__GLCD.y,data);
    y += '\b';
  }
  iVar8 = (uint)Height + (uint)uVar3 + -1;
  if (iVar8 < 0)
  {
    iVar8 = (uint)Height + (uint)uVar3 + 6;
  }
  if (((uint)(uVar3 >> 3) != iVar8 >> 3) && (y < 0x40))
  {
    smtc_display_goto_x_y((ushort)uVar2,(ushort)y);
    bmpReadPrev = (j - 1) * (ushort)Width_local;
    for (i = '\0'; i < Width_local; i += '\x01')
    {
      bVar5 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
      uVar9 = (uint)bmpReadPrev;
      bmpReadPrev += 1;
      bVar6 = pgm_read_byte((char *)(bitmap + uVar9));
      data = (byte)((int)(uint)bVar6 >> (8 - bVar7 & 0xff)) | bVar5;
      if (cVar1 == '\x01')
      {
        bVar5 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
        data |= bVar5;
      }
      uVar2 = __GLCD.x;
      __GLCD.x += '\x01';
      ssd1306_buffer_write(uVar2,__GLCD.y,data);
    }
    if (__GLCD.Font.Mode == GLCD_Overwrite)
    {
      data = '\0';
    }
    else if (__GLCD.Font.Mode == GLCD_Merge)
    {
      data = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
    }
    else
    {
      bVar7 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
      data = ~bVar7;
    }
    uVar2 = __GLCD.x;
    __GLCD.x += '\x01';
    ssd1306_buffer_write(uVar2,__GLCD.y,data);
  }
  bVar7 = GLCD_GetX();
  smtc_display_goto_x_y((ushort)bVar7,(ushort)uVar3);
  return;
}



void smtc_display_fill_screen(uint16_t color)
{
  uint16_t color_local;
  Color_t color_type;
  uint8_t j;
  uint8_t i;
  
  for (j = '\0'; j < 0x40; j += '\b')
  {
    for (i = '\0'; -1 < (char)i; i += '\x01')
    {
      ssd1306_buffer_write(i,j,(uint8_t)color);
    }
  }
  return;
}



void smtc_display_draw_filled_rectangle
               (uint16_t x1,uint16_t y1,uint16_t x2,uint16_t y2,uint32_t color)
{
  uint16_t y2_local;
  uint16_t x2_local;
  uint16_t y1_local;
  uint16_t x1_local;
  
  smtc_display_set_pixels(x1,y1,x2,y2,color);
  return;
}



void smtc_display_set_font(uint8_t *name,uint8_t width,uint8_t height,void *app_params)
{
  int iVar1;
  void *app_params_local;
  uint8_t height_local;
  uint8_t width_local;
  uint8_t *name_local;
  PrintMode_t *mode;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if (((-1 < (char)width) && (height < 0x40)) && ((*app_params == '\0' || (*app_params == '\x01'))))
  {
    iVar1 = height - 1;
    if (iVar1 < 0)
    {
      iVar1 = height + 6;
    }
    __GLCD.Font.Lines = (char)(iVar1 >> 3) + '\x01';
                    // WARNING: Load size is inaccurate
    __GLCD.Font.Mode = *app_params;
    __GLCD.Font.Name = name;
    __GLCD.Font.Width = width;
    __GLCD.Font.Height = height;
  }
  return;
}



void GLCD_PrintChar(char character)
{
  ushort uVar1;
  short sVar2;
  uint8_t uVar3;
  uint8_t uVar4;
  uint8_t uVar5;
  byte bVar6;
  char cVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  int iVar11;
  char character_local;
  uint16_t fontStart;
  uint8_t x;
  uint8_t y2;
  uint8_t width;
  uint8_t overflow;
  uint8_t dataPrev;
  uint8_t data;
  uint8_t j;
  uint8_t i;
  uint8_t y;
  uint16_t fontReadPrev;
  uint16_t fontRead;
  
  uVar5 = __GLCD.y;
  uVar3 = __GLCD.x;
  y = __GLCD.y;
  uVar1 = (ushort)(byte)(character - 0x20) *
          ((ushort)__GLCD.Font.Lines * (ushort)__GLCD.Font.Width + 1);
  sVar2 = uVar1 + 1;
  bVar6 = pgm_read_byte((char *)(__GLCD.Font.Name + uVar1));
  bVar10 = __GLCD.y & 7;
  for (j = '\0'; j < __GLCD.Font.Lines; j += '\x01')
  {
    smtc_display_goto_x_y((ushort)uVar3,(ushort)y);
    fontRead = sVar2 + (ushort)j;
    fontReadPrev = fontRead - 1;
    for (i = '\0'; i < bVar6; i += '\x01')
    {
      cVar7 = pgm_read_byte((char *)(__GLCD.Font.Name + fontRead));
      data = cVar7 << bVar10;
      if (j != '\0')
      {
        bVar8 = pgm_read_byte((char *)(__GLCD.Font.Name + fontReadPrev));
        data = (byte)((int)(uint)bVar8 >> (8 - bVar10 & 0xff)) | data;
        fontReadPrev += __GLCD.Font.Lines;
      }
      if (__GLCD.Font.Mode == GLCD_Merge)
      {
        bVar8 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
        data |= bVar8;
      }
      uVar4 = __GLCD.x;
      __GLCD.x += '\x01';
      ssd1306_buffer_write(uVar4,__GLCD.y,data);
      fontRead += __GLCD.Font.Lines;
    }
    if (__GLCD.Font.Mode == GLCD_Overwrite)
    {
      ssd1306_buffer_write(__GLCD.x,__GLCD.y,'\0');
    }
    y += '\b';
  }
  iVar11 = (uint)uVar5 + (uint)__GLCD.Font.Height + -1;
  if (iVar11 < 0)
  {
    iVar11 = (uint)uVar5 + (uint)__GLCD.Font.Height + 6;
  }
  if (((uint)(uVar5 >> 3) != iVar11 >> 3) && (y < 0x40))
  {
    smtc_display_goto_x_y((ushort)uVar3,(ushort)y);
    fontReadPrev = (sVar2 + (ushort)j) - 1;
    for (i = '\0'; i < bVar6; i += '\x01')
    {
      bVar8 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
      bVar9 = pgm_read_byte((char *)(__GLCD.Font.Name + fontReadPrev));
      data = (byte)((int)(uint)bVar9 >> (8 - bVar10 & 0xff)) | bVar8;
      if (__GLCD.Font.Mode == GLCD_Merge)
      {
        bVar8 = ssd1306_buffer_read(__GLCD.x,__GLCD.y);
        data |= bVar8;
      }
      uVar4 = __GLCD.x;
      __GLCD.x += '\x01';
      ssd1306_buffer_write(uVar4,__GLCD.y,data);
      fontReadPrev += __GLCD.Font.Lines;
    }
    if (__GLCD.Font.Mode == GLCD_Overwrite)
    {
      ssd1306_buffer_write(__GLCD.x,__GLCD.y,'\0');
    }
  }
  smtc_display_goto_x_y((ushort)bVar6 + (ushort)uVar3 + 1,(ushort)uVar5);
  return;
}



void smtc_display_print_format_string(uint16_t x,uint16_t y,char *format,...)
{
  undefined4 in_r3;
  uint16_t y_local;
  uint16_t x_local;
  va_list p;
  char buffer [256];
  char *format_local;
  undefined4 uStack_4;
  
  uStack_4 = in_r3;
  smtc_display_goto_x_y(x,y);
  vsprintf(buffer,format,&uStack_4);
  ssd1306_print_string(buffer);
  return;
}



void ssd1306_print_string(char *text)
{
  char *text_local;
  
  text_local = text;
  while ((*text_local != '\0' && ((uint)__GLCD.Font.Width + (uint)__GLCD.x < 0x80)))
  {
    GLCD_PrintChar(*text_local);
    text_local = text_local + 1;
  }
  return;
}



char pgm_read_byte(char *address)
{
  char *address_local;
  
  return *address;
}



void ssd1306_send(uint8_t control,uint8_t *data,uint8_t length)
{
  uint8_t *data_local;
  uint8_t length_local;
  uint8_t control_local;
  uint8_t tx_buf [50];
  
  tx_buf[0] = control;
  memcpy(tx_buf + 1,data,(uint)length);
  smtc_display_write(0x78,tx_buf,length + 1);
  return;
}



void ssd1306_buffer_write(uint8_t x,uint8_t y,uint8_t data)
{
  uint8_t data_local;
  uint8_t y_local;
  uint8_t x_local;
  
  __GLCD_Buffer[(uint)(y >> 3) * 0x80 + (uint)x] = data;
  return;
}



uint8_t ssd1306_buffer_read(uint8_t x,uint8_t y)
{
  uint8_t y_local;
  uint8_t x_local;
  
  return __GLCD_Buffer[(uint)(y >> 3) * 0x80 + (uint)x];
}



void ssd1306_send_command(uint8_t command)
{
  uint8_t command_local;
  
  command_local = command;
  ssd1306_send('\0',&command_local,'\x01');
  return;
}



void support_spi_init(smtc_hal_mcu_spi_inst_t *spi_com_instance,
                     smtc_shield_lr20xx_pinout_t *shield_pinout)
{
  smtc_shield_lr20xx_pinout_t *shield_pinout_local;
  smtc_hal_mcu_spi_inst_t *spi_com_instance_local;
  smtc_hal_mcu_spi_cfg_app_t app_cfg;
  smtc_hal_mcu_spi_cfg_s cfg;
  
  cfg.spi = (SPI_TypeDef *)&SPI1;
  app_cfg.is_master = true;
  smtc_hal_mcu_spi_init(&cfg,&app_cfg,spi_com_instance);
  return;
}



void support_i2c_init(smtc_hal_mcu_i2c_inst_t *i2c_com_instance)
{
  smtc_hal_mcu_status_t sVar1;
  smtc_hal_mcu_i2c_inst_t *i2c_com_instance_local;
  smtc_hal_mcu_i2c_cfg_s i2c_cfg;
  smtc_hal_mcu_status_t status;
  
  if (!is_i2c_cfg)
  {
    i2c_cfg.i2c = (I2C_TypeDef *)&I2C1;
    i2c_cfg.max_nacks_in_a_row = '\x03';
    i2c_cfg._5_3_ = 0;
    sVar1 = smtc_hal_mcu_i2c_init(&i2c_cfg,i2c_com_instance);
    if (sVar1 == SMTC_HAL_MCU_STATUS_OK)
    {
      is_i2c_cfg = true;
    }
  }
  return;
}



void support_i2c_deinit(smtc_hal_mcu_i2c_inst_t *i2c_com_instance)
{
  smtc_hal_mcu_i2c_inst_t *i2c_com_instance_local;
  
  smtc_hal_mcu_i2c_deinit(i2c_com_instance);
  is_i2c_cfg = false;
  return;
}



smtc_hal_mcu_status_t
support_uart_init(_func_void *callback_rx,_func_void *callback_tx,_func_void *callback_error_rx,
                 _func_void *callback_error_tx)
{
  smtc_hal_mcu_status_t sVar1;
  smtc_hal_mcu_uart_inst_t *inst;
  _func_void *callback_error_tx_local;
  _func_void *callback_error_rx_local;
  _func_void *callback_tx_local;
  _func_void *callback_rx_local;
  smtc_hal_mcu_uart_dma_cfg_app_s cfg_uart_dma_app;
  smtc_hal_mcu_uart_dma_cfg_s cfg_uart_dma;
  
  cfg_uart_dma.dma = (DMA_TypeDef *)&DMA1;
  cfg_uart_dma_app.baudrate = 0xe1000;
  cfg_uart_dma_app.callback_rx = callback_rx;
  cfg_uart_dma_app.callback_tx = callback_tx;
  cfg_uart_dma_app.callback_error_rx = callback_error_rx;
  cfg_uart_dma_app.callback_error_tx = callback_error_tx;
  inst = get_uart_instance();
  sVar1 = smtc_hal_mcu_uart_dma_init(&cfg_uart_dma,&cfg_uart_dma_app,inst);
  return sVar1;
}



smtc_hal_mcu_gpio_cfg_t smtc_shield_pinout_mapping_get_gpio_cfg(smtc_shield_pinout_t gpio)
{
  smtc_shield_pinout_t gpio_local;
  
  return arduino_mapping + gpio;
}



void board_init_leds(smtc_hal_mcu_gpio_inst_t *led_rx_inst,smtc_hal_mcu_gpio_inst_t *led_tx_inst)
{
  smtc_hal_mcu_gpio_inst_t *led_tx_inst_local;
  smtc_hal_mcu_gpio_inst_t *led_rx_inst_local;
  
  return;
}



void board_post_rx_led_trigger(smtc_hal_mcu_gpio_inst_t led_rx_inst)
{
  smtc_hal_mcu_gpio_inst_t led_rx_inst_local;
  
  smtc_hal_mcu_gpio_set_state(led_rx_inst,SMTC_HAL_MCU_GPIO_STATE_LOW);
  return;
}



void board_post_tx_led_trigger(smtc_hal_mcu_gpio_inst_t led_tx_inst)
{
  smtc_hal_mcu_gpio_inst_t led_tx_inst_local;
  
  smtc_hal_mcu_gpio_set_state(led_tx_inst,SMTC_HAL_MCU_GPIO_STATE_LOW);
  return;
}



void board_pre_rx_led_trigger(smtc_hal_mcu_gpio_inst_t led_rx_inst)
{
  smtc_hal_mcu_gpio_inst_t led_rx_inst_local;
  
  smtc_hal_mcu_gpio_set_state(led_rx_inst,SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return;
}



void board_pre_tx_led_trigger(smtc_hal_mcu_gpio_inst_t led_tx_inst)
{
  smtc_hal_mcu_gpio_inst_t led_tx_inst_local;
  
  smtc_hal_mcu_gpio_set_state(led_tx_inst,SMTC_HAL_MCU_GPIO_STATE_HIGH);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void LL_SYSTICK_EnableIT(void)
{
  _DAT_e000e010 = _DAT_e000e010 | 2;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void support_timing_init(void)
{
  LL_SYSTICK_EnableIT();
  return;
}



// WARNING: Unknown calling convention

uint32_t support_timing_get_time(void)
{
  uint32_t uVar1;
  
  uVar1 = system_time_GetTicker();
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void SysTick_Handler(void)
{
  system_time_IncreaseTicker();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void system_time_IncreaseTicker(void)
{
  ticker = ticker + 1;
  return;
}



// WARNING: Unknown calling convention

uint32_t system_time_GetTicker(void)
{
  return ticker;
}



void smtc_hal_button_init_user_btn(_func_void_void_ptr *callback,void *context)
{
  void *context_local;
  _func_void_void_ptr *callback_local;
  
  usr_btn.cfg = &usr_btn_cfg;
  usr_btn.cfg_input.pull_mode = SMTC_HAL_MCU_GPIO_PULL_MODE_NONE;
  usr_btn.cfg_input.irq_mode = SMTC_HAL_MCU_GPIO_IRQ_MODE_RISING;
  usr_btn.cfg_input.context = (void *)0x0;
  usr_btn.cfg_input.callback = callback;
  smtc_hal_mcu_gpio_init_input(&usr_btn_cfg,&usr_btn.cfg_input,&usr_btn.inst);
  smtc_hal_mcu_gpio_enable_irq(usr_btn.inst);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void user_button_enable(void)
{
  smtc_hal_mcu_gpio_enable_irq(usr_btn.inst);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void user_button_disable(void)
{
  smtc_hal_mcu_gpio_disable_irq(usr_btn.inst);
  return;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr11x0_common_get_xosc_cfg(void)
{
  return &smtc_shield_lr11x0_common_xosc_cfg;
}



_Bool smtc_shield_lr11x0_common_rttof_recommended_rx_tx_delay_indicator
                (uint32_t rf_freq_in_hz,lr11xx_radio_lora_bw_t bw,lr11xx_radio_lora_sf_t sf,
                uint32_t *delay_indicator)
{
  uint32_t *delay_indicator_local;
  lr11xx_radio_lora_sf_t sf_local;
  lr11xx_radio_lora_bw_t bw_local;
  uint32_t rf_freq_in_hz_local;
  uint8_t column_index;
  uint8_t row_index;
  
  *delay_indicator = 0;
  if (bw == LR11XX_RADIO_LORA_BW_500)
  {
    row_index = '\x02';
  }
  else
  {
    if (LR11XX_RADIO_LORA_BW_500 < bw)
    {
      return false;
    }
    if (bw == LR11XX_RADIO_LORA_BW_125)
    {
      row_index = '\0';
    }
    else
    {
      if (bw != LR11XX_RADIO_LORA_BW_250)
      {
        return false;
      }
      row_index = '\x01';
    }
  }
  switch(sf)
  {
  case LR11XX_RADIO_LORA_SF5:
    column_index = '\0';
    break;
  case LR11XX_RADIO_LORA_SF6:
    column_index = '\x01';
    break;
  case LR11XX_RADIO_LORA_SF7:
    column_index = '\x02';
    break;
  case LR11XX_RADIO_LORA_SF8:
    column_index = '\x03';
    break;
  case LR11XX_RADIO_LORA_SF9:
    column_index = '\x04';
    break;
  case LR11XX_RADIO_LORA_SF10:
    column_index = '\x05';
    break;
  case LR11XX_RADIO_LORA_SF11:
    column_index = '\x06';
    break;
  case LR11XX_RADIO_LORA_SF12:
    column_index = '\a';
    break;
  default:
    return false;
  }
  if (rf_freq_in_hz < 600000000)
  {
    *delay_indicator = rttof_delay_indicator_table_below_600mhz[row_index][column_index];
  }
  else if ((rf_freq_in_hz < 600000000) || (1999999999 < rf_freq_in_hz))
  {
    *delay_indicator = rttof_delay_indicator_table_above_2ghz[row_index][column_index];
  }
  else
  {
    *delay_indicator = rttof_delay_indicator_table_from_600mhz_to_2ghz[row_index][column_index];
  }
  return true;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr11x1_common_get_xosc_cfg(void)
{
  return &smtc_shield_lr11x1_common_xosc_cfg;
}



_Bool smtc_shield_lr11x1_common_rttof_recommended_rx_tx_delay_indicator
                (uint32_t rf_freq_in_hz,lr11xx_radio_lora_bw_t bw,lr11xx_radio_lora_sf_t sf,
                uint32_t *delay_indicator)
{
  uint32_t *delay_indicator_local;
  lr11xx_radio_lora_sf_t sf_local;
  lr11xx_radio_lora_bw_t bw_local;
  uint32_t rf_freq_in_hz_local;
  
  return false;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr11xx_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  if (rf_freq_in_hz < 600000000)
  {
    plVar1 = &smtc_shield_lr11xx_common_rssi_calibration_table_below_600mhz;
  }
  else if ((rf_freq_in_hz < 600000000) || (2000000000 < rf_freq_in_hz))
  {
    plVar1 = &smtc_shield_lr11xx_common_rssi_calibration_table_above_2ghz;
  }
  else
  {
    plVar1 = &smtc_shield_lr11xx_common_rssi_calibration_table_from_600mhz_to_2ghz;
  }
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr11xx_common_get_rf_switch_cfg(void)
{
  return &smtc_shield_lr11xx_common_rf_switch_cfg;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr11xx_common_get_reg_mode(void)
{
  return LR11XX_SYSTEM_REG_MODE_DCDC;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr11xx_common_get_lfclk_cfg(void)
{
  return &smtc_shield_lr11xx_common_lfclk_cfg;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr11xx_common_get_pinout(void)
{
  return &smtc_shield_lr11xx_common_pinout;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1110mb1dxs_common_get_pa_pwr_cfg
          (uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  if ((((rf_freq_in_hz < 150000000) || (960000000 < rf_freq_in_hz)) ||
      (expected_output_pwr_in_dbm + 0x11 < 0 != SCARRY4((int)expected_output_pwr_in_dbm,0x11))) ||
     ('\x16' < expected_output_pwr_in_dbm))
  {
    psVar1 = (smtc_shield_lr11xx_pa_pwr_cfg_t *)0x0;
  }
  else
  {
    psVar1 = smtc_shield_lr1110mb1dxs_common_pa_pwr_cfg_table + expected_output_pwr_in_dbm + 0x11;
  }
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1110mb1gxs_common_get_pa_pwr_cfg
          (uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  if ((((rf_freq_in_hz < 150000000) || (960000000 < rf_freq_in_hz)) ||
      (expected_output_pwr_in_dbm + 0x11 < 0 != SCARRY4((int)expected_output_pwr_in_dbm,0x11))) ||
     ('\x16' < expected_output_pwr_in_dbm))
  {
    psVar1 = (smtc_shield_lr11xx_pa_pwr_cfg_t *)0x0;
  }
  else
  {
    psVar1 = smtc_shield_lr1110mb1gxs_common_pa_pwr_cfg_table + expected_output_pwr_in_dbm + 0x11;
  }
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1120mb1dxs_common_get_pa_pwr_cfg
          (uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  if ((rf_freq_in_hz < 150000000) || (960000000 < rf_freq_in_hz))
  {
    if ((((1999999999 < rf_freq_in_hz) && (rf_freq_in_hz < 0x7d2b7501)) ||
        ((2399999999 < rf_freq_in_hz && (rf_freq_in_hz < 0x9502f901)))) &&
       ((expected_output_pwr_in_dbm + 0x12 < 0 == SCARRY4((int)expected_output_pwr_in_dbm,0x12) &&
        (expected_output_pwr_in_dbm < '\x0e'))))
    {
      return smtc_shield_lr1120mb1dxs_common_pa_pwr_hf_cfg_table + expected_output_pwr_in_dbm + 0x12
      ;
    }
  }
  else if ((expected_output_pwr_in_dbm + 0x11 < 0 == SCARRY4((int)expected_output_pwr_in_dbm,0x11))
          && (expected_output_pwr_in_dbm < '\x17'))
  {
    return smtc_shield_lr1120mb1dxs_common_pa_pwr_cfg_table + expected_output_pwr_in_dbm + 0x11;
  }
  return (smtc_shield_lr11xx_pa_pwr_cfg_t *)0x0;
}



lr11xx_status_t lr11xx_system_get_irq_status(void *context,lr11xx_system_irq_mask_t *irq_status)
{
  lr11xx_status_t lVar1;
  lr11xx_system_irq_mask_t *irq_status_local;
  void *context_local;
  
  lVar1 = lr11xx_system_get_status
                    (context,(lr11xx_system_stat1_t *)0x0,(lr11xx_system_stat2_t *)0x0,irq_status);
  return lVar1;
}



lr11xx_status_t lr11xx_system_reset(void *context)
{
  lr11xx_hal_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_hal_reset(context);
  return lVar1;
}



lr11xx_status_t
lr11xx_system_get_status
          (void *context,lr11xx_system_stat1_t *stat1,lr11xx_system_stat2_t *stat2,
          lr11xx_system_irq_mask_t *irq_status)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_irq_mask_t *irq_status_local;
  lr11xx_system_stat2_t *stat2_local;
  lr11xx_system_stat1_t *stat1_local;
  void *context_local;
  uint8_t data [6];
  lr11xx_status_t status;
  
  data[0] = '\0';
  data[1] = '\0';
  data[2] = '\0';
  data[3] = '\0';
  data[4] = '\0';
  data[5] = '\0';
  lVar1 = lr11xx_hal_direct_read(context,data,6);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    lr11xx_system_convert_stat1_byte_to_enum(data[0],stat1);
    lr11xx_system_convert_stat2_byte_to_enum(data[1],stat2);
    if (irq_status != (lr11xx_system_irq_mask_t *)0x0)
    {
      *irq_status = (uint)data[5] +
                    (uint)data[4] * 0x100 +
                    ((uint)data._0_4_ >> 0x10) * 0x1000000 + ((uint)data._0_4_ >> 0x18) * 0x10000;
    }
  }
  return lVar1;
}



lr11xx_status_t lr11xx_system_get_errors(void *context,lr11xx_system_errors_t *errors)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_errors_t *errors_local;
  void *context_local;
  uint8_t rbuffer [4];
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\r';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  rbuffer[2] = '\0';
  rbuffer[3] = '\0';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,rbuffer,2);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    *errors = (ushort)rbuffer[1] + (ushort)rbuffer[0] * 0x100;
  }
  return lVar1;
}



lr11xx_status_t lr11xx_system_clear_errors(void *context)
{
  lr11xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x0e';
  lVar1 = lr11xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_calibrate(void *context,uint8_t calib_param)
{
  lr11xx_hal_status_t lVar1;
  uint8_t calib_param_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x0f';
  cbuffer[2] = calib_param;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_set_reg_mode(void *context,lr11xx_system_reg_mode_t reg_mode)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_reg_mode_t reg_mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x10';
  cbuffer[2] = reg_mode;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_calibrate_image(void *context,uint8_t freq1,uint8_t freq2)
{
  lr11xx_hal_status_t lVar1;
  uint8_t freq2_local;
  uint8_t freq1_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x11';
  cbuffer[2] = freq1;
  cbuffer[3] = freq2;
  lVar1 = lr11xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_system_calibrate_image_in_mhz(void *context,uint16_t freq1_in_mhz,uint16_t freq2_in_mhz)
{
  lr11xx_status_t lVar1;
  int iVar2;
  uint16_t freq2_in_mhz_local;
  uint16_t freq1_in_mhz_local;
  void *context_local;
  uint8_t freq2;
  uint8_t freq1;
  
  iVar2 = freq2_in_mhz + 3;
  if (false)
  {
    iVar2 = freq2_in_mhz + 6;
  }
  lVar1 = lr11xx_system_calibrate_image(context,(uint8_t)(freq1_in_mhz >> 2),(uint8_t)(iVar2 >> 2));
  return lVar1;
}



lr11xx_status_t
lr11xx_system_set_dio_as_rf_switch(void *context,lr11xx_system_rfswitch_cfg_t *rf_switch_cfg)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_rfswitch_cfg_t *rf_switch_cfg_local;
  void *context_local;
  uint8_t cbuffer [10];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x12';
  cbuffer[2] = rf_switch_cfg->enable;
  cbuffer[3] = rf_switch_cfg->standby;
  cbuffer[4] = rf_switch_cfg->rx;
  cbuffer[5] = rf_switch_cfg->tx;
  cbuffer[6] = rf_switch_cfg->tx_hp;
  cbuffer[7] = rf_switch_cfg->tx_hf;
  cbuffer[8] = rf_switch_cfg->gnss;
  cbuffer[9] = rf_switch_cfg->wifi;
  lVar1 = lr11xx_hal_write(context,cbuffer,10,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_system_set_dio_irq_params
          (void *context,lr11xx_system_irq_mask_t irqs_to_enable_dio1,
          lr11xx_system_irq_mask_t irqs_to_enable_dio2)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_irq_mask_t irqs_to_enable_dio2_local;
  lr11xx_system_irq_mask_t irqs_to_enable_dio1_local;
  void *context_local;
  uint8_t cbuffer [10];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x13';
  cbuffer[2] = (uint8_t)(irqs_to_enable_dio1 >> 0x18);
  cbuffer[3] = (uint8_t)(irqs_to_enable_dio1 >> 0x10);
  cbuffer[4] = (uint8_t)(irqs_to_enable_dio1 >> 8);
  cbuffer[5] = (uint8_t)irqs_to_enable_dio1;
  cbuffer[6] = (uint8_t)(irqs_to_enable_dio2 >> 0x18);
  cbuffer[7] = (uint8_t)(irqs_to_enable_dio2 >> 0x10);
  cbuffer[8] = (uint8_t)(irqs_to_enable_dio2 >> 8);
  cbuffer[9] = (uint8_t)irqs_to_enable_dio2;
  lVar1 = lr11xx_hal_write(context,cbuffer,10,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_clear_irq_status(void *context,lr11xx_system_irq_mask_t irqs_to_clear)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_irq_mask_t irqs_to_clear_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x14';
  cbuffer[2] = (uint8_t)(irqs_to_clear >> 0x18);
  cbuffer[3] = (uint8_t)(irqs_to_clear >> 0x10);
  cbuffer[4] = (uint8_t)(irqs_to_clear >> 8);
  cbuffer[5] = (uint8_t)irqs_to_clear;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_get_and_clear_irq_status(void *context,lr11xx_system_irq_mask_t *irq)
{
  lr11xx_system_irq_mask_t *irq_local;
  void *context_local;
  lr11xx_system_irq_mask_t lr11xx_irq_mask;
  lr11xx_status_t status;
  
  lr11xx_irq_mask = 0;
  status = lr11xx_system_get_irq_status(context,&lr11xx_irq_mask);
  if ((status == LR11XX_STATUS_OK) && (lr11xx_irq_mask != 0))
  {
    status = lr11xx_system_clear_irq_status(context,lr11xx_irq_mask);
  }
  if ((status == LR11XX_STATUS_OK) && (irq != (lr11xx_system_irq_mask_t *)0x0))
  {
    *irq = lr11xx_irq_mask;
  }
  return status;
}



lr11xx_status_t
lr11xx_system_cfg_lfclk
          (void *context,lr11xx_system_lfclk_cfg_t lfclock_cfg,_Bool wait_for_32k_ready)
{
  lr11xx_hal_status_t lVar1;
  _Bool wait_for_32k_ready_local;
  lr11xx_system_lfclk_cfg_t lfclock_cfg_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x16';
  cbuffer[2] = lfclock_cfg | wait_for_32k_ready << 2;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_system_set_tcxo_mode(void *context,lr11xx_system_tcxo_supply_voltage_t tune,uint32_t timeout)
{
  lr11xx_hal_status_t lVar1;
  uint32_t timeout_local;
  lr11xx_system_tcxo_supply_voltage_t tune_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x17';
  cbuffer[3] = (uint8_t)(timeout >> 0x10);
  cbuffer[4] = (uint8_t)(timeout >> 8);
  cbuffer[5] = (uint8_t)timeout;
  cbuffer[2] = tune;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_system_set_sleep(void *context,lr11xx_system_sleep_cfg_t sleep_cfg,uint32_t sleep_time)
{
  lr11xx_hal_status_t lVar1;
  uint32_t sleep_time_local;
  lr11xx_system_sleep_cfg_t sleep_cfg_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x1b';
  sleep_cfg_local.is_rtc_timeout = sleep_cfg.is_rtc_timeout;
  sleep_cfg_local.is_warm_start = sleep_cfg.is_warm_start;
  cbuffer[2] = sleep_cfg_local.is_rtc_timeout * '\x02' + sleep_cfg_local.is_warm_start;
  cbuffer[3] = (uint8_t)(sleep_time >> 0x18);
  cbuffer[4] = (uint8_t)(sleep_time >> 0x10);
  cbuffer[5] = (uint8_t)(sleep_time >> 8);
  cbuffer[6] = (uint8_t)sleep_time;
  lVar1 = lr11xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_set_standby(void *context,lr11xx_system_standby_cfg_t standby_cfg)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_system_standby_cfg_t standby_cfg_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x1c';
  cbuffer[2] = standby_cfg;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_wakeup(void *context)
{
  lr11xx_hal_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_hal_wakeup(context);
  return lVar1;
}



lr11xx_status_t lr11xx_system_set_fs(void *context)
{
  lr11xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x1d';
  lVar1 = lr11xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_system_get_random_number(void *context,uint32_t *random_number)
{
  lr11xx_hal_status_t lVar1;
  uint32_t *random_number_local;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = ' ';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,(uint8_t *)random_number,4);
  return lVar1;
}



lr11xx_status_t lr11xx_system_enable_spi_crc(void *context,_Bool enable_crc)
{
  lr11xx_hal_status_t lVar1;
  _Bool enable_crc_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '(';
  cbuffer[2] = enable_crc;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



void lr11xx_system_convert_stat1_byte_to_enum(uint8_t stat1_byte,lr11xx_system_stat1_t *stat1)
{
  lr11xx_system_stat1_t *stat1_local;
  uint8_t stat1_byte_local;
  
  if (stat1 != (lr11xx_system_stat1_t *)0x0)
  {
    stat1->is_interrupt_active = (stat1_byte & 1) != 0;
    stat1->command_status = stat1_byte >> 1;
  }
  return;
}



void lr11xx_system_convert_stat2_byte_to_enum(uint8_t stat2_byte,lr11xx_system_stat2_t *stat2)
{
  lr11xx_system_stat2_t *stat2_local;
  uint8_t stat2_byte_local;
  
  if (stat2 != (lr11xx_system_stat2_t *)0x0)
  {
    stat2->is_running_from_flash = (stat2_byte & 1) != 0;
    stat2->chip_mode =
         (lr11xx_system_chip_modes_t)((int)(uint)stat2_byte >> 1) &
         (LR11XX_SYSTEM_CHIP_MODE_LOC|LR11XX_SYSTEM_CHIP_MODE_STBY_RC);
    stat2->reset_status = stat2_byte >> 4;
  }
  return;
}



lr11xx_status_t lr11xx_radio_get_pkt_type(void *context,lr11xx_radio_pkt_type_t *pkt_type)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pkt_type_t *pkt_type_local;
  void *context_local;
  uint8_t pkt_type_raw;
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x02';
  pkt_type_raw = '\0';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,&pkt_type_raw,1);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    *pkt_type = pkt_type_raw;
  }
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_get_rx_buffer_status(void *context,lr11xx_radio_rx_buffer_status_t *rx_buffer_status)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_rx_buffer_status_t *rx_buffer_status_local;
  void *context_local;
  uint8_t rbuffer [2];
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x03';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,rbuffer,2);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    rx_buffer_status->pld_len_in_bytes = rbuffer[0];
    rx_buffer_status->buffer_start_pointer = rbuffer[1];
  }
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_get_gfsk_pkt_status(void *context,lr11xx_radio_pkt_status_gfsk_t *pkt_status)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pkt_status_gfsk_t *pkt_status_local;
  void *context_local;
  uint8_t rbuffer [4];
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x04';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  rbuffer[2] = '\0';
  rbuffer[3] = '\0';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,rbuffer,4);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    pkt_status->rssi_sync_in_dbm = -(rbuffer[0] >> 1);
    pkt_status->rssi_avg_in_dbm = -(rbuffer[1] >> 1);
    pkt_status->rx_len_in_bytes = rbuffer[2];
    pkt_status->is_addr_err = ((int)(uint)rbuffer[3] >> 5 & 1U) != 0;
    pkt_status->is_crc_err = ((int)(uint)rbuffer[3] >> 4 & 1U) != 0;
    pkt_status->is_len_err = ((int)(uint)rbuffer[3] >> 3 & 1U) != 0;
    pkt_status->is_abort_err = ((int)(uint)rbuffer[3] >> 2 & 1U) != 0;
    pkt_status->is_received = ((int)(uint)rbuffer[3] >> 1 & 1U) != 0;
    pkt_status->is_sent = ((uint)rbuffer & 0x1000000) != 0;
  }
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_get_lora_pkt_status(void *context,lr11xx_radio_pkt_status_lora_t *pkt_status)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pkt_status_lora_t *pkt_status_local;
  void *context_local;
  uint8_t rbuffer [3];
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x04';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  rbuffer[2] = '\0';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,rbuffer,3);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    pkt_status->rssi_pkt_in_dbm = -(rbuffer[0] >> 1);
    pkt_status->snr_pkt_in_db = (int8_t)((char)rbuffer[1] + 2 >> 2);
    pkt_status->signal_rssi_pkt_in_dbm = -(rbuffer[2] >> 1);
  }
  return lVar1;
}



lr11xx_status_t lr11xx_radio_get_rssi_inst(void *context,int8_t *rssi_in_dbm)
{
  lr11xx_hal_status_t lVar1;
  int8_t *rssi_in_dbm_local;
  void *context_local;
  uint8_t rssi;
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x05';
  rssi = '\0';
  lVar1 = lr11xx_hal_read(context,cbuffer,2,&rssi,1);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    *rssi_in_dbm = -(rssi >> 1);
  }
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_gfsk_sync_word(void *context,uint8_t *gfsk_sync_word)
{
  lr11xx_hal_status_t lVar1;
  uint8_t *gfsk_sync_word_local;
  void *context_local;
  uint8_t cbuffer [10];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x06';
  cbuffer[2] = *gfsk_sync_word;
  cbuffer[3] = gfsk_sync_word[1];
  cbuffer[4] = gfsk_sync_word[2];
  cbuffer[5] = gfsk_sync_word[3];
  cbuffer[6] = gfsk_sync_word[4];
  cbuffer[7] = gfsk_sync_word[5];
  cbuffer[8] = gfsk_sync_word[6];
  cbuffer[9] = gfsk_sync_word[7];
  lVar1 = lr11xx_hal_write(context,cbuffer,10,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_lora_sync_word(void *context,uint8_t sync_word)
{
  lr11xx_hal_status_t lVar1;
  uint8_t sync_word_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '+';
  cbuffer[2] = sync_word;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_lr_fhss_sync_word(void *context,uint8_t *sync_word)
{
  lr11xx_hal_status_t lVar1;
  uint8_t *sync_word_local;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '-';
  lVar1 = lr11xx_hal_write(context,cbuffer,2,sync_word,4);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_rx(void *context,uint32_t timeout_in_ms)
{
  lr11xx_status_t lVar1;
  uint32_t timeout_in_ms_00;
  uint32_t timeout_in_ms_local;
  void *context_local;
  uint32_t timeout_in_rtc_step;
  
  timeout_in_ms_00 = lr11xx_radio_convert_time_in_ms_to_rtc_step(timeout_in_ms);
  lVar1 = lr11xx_radio_set_rx_with_timeout_in_rtc_step(context,timeout_in_ms_00);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_rx_with_timeout_in_rtc_step(void *context,uint32_t timeout_in_ms)
{
  lr11xx_status_t lVar1;
  uint32_t timeout_in_ms_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_rx_with_timeout_in_rtc_step_and_lna_mode
                    (context,timeout_in_ms,LR11XX_RADIO_LNA_MODE_DIFFERENTIAL_LF0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_rx_with_timeout_in_rtc_step_and_lna_mode
          (void *context,uint32_t timeout,lr11xx_radio_lna_mode_t lna_mode)
{
  lr11xx_radio_lna_mode_t lna_mode_local;
  uint32_t timeout_local;
  void *context_local;
  uint8_t cbuffer [5];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\t';
  cbuffer[2] = (uint8_t)(timeout >> 0x10);
  cbuffer[3] = (uint8_t)(timeout >> 8);
  cbuffer[4] = (uint8_t)timeout;
  status = LR11XX_STATUS_OK;
  if (((true) &&
      (status = lr11xx_hal_write(context,cbuffer,5,(uint8_t *)0x0,0), status == LR11XX_HAL_STATUS_OK
      )) && ((lna_mode == LR11XX_RADIO_LNA_MODE_SINGLE_RFI_P_LF0 ||
             (lna_mode == LR11XX_RADIO_LNA_MODE_SINGLE_RFI_N_LF0))))
  {
    status = lr11xx_radio_set_lna_mode(context,lna_mode);
  }
  return status;
}



lr11xx_status_t lr11xx_radio_set_tx(void *context,uint32_t timeout_in_ms)
{
  lr11xx_status_t lVar1;
  uint32_t timeout_in_rtc_step_00;
  uint32_t timeout_in_ms_local;
  void *context_local;
  uint32_t timeout_in_rtc_step;
  
  timeout_in_rtc_step_00 = lr11xx_radio_convert_time_in_ms_to_rtc_step(timeout_in_ms);
  lVar1 = lr11xx_radio_set_tx_with_timeout_in_rtc_step(context,timeout_in_rtc_step_00);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_tx_with_timeout_in_rtc_step(void *context,uint32_t timeout_in_rtc_step)
{
  uint32_t timeout_in_rtc_step_local;
  void *context_local;
  uint8_t cbuffer [5];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\n';
  cbuffer[2] = (uint8_t)(timeout_in_rtc_step >> 0x10);
  cbuffer[3] = (uint8_t)(timeout_in_rtc_step >> 8);
  cbuffer[4] = (uint8_t)timeout_in_rtc_step;
  status = LR11XX_STATUS_OK;
  if (true)
  {
    status = lr11xx_hal_write(context,cbuffer,5,(uint8_t *)0x0,0);
  }
  return status;
}



lr11xx_status_t lr11xx_radio_set_rf_freq(void *context,uint32_t freq_in_hz)
{
  lr11xx_hal_status_t lVar1;
  uint32_t freq_in_hz_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\v';
  cbuffer[2] = (uint8_t)(freq_in_hz >> 0x18);
  cbuffer[3] = (uint8_t)(freq_in_hz >> 0x10);
  cbuffer[4] = (uint8_t)(freq_in_hz >> 8);
  cbuffer[5] = (uint8_t)freq_in_hz;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_cad_params(void *context,lr11xx_radio_cad_params_t *cad_params)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_cad_params_t *cad_params_local;
  void *context_local;
  uint8_t cbuffer [9];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\r';
  cbuffer[2] = cad_params->cad_symb_nb;
  cbuffer[3] = cad_params->cad_detect_peak;
  cbuffer[4] = cad_params->cad_detect_min;
  cbuffer[5] = cad_params->cad_exit_mode;
  cbuffer[6] = (uint8_t)(cad_params->cad_timeout >> 0x10);
  cbuffer[7] = (uint8_t)(cad_params->cad_timeout >> 8);
  cbuffer[8] = (uint8_t)cad_params->cad_timeout;
  lVar1 = lr11xx_hal_write(context,cbuffer,9,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_pkt_type(void *context,lr11xx_radio_pkt_type_t pkt_type)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pkt_type_t pkt_type_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x0e';
  cbuffer[2] = pkt_type;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_gfsk_mod_params(void *context,lr11xx_radio_mod_params_gfsk_t *mod_params)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_mod_params_gfsk_t *mod_params_local;
  void *context_local;
  uint8_t cbuffer [12];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x0f';
  cbuffer[2] = (uint8_t)(mod_params->br_in_bps >> 0x18);
  cbuffer[3] = (uint8_t)(mod_params->br_in_bps >> 0x10);
  cbuffer[4] = (uint8_t)(mod_params->br_in_bps >> 8);
  cbuffer[5] = (uint8_t)mod_params->br_in_bps;
  cbuffer[6] = mod_params->pulse_shape;
  cbuffer[7] = mod_params->bw_dsb_param;
  cbuffer[8] = (uint8_t)(mod_params->fdev_in_hz >> 0x18);
  cbuffer[9] = (uint8_t)(mod_params->fdev_in_hz >> 0x10);
  cbuffer[10] = (uint8_t)(mod_params->fdev_in_hz >> 8);
  cbuffer[0xb] = (uint8_t)mod_params->fdev_in_hz;
  lVar1 = lr11xx_hal_write(context,cbuffer,0xc,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_lora_mod_params(void *context,lr11xx_radio_mod_params_lora_t *mod_params)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_mod_params_lora_t *mod_params_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x0f';
  cbuffer[2] = mod_params->sf;
  cbuffer[3] = mod_params->bw;
  cbuffer[4] = mod_params->cr;
  cbuffer[5] = mod_params->ldro;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_lr_fhss_mod_params(void *radio,lr11xx_radio_mod_params_lr_fhss_t *mod_params)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_mod_params_lr_fhss_t *mod_params_local;
  void *radio_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x0f';
  cbuffer[2] = (uint8_t)((uint)mod_params->br_in_bps >> 0x18);
  cbuffer[3] = (uint8_t)((uint)mod_params->br_in_bps >> 0x10);
  cbuffer[4] = (uint8_t)((uint)mod_params->br_in_bps >> 8);
  cbuffer[5] = (uint8_t)mod_params->br_in_bps;
  cbuffer[6] = mod_params->pulse_shape;
  lVar1 = lr11xx_hal_write(radio,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_gfsk_pkt_params(void *context,lr11xx_radio_pkt_params_gfsk_t *pkt_params)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pkt_params_gfsk_t *pkt_params_local;
  void *context_local;
  uint8_t cbuffer [11];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x10';
  cbuffer[2] = (uint8_t)(pkt_params->preamble_len_in_bits >> 8);
  cbuffer[3] = (uint8_t)pkt_params->preamble_len_in_bits;
  cbuffer[4] = pkt_params->preamble_detector;
  cbuffer[5] = pkt_params->sync_word_len_in_bits;
  cbuffer[6] = pkt_params->address_filtering;
  cbuffer[7] = pkt_params->header_type;
  cbuffer[8] = pkt_params->pld_len_in_bytes;
  cbuffer[9] = pkt_params->crc_type;
  cbuffer[10] = pkt_params->dc_free;
  lVar1 = lr11xx_hal_write(context,cbuffer,0xb,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_lora_pkt_params(void *context,lr11xx_radio_pkt_params_lora_t *pkt_params)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pkt_params_lora_t *pkt_params_local;
  void *context_local;
  uint8_t cbuffer [8];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x10';
  cbuffer[2] = (uint8_t)(pkt_params->preamble_len_in_symb >> 8);
  cbuffer[3] = (uint8_t)pkt_params->preamble_len_in_symb;
  cbuffer[4] = pkt_params->header_type;
  cbuffer[5] = pkt_params->pld_len_in_bytes;
  cbuffer[6] = pkt_params->crc;
  cbuffer[7] = pkt_params->iq;
  lVar1 = lr11xx_hal_write(context,cbuffer,8,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_tx_params(void *context,int8_t pwr_in_dbm,lr11xx_radio_ramp_time_t ramp_time)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_ramp_time_t ramp_time_local;
  int8_t pwr_in_dbm_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x11';
  cbuffer[2] = pwr_in_dbm;
  cbuffer[3] = ramp_time;
  lVar1 = lr11xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_rx_tx_fallback_mode(void *context,lr11xx_radio_fallback_modes_t fallback_mode)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_fallback_modes_t fallback_mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x13';
  cbuffer[2] = fallback_mode;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_rx_duty_cycle
          (void *context,uint32_t rx_period_in_ms,uint32_t sleep_period_in_ms,
          lr11xx_radio_rx_duty_cycle_mode_t mode)
{
  lr11xx_status_t lVar1;
  uint32_t rx_period_in_rtc_step_00;
  uint32_t sleep_period_in_rtc_step_00;
  lr11xx_radio_rx_duty_cycle_mode_t mode_local;
  uint32_t sleep_period_in_ms_local;
  uint32_t rx_period_in_ms_local;
  void *context_local;
  uint32_t sleep_period_in_rtc_step;
  uint32_t rx_period_in_rtc_step;
  
  rx_period_in_rtc_step_00 = lr11xx_radio_convert_time_in_ms_to_rtc_step(rx_period_in_ms);
  sleep_period_in_rtc_step_00 = lr11xx_radio_convert_time_in_ms_to_rtc_step(sleep_period_in_ms);
  lVar1 = lr11xx_radio_set_rx_duty_cycle_with_timings_in_rtc_step
                    (context,rx_period_in_rtc_step_00,sleep_period_in_rtc_step_00,mode);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_rx_duty_cycle_with_timings_in_rtc_step
          (void *context,uint32_t rx_period_in_rtc_step,uint32_t sleep_period_in_rtc_step,
          lr11xx_radio_rx_duty_cycle_mode_t mode)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_rx_duty_cycle_mode_t mode_local;
  uint32_t sleep_period_in_rtc_step_local;
  uint32_t rx_period_in_rtc_step_local;
  void *context_local;
  uint8_t cbuffer [9];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x14';
  cbuffer[2] = (uint8_t)(rx_period_in_rtc_step >> 0x10);
  cbuffer[3] = (uint8_t)(rx_period_in_rtc_step >> 8);
  cbuffer[4] = (uint8_t)rx_period_in_rtc_step;
  cbuffer[5] = (uint8_t)(sleep_period_in_rtc_step >> 0x10);
  cbuffer[6] = (uint8_t)(sleep_period_in_rtc_step >> 8);
  cbuffer[7] = (uint8_t)sleep_period_in_rtc_step;
  cbuffer[8] = mode;
  lVar1 = lr11xx_hal_write(context,cbuffer,9,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_pa_cfg(void *context,lr11xx_radio_pa_cfg_t *pa_cfg)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_pa_cfg_t *pa_cfg_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x15';
  cbuffer[2] = pa_cfg->pa_sel;
  cbuffer[3] = pa_cfg->pa_reg_supply;
  cbuffer[4] = pa_cfg->pa_duty_cycle;
  cbuffer[5] = pa_cfg->pa_hp_sel;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_stop_timeout_on_preamble(void *context,_Bool stop_timeout_on_preamble)
{
  lr11xx_hal_status_t lVar1;
  _Bool stop_timeout_on_preamble_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x17';
  cbuffer[2] = stop_timeout_on_preamble;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_cad(void *context)
{
  void *context_local;
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x18';
  status = LR11XX_STATUS_OK;
  if (true)
  {
    status = lr11xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  }
  return status;
}



lr11xx_status_t lr11xx_radio_set_tx_cw(void *context)
{
  lr11xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x19';
  lVar1 = lr11xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_tx_infinite_preamble(void *context)
{
  void *context_local;
  uint8_t cbuffer [2];
  lr11xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x1a';
  status = LR11XX_STATUS_OK;
  if (true)
  {
    status = lr11xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  }
  return status;
}



lr11xx_status_t lr11xx_radio_set_lora_sync_timeout(void *context,uint16_t nb_symbol)
{
  lr11xx_hal_status_t lVar1;
  uint16_t nb_symbol_local;
  void *context_local;
  uint8_t mant;
  uint8_t exp;
  uint8_t cbuffer [3];
  
  if (nb_symbol < 0x100)
  {
    cbuffer[0] = '\x02';
    cbuffer[1] = '\x1b';
    cbuffer[2] = (uint8_t)nb_symbol;
    lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  }
  else
  {
    lr11xx_radio_convert_nb_symb_to_mant_exp(nb_symbol,&mant,&exp);
    lVar1 = lr11xx_radio_set_lora_sync_timeout_with_mantissa_exponent(context,mant,exp);
  }
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_lora_sync_timeout_with_mantissa_exponent
          (void *context,uint8_t mantissa,uint8_t exponent)
{
  lr11xx_hal_status_t lVar1;
  uint8_t exponent_local;
  uint8_t mantissa_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x1b';
  cbuffer[2] = exponent | mantissa << 3;
  cbuffer[3] = '\x01';
  if ((mantissa < 0x20) && (exponent < 8))
  {
    lVar1 = lr11xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  }
  else
  {
    lVar1 = LR11XX_HAL_STATUS_ERROR;
  }
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_gfsk_crc_params(void *context,uint32_t seed,uint32_t polynomial)
{
  lr11xx_hal_status_t lVar1;
  uint32_t polynomial_local;
  uint32_t seed_local;
  void *context_local;
  uint8_t cbuffer [10];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '$';
  cbuffer[2] = (uint8_t)(seed >> 0x18);
  cbuffer[3] = (uint8_t)(seed >> 0x10);
  cbuffer[4] = (uint8_t)(seed >> 8);
  cbuffer[5] = (uint8_t)seed;
  cbuffer[6] = (uint8_t)(polynomial >> 0x18);
  cbuffer[7] = (uint8_t)(polynomial >> 0x10);
  cbuffer[8] = (uint8_t)(polynomial >> 8);
  cbuffer[9] = (uint8_t)polynomial;
  lVar1 = lr11xx_hal_write(context,cbuffer,10,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_set_gfsk_whitening_seed(void *context,uint16_t seed)
{
  lr11xx_hal_status_t lVar1;
  uint16_t seed_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '%';
  cbuffer[2] = (uint8_t)(seed >> 8);
  cbuffer[3] = (uint8_t)seed;
  lVar1 = lr11xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_radio_cfg_rx_boosted(void *context,_Bool enable_boost_mode)
{
  lr11xx_hal_status_t lVar1;
  _Bool enable_boost_mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\'';
  cbuffer[2] = enable_boost_mode;
  lVar1 = lr11xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_set_rssi_calibration
          (void *context,lr11xx_radio_rssi_calibration_table_t *rssi_cal_table)
{
  lr11xx_hal_status_t lVar1;
  lr11xx_radio_rssi_calibration_table_t *rssi_cal_table_local;
  void *context_local;
  uint8_t cbuffer [13];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = ')';
  cbuffer[2] = ((rssi_cal_table->gain_tune).g4 & 0xf) + (rssi_cal_table->gain_tune).g5 * '\x10';
  cbuffer[3] = ((rssi_cal_table->gain_tune).g6 & 0xf) + (rssi_cal_table->gain_tune).g7 * '\x10';
  cbuffer[4] = ((rssi_cal_table->gain_tune).g8 & 0xf) + (rssi_cal_table->gain_tune).g9 * '\x10';
  cbuffer[5] = ((rssi_cal_table->gain_tune).g10 & 0xf) + (rssi_cal_table->gain_tune).g11 * '\x10';
  cbuffer[6] = ((rssi_cal_table->gain_tune).g12 & 0xf) + (rssi_cal_table->gain_tune).g13 * '\x10';
  cbuffer[7] = ((rssi_cal_table->gain_tune).g13hp1 & 0xf) +
               (rssi_cal_table->gain_tune).g13hp2 * '\x10';
  cbuffer[8] = ((rssi_cal_table->gain_tune).g13hp3 & 0xf) +
               (rssi_cal_table->gain_tune).g13hp4 * '\x10';
  cbuffer[9] = ((rssi_cal_table->gain_tune).g13hp5 & 0xf) +
               (rssi_cal_table->gain_tune).g13hp6 * '\x10';
  cbuffer[10] = (rssi_cal_table->gain_tune).g13hp7 & 0xf;
  cbuffer[0xb] = (uint8_t)((ushort)rssi_cal_table->gain_offset >> 8);
  cbuffer[0xc] = (uint8_t)rssi_cal_table->gain_offset;
  lVar1 = lr11xx_hal_write(context,cbuffer,0xd,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_radio_get_gfsk_rx_bandwidth(uint32_t bw_in_hz,lr11xx_radio_gfsk_bw_t *bw_parameter)
{
  lr11xx_radio_gfsk_bw_t *bw_parameter_local;
  uint32_t bw_in_hz_local;
  
  if (bw_in_hz < 0x12c1)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_4800;
  }
  else if (bw_in_hz < 0x16a9)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_5800;
  }
  else if (bw_in_hz < 0x1c85)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_7300;
  }
  else if (bw_in_hz < 0x25e5)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_9700;
  }
  else if (bw_in_hz < 0x2db5)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_11700;
  }
  else if (bw_in_hz < 0x3909)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_14600;
  }
  else if (bw_in_hz < 0x4c2d)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_19500;
  }
  else if (bw_in_hz < 0x5b69)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_23400;
  }
  else if (bw_in_hz < 0x7275)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_29300;
  }
  else if (bw_in_hz < 0x9859)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_39000;
  }
  else if (bw_in_hz < 0xb735)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_46900;
  }
  else if (bw_in_hz < 0xe4e9)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_58600;
  }
  else if (bw_in_hz < 0x13179)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_78200;
  }
  else if (bw_in_hz < 0x16e69)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_93800;
  }
  else if (bw_in_hz < 0x1ca35)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_117300;
  }
  else if (bw_in_hz < 0x26229)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_156200;
  }
  else if (bw_in_hz < 0x2db41)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_187200;
  }
  else if (bw_in_hz < 0x3933d)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_234300;
  }
  else if (bw_in_hz < 0x4c2c1)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_312000;
  }
  else if (bw_in_hz < 0x5b361)
  {
    *bw_parameter = LR11XX_RADIO_GFSK_BW_373600;
  }
  else
  {
    if (0x72038 < bw_in_hz)
    {
      return LR11XX_STATUS_ERROR;
    }
    *bw_parameter = LR11XX_RADIO_GFSK_BW_467000;
  }
  return LR11XX_STATUS_OK;
}



uint32_t lr11xx_radio_get_lora_time_on_air_numerator
                   (lr11xx_radio_pkt_params_lora_t *pkt_p,lr11xx_radio_mod_params_lora_t *mod_p)
{
  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  bool bVar11;
  lr11xx_radio_mod_params_lora_t *mod_p_local;
  lr11xx_radio_pkt_params_lora_t *pkt_p_local;
  uint32_t intermed;
  int32_t tx_codedbits_header;
  int32_t tx_bits_symbol_start;
  int32_t fec_rate_denominator;
  int32_t fec_rate_numerator;
  int32_t tx_bits_symbol;
  int32_t total_bytes_nb;
  _Bool long_interleaving;
  int32_t fine_synch;
  _Bool pld_is_fix;
  int32_t sf;
  int32_t pld_len_in_bytes;
  int32_t tx_infobits_payload;
  int32_t tx_infobits_header;
  int32_t symbols_nb_data;
  int32_t ceil_denominator;
  int32_t ceil_numerator;
  
  uVar5 = (uint)pkt_p->pld_len_in_bytes;
  uVar6 = (uint)mod_p->sf;
  bVar11 = pkt_p->header_type != LR11XX_RADIO_LORA_PKT_IMPLICIT;
  uVar7 = (uint)(uVar6 < 7);
  bVar1 = mod_p->cr < LR11XX_RADIO_LORA_CR_LI_4_5;
  if (pkt_p->crc == LR11XX_RADIO_LORA_CRC_ON)
  {
    iVar4 = 2;
  }
  else
  {
    iVar4 = 0;
  }
  iVar4 = uVar5 + iVar4;
  if (mod_p->ldro == '\0')
  {
    iVar8 = 0;
  }
  else
  {
    iVar8 = 2;
  }
  iVar8 = uVar6 - iVar8;
  if (bVar1)
  {
    tx_infobits_header = (uVar6 + uVar7 * 2 + -2) * 4;
    if (bVar11)
    {
      tx_infobits_header += -0x14;
    }
    tx_infobits_payload = iVar4 * 8 - tx_infobits_header;
    if (tx_infobits_payload < 0)
    {
      tx_infobits_payload = 0;
    }
    ceil_numerator = tx_infobits_payload;
    ceil_denominator = iVar8 * 4;
  }
  else
  {
    iVar9 = (uint)(mod_p->cr == LR11XX_RADIO_LORA_CR_LI_4_8) + (uint)mod_p->cr;
    if (bVar11)
    {
      tx_infobits_header = (uVar6 + uVar7 * 2 + -7) * 4 & 0xfffffff8;
      if ((tx_infobits_header + iVar4 * -8 < 0 != SBORROW4(tx_infobits_header,iVar4 * 8)) &&
         (tx_infobits_header != uVar5 * 8 &&
          (int)(tx_infobits_header + uVar5 * -8) < 0 == SBORROW4(tx_infobits_header,uVar5 * 8)))
      {
        tx_infobits_header = uVar5 << 3;
      }
      tx_infobits_payload = iVar4 * 8 - tx_infobits_header;
      if (tx_infobits_payload < 0)
      {
        tx_infobits_payload = 0;
      }
      ceil_numerator = iVar8 * 0x20 + iVar9 * tx_infobits_payload;
      ceil_denominator = iVar8 * 4;
    }
    else
    {
      iVar10 = uVar7 * 2 + (uVar6 - 2);
      iVar3 = iVar9 * iVar4 * 8;
      iVar2 = iVar3 + iVar10 * -0x1c;
      if (iVar2 == 0 || iVar2 < 0 != SBORROW4(iVar3,iVar10 * 0x1c))
      {
        ceil_numerator = iVar9 * iVar4 * 8;
        ceil_denominator = iVar10 * 4;
      }
      else
      {
        ceil_numerator = (iVar9 * iVar4 + iVar8 * 4) * 8 + iVar10 * -0x20;
        ceil_denominator = iVar8 * 4;
      }
    }
  }
  symbols_nb_data = (ceil_denominator + ceil_numerator + -1) / ceil_denominator;
  if (bVar1)
  {
    symbols_nb_data = symbols_nb_data * (mod_p->cr + 4) + 8;
  }
  return ((symbols_nb_data + pkt_p->preamble_len_in_symb + 4 + uVar7 * 2) * 4 + 1 <<
         (uVar6 - 2 & 0xff)) - 1;
}



uint32_t lr11xx_radio_get_lora_bw_in_hz(lr11xx_radio_lora_bw_t bw)
{
  lr11xx_radio_lora_bw_t bw_local;
  uint32_t bw_in_hz;
  
  bw_in_hz = 0;
  if (true)
  {
    switch(bw)
    {
    case LR11XX_RADIO_LORA_BW_15:
      bw_in_hz = 0x3d09;
      break;
    case LR11XX_RADIO_LORA_BW_31:
      bw_in_hz = 0x7a12;
      break;
    case LR11XX_RADIO_LORA_BW_62:
      bw_in_hz = 0xf424;
      break;
    case LR11XX_RADIO_LORA_BW_125:
      bw_in_hz = 0x1e848;
      break;
    case LR11XX_RADIO_LORA_BW_250:
      bw_in_hz = 250000;
      break;
    case LR11XX_RADIO_LORA_BW_500:
      bw_in_hz = 500000;
      break;
    case LR11XX_RADIO_LORA_BW_10:
      bw_in_hz = 0x28b1;
      break;
    case LR11XX_RADIO_LORA_BW_20:
      bw_in_hz = 0x5161;
      break;
    case LR11XX_RADIO_LORA_BW_41:
      bw_in_hz = 0xa2c3;
      break;
    case LR11XX_RADIO_LORA_BW_200:
      bw_in_hz = 0x318f8;
      break;
    case LR11XX_RADIO_LORA_BW_400:
      bw_in_hz = 0x631f0;
      break;
    case LR11XX_RADIO_LORA_BW_800:
      bw_in_hz = 0xc63e0;
    }
  }
  return bw_in_hz;
}



uint32_t lr11xx_radio_get_lora_time_on_air_in_ms
                   (lr11xx_radio_pkt_params_lora_t *pkt_p,lr11xx_radio_mod_params_lora_t *mod_p)
{
  uint32_t uVar1;
  uint32_t uVar2;
  lr11xx_radio_mod_params_lora_t *mod_p_local;
  lr11xx_radio_pkt_params_lora_t *pkt_p_local;
  uint32_t denominator;
  uint32_t numerator;
  
  uVar1 = lr11xx_radio_get_lora_time_on_air_numerator(pkt_p,mod_p);
  uVar2 = lr11xx_radio_get_lora_bw_in_hz(mod_p->bw);
  return ((uVar2 + uVar1 * 1000) - 1) / uVar2;
}



uint32_t lr11xx_radio_get_gfsk_time_on_air_numerator(lr11xx_radio_pkt_params_gfsk_t *pkt_p)
{
  lr11xx_radio_gfsk_pkt_len_modes_t lVar1;
  byte bVar2;
  byte bVar3;
  lr11xx_radio_gfsk_address_filtering_t lVar4;
  ushort uVar5;
  uint32_t uVar6;
  lr11xx_radio_pkt_params_gfsk_t *pkt_p_local;
  uint8_t header_len_in_bits;
  
  lVar1 = pkt_p->header_type;
  if (lVar1 == LR11XX_RADIO_GFSK_PKT_VAR_LEN_SX128X_COMP)
  {
    header_len_in_bits = '\t';
  }
  else
  {
    if (LR11XX_RADIO_GFSK_PKT_VAR_LEN_SX128X_COMP < lVar1)
    {
      return 0;
    }
    if (lVar1 == LR11XX_RADIO_GFSK_PKT_FIX_LEN)
    {
      header_len_in_bits = '\0';
    }
    else
    {
      if (lVar1 != LR11XX_RADIO_GFSK_PKT_VAR_LEN)
      {
        return 0;
      }
      header_len_in_bits = '\b';
    }
  }
  uVar5 = pkt_p->preamble_len_in_bits;
  bVar2 = pkt_p->sync_word_len_in_bits;
  bVar3 = pkt_p->pld_len_in_bytes;
  lVar4 = pkt_p->address_filtering;
  uVar6 = lr11xx_radio_get_gfsk_crc_len_in_bytes(pkt_p->crc_type);
  return (uVar6 + (uint)(lVar4 != LR11XX_RADIO_GFSK_ADDRESS_FILTERING_DISABLE) + (uint)bVar3) * 8 +
         (uint)header_len_in_bits + (uint)uVar5 + (uint)bVar2;
}



uint32_t lr11xx_radio_get_gfsk_time_on_air_in_ms
                   (lr11xx_radio_pkt_params_gfsk_t *pkt_p,lr11xx_radio_mod_params_gfsk_t *mod_p)
{
  uint32_t uVar1;
  lr11xx_radio_mod_params_gfsk_t *mod_p_local;
  lr11xx_radio_pkt_params_gfsk_t *pkt_p_local;
  uint32_t denominator;
  uint32_t numerator;
  
  uVar1 = lr11xx_radio_get_gfsk_time_on_air_numerator(pkt_p);
  return ((mod_p->br_in_bps + uVar1 * 1000) - 1) / mod_p->br_in_bps;
}



uint32_t lr11xx_radio_convert_time_in_ms_to_rtc_step(uint32_t time_in_ms)
{
  uint32_t time_in_ms_local;
  
  return (time_in_ms << 0xf) / 1000;
}



uint16_t lr11xx_radio_convert_nb_symb_to_mant_exp(uint16_t nb_symbol,uint8_t *mant,uint8_t *exp)
{
  uint8_t *exp_local;
  uint8_t *mant_local;
  uint16_t nb_symbol_local;
  uint16_t mant_loc;
  uint8_t exp_loc;
  
  exp_loc = '\0';
  for (mant_loc = (uint16_t)((int)(nb_symbol + 1) >> 1); 0x1f < mant_loc;
      mant_loc = (uint16_t)((int)(mant_loc + 3) >> 2))
  {
    exp_loc += '\x01';
  }
  *mant = (uint8_t)mant_loc;
  *exp = exp_loc;
  return mant_loc << ((uint)exp_loc * 2 + 1 & 0xff);
}



lr11xx_status_t lr11xx_radio_set_lna_mode(void *context,lr11xx_radio_lna_mode_t lna_config)
{
  lr11xx_status_t lVar1;
  lr11xx_radio_lna_mode_t lna_config_local;
  void *context_local;
  
  lVar1 = lr11xx_regmem_write_regmem32_mask(context,0xf3008c,0xf0,(uint)lna_config << 4);
  return lVar1;
}



uint32_t lr11xx_radio_get_gfsk_crc_len_in_bytes(lr11xx_radio_gfsk_crc_type_t crc_type)
{
  uint32_t uVar1;
  lr11xx_radio_gfsk_crc_type_t crc_type_local;
  
  if (false)
  {
switchD_08022946_caseD_3:
    uVar1 = 0;
  }
  else
  {
    switch(crc_type)
    {
    case LR11XX_RADIO_GFSK_CRC_1_BYTE:
      uVar1 = 1;
      break;
    case LR11XX_RADIO_GFSK_CRC_OFF:
      uVar1 = 0;
      break;
    case LR11XX_RADIO_GFSK_CRC_2_BYTES:
      uVar1 = 2;
      break;
    default:
      goto switchD_08022946_caseD_3;
    case LR11XX_RADIO_GFSK_CRC_1_BYTE_INV:
      uVar1 = 1;
      break;
    case LR11XX_RADIO_GFSK_CRC_2_BYTES_INV:
      uVar1 = 2;
    }
  }
  return uVar1;
}



lr11xx_status_t lr11xx_regmem_write_buffer8(void *context,uint8_t *buffer,uint8_t length)
{
  lr11xx_hal_status_t lVar1;
  uint8_t length_local;
  uint8_t *buffer_local;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\t';
  lVar1 = lr11xx_hal_write(context,cbuffer,2,buffer,(ushort)length);
  return lVar1;
}



lr11xx_status_t
lr11xx_regmem_read_buffer8(void *context,uint8_t *buffer,uint8_t offset,uint8_t length)
{
  lr11xx_hal_status_t lVar1;
  uint8_t length_local;
  uint8_t offset_local;
  uint8_t *buffer_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\n';
  cbuffer[2] = offset;
  cbuffer[3] = length;
  lVar1 = lr11xx_hal_read(context,cbuffer,4,buffer,(ushort)length);
  return lVar1;
}



lr11xx_status_t
lr11xx_regmem_write_regmem32_mask(void *context,uint32_t address,uint32_t mask,uint32_t data)
{
  lr11xx_hal_status_t lVar1;
  uint32_t data_local;
  uint32_t mask_local;
  uint32_t address_local;
  void *context_local;
  uint8_t cbuffer [14];
  
  lr11xx_regmem_fill_cbuffer_opcode_address(cbuffer,0x10c,address);
  cbuffer[6] = (uint8_t)(mask >> 0x18);
  cbuffer[7] = (uint8_t)(mask >> 0x10);
  cbuffer[8] = (uint8_t)(mask >> 8);
  cbuffer[9] = (uint8_t)mask;
  cbuffer[10] = (uint8_t)(data >> 0x18);
  cbuffer[0xb] = (uint8_t)(data >> 0x10);
  cbuffer[0xc] = (uint8_t)(data >> 8);
  cbuffer[0xd] = (uint8_t)data;
  lVar1 = lr11xx_hal_write(context,cbuffer,0xe,(uint8_t *)0x0,0);
  return lVar1;
}



void lr11xx_regmem_fill_cbuffer_opcode_address(uint8_t *cbuffer,uint16_t opcode,uint32_t address)
{
  uint32_t address_local;
  uint16_t opcode_local;
  uint8_t *cbuffer_local;
  
  *cbuffer = (uint8_t)(opcode >> 8);
  cbuffer[1] = (uint8_t)opcode;
  cbuffer[2] = (uint8_t)(address >> 0x18);
  cbuffer[3] = (uint8_t)(address >> 0x10);
  cbuffer[4] = (uint8_t)(address >> 8);
  cbuffer[5] = (uint8_t)address;
  return;
}



lr11xx_status_t lr11xx_rttof_set_address(void *context,uint32_t address,uint8_t check_length)
{
  lr11xx_hal_status_t lVar1;
  uint8_t check_length_local;
  uint32_t address_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x1c';
  cbuffer[2] = (uint8_t)(address >> 0x18);
  cbuffer[3] = (uint8_t)(address >> 0x10);
  cbuffer[4] = (uint8_t)(address >> 8);
  cbuffer[5] = (uint8_t)address;
  cbuffer[6] = check_length;
  lVar1 = lr11xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_rttof_set_request_address(void *context,uint32_t request_address)
{
  lr11xx_hal_status_t lVar1;
  uint32_t request_address_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x1d';
  cbuffer[2] = (uint8_t)(request_address >> 0x18);
  cbuffer[3] = (uint8_t)(request_address >> 0x10);
  cbuffer[4] = (uint8_t)(request_address >> 8);
  cbuffer[5] = (uint8_t)request_address;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_rttof_set_rx_tx_delay_indicator(void *context,uint32_t delay_indicator)
{
  lr11xx_hal_status_t lVar1;
  uint32_t delay_indicator_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x1f';
  cbuffer[2] = (uint8_t)(delay_indicator >> 0x18);
  cbuffer[3] = (uint8_t)(delay_indicator >> 0x10);
  cbuffer[4] = (uint8_t)(delay_indicator >> 8);
  cbuffer[5] = (uint8_t)delay_indicator;
  lVar1 = lr11xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t lr11xx_rttof_set_parameters(void *context,uint8_t nb_symbols)
{
  lr11xx_hal_status_t lVar1;
  uint8_t nb_symbols_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '(';
  cbuffer[2] = '\0';
  cbuffer[3] = nb_symbols;
  lVar1 = lr11xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr11xx_status_t
lr11xx_rttof_get_raw_result(void *context,lr11xx_rttof_result_type_t type,uint8_t *result)
{
  lr11xx_hal_status_t lVar1;
  uint8_t *result_local;
  lr11xx_rttof_result_type_t type_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x1e';
  cbuffer[2] = type;
  lVar1 = lr11xx_hal_read(context,cbuffer,3,result,4);
  return lVar1;
}



int32_t lr11xx_rttof_distance_raw_to_meter
                  (lr11xx_radio_lora_bw_t rttof_bw,uint8_t *raw_distance_buf)
{
  int iVar1;
  uint8_t *raw_distance_buf_local;
  lr11xx_radio_lora_bw_t rttof_bw_local;
  uint32_t raw_distance;
  uint8_t bitcnt;
  int32_t retval;
  uint8_t bw_scaling;
  
  bw_scaling = '\0';
  retval = (uint)*raw_distance_buf * 0x1000000 +
           (uint)raw_distance_buf[3] + (uint)raw_distance_buf[2] * 0x100 +
           (uint)raw_distance_buf[1] * 0x10000;
  if (rttof_bw == LR11XX_RADIO_LORA_BW_500)
  {
    bw_scaling = '\x01';
  }
  else if (rttof_bw == LR11XX_RADIO_LORA_BW_250)
  {
    bw_scaling = '\x02';
  }
  else if (rttof_bw == LR11XX_RADIO_LORA_BW_125)
  {
    bw_scaling = '\x04';
  }
  if (0x7fffff < (uint)retval)
  {
    retval -= 0x1000000;
  }
  iVar1 = retval * (uint)bw_scaling * 300;
  if (iVar1 < 0)
  {
    iVar1 += 0xfff;
  }
  return iVar1 >> 0xc;
}



lr11xx_status_t lr11xx_lr_fhss_init(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  lr11xx_radio_mod_params_lr_fhss_t mod_lr_fhss;
  lr11xx_status_t set_modulation_param_status;
  lr11xx_status_t set_packet_type_status;
  
  lVar1 = lr11xx_radio_set_pkt_type(context,LR11XX_RADIO_PKT_TYPE_LR_FHSS);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    mod_lr_fhss.br_in_bps = LR11XX_RADIO_LR_FHSS_BITRATE_488_BPS;
    mod_lr_fhss.pulse_shape = LR11XX_RADIO_LR_FHSS_PULSE_SHAPE_BT_1;
    mod_lr_fhss._5_3_ = 0;
    lVar1 = lr11xx_radio_set_lr_fhss_mod_params(context,&mod_lr_fhss);
  }
  return lVar1;
}



uint16_t lr11xx_lr_fhss_get_bit_delay_in_us(lr11xx_lr_fhss_params_t *params,uint16_t payload_length)
{
  uint16_t uVar1;
  uint16_t payload_length_local;
  lr11xx_lr_fhss_params_t *params_local;
  uint8_t nb_padding_bits;
  uint16_t nb_bits;
  
  uVar1 = lr11xx_lr_fhss_get_nb_bits(&params->lr_fhss_params,payload_length);
  return (ushort)(byte)((-(char)uVar1 & 7U) + 1) * 0x800 + 0x640;
}



lr11xx_status_t
lr11xx_lr_fhss_build_frame
          (void *context,lr11xx_lr_fhss_params_t *lr_fhss_params,uint16_t hop_sequence_id,
          uint8_t *payload,uint8_t payload_length)
{
  lr11xx_hal_status_t lVar1;
  uint8_t *payload_local;
  uint16_t hop_sequence_id_local;
  lr11xx_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  uint8_t cbuffer [11];
  lr11xx_status_t status;
  
  lVar1 = lr11xx_radio_set_lr_fhss_sync_word(context,(lr_fhss_params->lr_fhss_params).sync_word);
  if (lVar1 == LR11XX_HAL_STATUS_OK)
  {
    cbuffer[0] = '\x02';
    cbuffer[1] = ',';
    cbuffer[2] = (lr_fhss_params->lr_fhss_params).header_count;
    cbuffer[3] = (lr_fhss_params->lr_fhss_params).cr;
    cbuffer[4] = (lr_fhss_params->lr_fhss_params).modulation_type;
    cbuffer[5] = (lr_fhss_params->lr_fhss_params).grid;
    cbuffer[6] = (lr_fhss_params->lr_fhss_params).enable_hopping != false;
    cbuffer[7] = (lr_fhss_params->lr_fhss_params).bw;
    cbuffer[8] = (uint8_t)(hop_sequence_id >> 8);
    cbuffer[9] = (uint8_t)hop_sequence_id;
    cbuffer[10] = lr_fhss_params->device_offset;
    lVar1 = lr11xx_hal_write(context,cbuffer,0xb,payload,(ushort)payload_length);
  }
  return lVar1;
}



uint32_t lr11xx_lr_fhss_get_time_on_air_in_ms
                   (lr11xx_lr_fhss_params_t *params,uint16_t payload_length)
{
  uint16_t uVar1;
  uint16_t payload_length_local;
  lr11xx_lr_fhss_params_t *params_local;
  
  uVar1 = lr11xx_lr_fhss_get_nb_bits(&params->lr_fhss_params,payload_length);
  return ((uint)uVar1 * 0x100 + 0x7c) / 0x7d;
}



uint lr11xx_lr_fhss_get_hop_sequence_count(lr11xx_lr_fhss_params_t *lr_fhss_params)
{
  uint uVar1;
  lr11xx_lr_fhss_params_t *lr_fhss_params_local;
  
  if (((lr_fhss_params->lr_fhss_params).grid == LR_FHSS_V1_GRID_25391_HZ) ||
     (((lr_fhss_params->lr_fhss_params).grid == LR_FHSS_V1_GRID_3906_HZ &&
      ((lr_fhss_params->lr_fhss_params).bw < LR_FHSS_V1_BW_335938_HZ))))
  {
    uVar1 = 0x180;
  }
  else
  {
    uVar1 = 0x200;
  }
  return uVar1;
}



uint16_t lr11xx_lr_fhss_get_nb_bits(lr_fhss_v1_params_t *params,uint16_t payload_length)
{
  uint16_t payload_length_local;
  lr_fhss_v1_params_t *params_local;
  uint16_t last_block_bits;
  uint16_t payload_bits;
  uint16_t length_bits;
  
  length_bits = (payload_length + 2) * 8 + 6;
  switch(params->cr)
  {
  case LR_FHSS_V1_CR_5_6:
    length_bits = (uint16_t)(((uint)length_bits * 6 + 4) / 5);
    break;
  case LR_FHSS_V1_CR_2_3:
    length_bits = (uint16_t)(((uint)length_bits * 3) / 2);
    break;
  case LR_FHSS_V1_CR_1_2:
    length_bits *= 2;
    break;
  case LR_FHSS_V1_CR_1_3:
    length_bits *= 3;
  }
  payload_bits = (length_bits / 0x30) * 0x32;
  if (length_bits % 0x30 != 0)
  {
    payload_bits = payload_bits + length_bits % 0x30 + 2;
  }
  return payload_bits + (ushort)params->header_count * 0x72;
}



lr11xx_status_t lr11xx_system_get_irq_status(void *context,lr11xx_system_irq_mask_t *irq_status)
{
  lr11xx_status_t lVar1;
  lr11xx_system_irq_mask_t *irq_status_local;
  void *context_local;
  
  lVar1 = lr11xx_system_get_status
                    (context,(lr11xx_system_stat1_t *)0x0,(lr11xx_system_stat2_t *)0x0,irq_status);
  return lVar1;
}



int8_t lr11xx_rttof_rssi_raw_to_value(uint8_t *raw_rssi_buf)
{
  uint8_t *raw_rssi_buf_local;
  
  return -(raw_rssi_buf[3] >> 1);
}



_Bool ral_lr11xx_handles_part(char *part_number)
{
  int iVar1;
  _Bool _Var2;
  char *part_number_local;
  
  iVar1 = strcmp("lr1110",part_number);
  if ((iVar1 == 0) || (iVar1 = strcmp("lr1120",part_number), iVar1 == 0))
  {
    _Var2 = true;
  }
  else
  {
    _Var2 = false;
  }
  return _Var2;
}



ral_status_t ral_lr11xx_reset(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_system_reset(context);
  return lVar1;
}



ral_status_t ral_lr11xx_init(void *context)
{
  void *context_local;
  _Bool rx_boost_is_activated;
  uint32_t startup_time_in_tick;
  _Bool crc_is_activated;
  ral_xosc_cfg_t xosc_cfg;
  lr11xx_system_rfswitch_cfg_t system_rf_switch_cfg;
  lr11xx_system_reg_mode_t reg_mode;
  lr11xx_system_tcxo_supply_voltage_t tcxo_supply_voltage;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  system_rf_switch_cfg.enable = '\0';
  system_rf_switch_cfg.standby = '\0';
  system_rf_switch_cfg.rx = '\0';
  system_rf_switch_cfg.tx = '\0';
  system_rf_switch_cfg.tx_hp = '\0';
  system_rf_switch_cfg.tx_hf = '\0';
  system_rf_switch_cfg.gnss = '\0';
  system_rf_switch_cfg.wifi = '\0';
  crc_is_activated = false;
  startup_time_in_tick = 0;
  ral_lr11xx_bsp_get_crc_state(context,&crc_is_activated);
  if ((crc_is_activated == false) ||
     (status = lr11xx_system_enable_spi_crc(context,true), status == LR11XX_STATUS_OK))
  {
    ral_lr11xx_bsp_get_reg_mode(context,&reg_mode);
    status = lr11xx_system_set_reg_mode(context,reg_mode);
    if (status == LR11XX_STATUS_OK)
    {
      ral_lr11xx_bsp_get_rf_switch_cfg(context,&system_rf_switch_cfg);
      status = lr11xx_system_set_dio_as_rf_switch(context,&system_rf_switch_cfg);
      if ((status == LR11XX_STATUS_OK) &&
         ((ral_lr11xx_bsp_get_xosc_cfg(context,&xosc_cfg,&tcxo_supply_voltage,&startup_time_in_tick)
          , xosc_cfg != RAL_XOSC_CFG_TCXO_RADIO_CTRL ||
          ((status = lr11xx_system_set_tcxo_mode(context,tcxo_supply_voltage,startup_time_in_tick),
           status == LR11XX_STATUS_OK &&
           (status = lr11xx_system_calibrate(context,'?'), status == LR11XX_STATUS_OK))))))
      {
        ral_lr11xx_bsp_get_rx_boost_cfg(context,&rx_boost_is_activated);
        status = lr11xx_radio_cfg_rx_boosted(context,rx_boost_is_activated);
      }
    }
  }
  return status;
}



ral_status_t ral_lr11xx_wakeup(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_system_wakeup(context);
  return lVar1;
}



ral_status_t ral_lr11xx_set_sleep(void *context,_Bool retain_config)
{
  lr11xx_status_t lVar1;
  _Bool retain_config_local;
  void *context_local;
  lr11xx_system_sleep_cfg_t radio_sleep_cfg;
  _Bool lfclk_is_running;
  ral_status_t status;
  
  ral_lr11xx_bsp_get_lfclk_cfg_in_sleep(context,&lfclk_is_running);
  radio_sleep_cfg.is_rtc_timeout = lfclk_is_running;
  radio_sleep_cfg.is_warm_start = retain_config;
  if ((lfclk_is_running == true) ||
     (lVar1 = lr11xx_system_cfg_lfclk(context,LR11XX_SYSTEM_LFCLK_RC,true),
     lVar1 == LR11XX_STATUS_OK))
  {
    lVar1 = lr11xx_system_set_sleep(context,radio_sleep_cfg,0);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_standby(void *context,ral_standby_cfg_t ral_standby_cfg)
{
  lr11xx_status_t lVar1;
  ral_standby_cfg_t ral_standby_cfg_local;
  void *context_local;
  lr11xx_system_standby_cfg_t radio_standby_cfg;
  
  if (ral_standby_cfg == RAL_STANDBY_CFG_RC)
  {
    radio_standby_cfg = LR11XX_SYSTEM_STANDBY_CFG_RC;
  }
  else
  {
    if (ral_standby_cfg != RAL_STANDBY_CFG_XOSC)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    radio_standby_cfg = LR11XX_SYSTEM_STANDBY_CFG_XOSC;
  }
  lVar1 = lr11xx_system_set_standby(context,radio_standby_cfg);
  return lVar1;
}



ral_status_t ral_lr11xx_set_fs(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_system_set_fs(context);
  return lVar1;
}



ral_status_t ral_lr11xx_set_tx(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_tx(context,0);
  return lVar1;
}



ral_status_t ral_lr11xx_set_rx(void *context,uint32_t timeout_in_ms)
{
  lr11xx_status_t lVar1;
  uint32_t timeout_in_ms_local;
  void *context_local;
  
  if (timeout_in_ms == 0xffffffff)
  {
    lVar1 = lr11xx_radio_set_rx_with_timeout_in_rtc_step(context,0xffffff);
  }
  else if (timeout_in_ms < 0x7d000)
  {
    lVar1 = lr11xx_radio_set_rx(context,timeout_in_ms);
  }
  else
  {
    lVar1 = LR11XX_STATUS_ERROR;
  }
  return lVar1;
}



ral_status_t ral_lr11xx_cfg_rx_boosted(void *context,_Bool enable_boost_mode)
{
  lr11xx_status_t lVar1;
  _Bool enable_boost_mode_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_cfg_rx_boosted(context,enable_boost_mode);
  return lVar1;
}



ral_status_t
ral_lr11xx_set_rx_tx_fallback_mode(void *context,ral_fallback_modes_t ral_fallback_mode)
{
  lr11xx_status_t lVar1;
  ral_fallback_modes_t ral_fallback_mode_local;
  void *context_local;
  lr11xx_radio_fallback_modes_t radio_fallback_mode;
  
  if (ral_fallback_mode == RAL_FALLBACK_FS)
  {
    radio_fallback_mode = LR11XX_RADIO_FALLBACK_FS;
  }
  else
  {
    if (RAL_FALLBACK_FS < ral_fallback_mode)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    if (ral_fallback_mode == RAL_FALLBACK_STDBY_RC)
    {
      radio_fallback_mode = LR11XX_RADIO_FALLBACK_STDBY_RC;
    }
    else
    {
      if (ral_fallback_mode != RAL_FALLBACK_STDBY_XOSC)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      radio_fallback_mode = LR11XX_RADIO_FALLBACK_STDBY_XOSC;
    }
  }
  lVar1 = lr11xx_radio_set_rx_tx_fallback_mode(context,radio_fallback_mode);
  return lVar1;
}



ral_status_t ral_lr11xx_stop_timer_on_preamble(void *context,_Bool enable)
{
  lr11xx_status_t lVar1;
  _Bool enable_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_stop_timeout_on_preamble(context,enable);
  return lVar1;
}



ral_status_t
ral_lr11xx_set_rx_duty_cycle(void *context,uint32_t rx_time_in_ms,uint32_t sleep_time_in_ms)
{
  lr11xx_status_t lVar1;
  uint32_t sleep_time_in_ms_local;
  uint32_t rx_time_in_ms_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_rx_duty_cycle
                    (context,rx_time_in_ms,sleep_time_in_ms,LR11XX_RADIO_RX_DUTY_CYCLE_MODE_RX);
  return lVar1;
}



ral_status_t ral_lr11xx_set_lora_cad(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_cad(context);
  return lVar1;
}



ral_status_t ral_lr11xx_set_tx_cw(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_tx_cw(context);
  return lVar1;
}



ral_status_t ral_lr11xx_set_tx_infinite_preamble(void *context)
{
  lr11xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_tx_infinite_preamble(context);
  return lVar1;
}



ral_status_t ral_lr11xx_cal_img(void *context,uint16_t freq1_in_mhz,uint16_t freq2_in_mhz)
{
  lr11xx_status_t lVar1;
  uint16_t freq2_in_mhz_local;
  uint16_t freq1_in_mhz_local;
  void *context_local;
  
  lVar1 = lr11xx_system_calibrate_image_in_mhz(context,freq1_in_mhz,freq2_in_mhz);
  return lVar1;
}



ral_status_t ral_lr11xx_set_tx_cfg(void *context,int8_t output_pwr_in_dbm,uint32_t rf_freq_in_hz)
{
  lr11xx_status_t lVar1;
  uint32_t rf_freq_in_hz_local;
  int8_t output_pwr_in_dbm_local;
  void *context_local;
  ral_lr11xx_bsp_tx_cfg_input_params_t tx_cfg_input_params;
  ral_lr11xx_bsp_tx_cfg_output_params_t tx_cfg_output_params;
  ral_status_t status;
  
  tx_cfg_input_params.system_output_pwr_in_dbm = output_pwr_in_dbm;
  tx_cfg_input_params.freq_in_hz = rf_freq_in_hz;
  ral_lr11xx_bsp_get_tx_cfg(context,&tx_cfg_input_params,&tx_cfg_output_params);
  lVar1 = lr11xx_radio_set_pa_cfg(context,&tx_cfg_output_params.pa_cfg);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    lVar1 = lr11xx_radio_set_tx_params
                      (context,tx_cfg_output_params.chip_output_pwr_in_dbm_configured,
                       tx_cfg_output_params.pa_ramp_time);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_pkt_payload(void *context,uint8_t *buffer,uint16_t size)
{
  lr11xx_status_t lVar1;
  uint16_t size_local;
  uint8_t *buffer_local;
  void *context_local;
  
  lVar1 = lr11xx_regmem_write_buffer8(context,buffer,(uint8_t)size);
  return lVar1;
}



ral_status_t
ral_lr11xx_get_pkt_payload
          (void *context,uint16_t max_size_in_bytes,uint8_t *buffer,uint16_t *size_in_bytes)
{
  uint16_t *size_in_bytes_local;
  uint8_t *buffer_local;
  uint16_t max_size_in_bytes_local;
  void *context_local;
  lr11xx_radio_rx_buffer_status_t radio_rx_buffer_status;
  ral_status_t status;
  
  radio_rx_buffer_status.pld_len_in_bytes = '\0';
  radio_rx_buffer_status.buffer_start_pointer = '\0';
  status = lr11xx_radio_get_rx_buffer_status(context,&radio_rx_buffer_status);
  if (status == LR11XX_STATUS_OK)
  {
    if (size_in_bytes != (uint16_t *)0x0)
    {
      *size_in_bytes = (ushort)radio_rx_buffer_status & 0xff;
    }
    if (max_size_in_bytes < ((ushort)radio_rx_buffer_status & 0xff))
    {
      status = RAL_STATUS_ERROR;
    }
    else
    {
      status = lr11xx_regmem_read_buffer8
                         (context,buffer,radio_rx_buffer_status.buffer_start_pointer,
                          radio_rx_buffer_status.pld_len_in_bytes);
    }
  }
  return status;
}



ral_status_t ral_lr11xx_get_irq_status(void *context,ral_irq_t *irq)
{
  ral_irq_t rVar1;
  ral_irq_t *irq_local;
  void *context_local;
  lr11xx_system_irq_mask_t radio_irq_mask;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  radio_irq_mask = 0;
  status = lr11xx_system_get_irq_status(context,&radio_irq_mask);
  if (status == LR11XX_STATUS_OK)
  {
    rVar1 = ral_lr11xx_convert_irq_flags_to_ral(radio_irq_mask);
    *irq = rVar1;
  }
  return status;
}



ral_status_t ral_lr11xx_clear_irq_status(void *context,ral_irq_t irq)
{
  lr11xx_status_t lVar1;
  lr11xx_system_irq_mask_t irqs_to_clear;
  ral_irq_t irq_local;
  void *context_local;
  lr11xx_system_irq_mask_t radio_irq;
  
  irqs_to_clear = ral_lr11xx_convert_irq_flags_from_ral(irq);
  lVar1 = lr11xx_system_clear_irq_status(context,irqs_to_clear);
  return lVar1;
}



ral_status_t ral_lr11xx_get_and_clear_irq_status(void *context,ral_irq_t *irq)
{
  ral_irq_t rVar1;
  ral_irq_t *irq_local;
  void *context_local;
  lr11xx_system_irq_mask_t radio_irq;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  radio_irq = 0;
  status = lr11xx_system_get_and_clear_irq_status(context,&radio_irq);
  if ((status == LR11XX_STATUS_OK) && (irq != (ral_irq_t *)0x0))
  {
    rVar1 = ral_lr11xx_convert_irq_flags_to_ral(radio_irq);
    *irq = rVar1;
  }
  return status;
}



ral_status_t ral_lr11xx_set_dio_irq_params(void *context,ral_irq_t irq)
{
  lr11xx_status_t lVar1;
  lr11xx_system_irq_mask_t irqs_to_enable_dio1;
  ral_irq_t irq_local;
  void *context_local;
  lr11xx_system_irq_mask_t lr11xx_irq;
  
  irqs_to_enable_dio1 = ral_lr11xx_convert_irq_flags_from_ral(irq);
  lVar1 = lr11xx_system_set_dio_irq_params(context,irqs_to_enable_dio1,0);
  return lVar1;
}



ral_status_t ral_lr11xx_set_rf_freq(void *context,uint32_t freq_in_hz)
{
  lr11xx_status_t lVar1;
  uint32_t freq_in_hz_local;
  void *context_local;
  lr11xx_radio_rssi_calibration_table_t rssi_calibration_table;
  ral_status_t status;
  
  lVar1 = lr11xx_radio_set_rf_freq(context,freq_in_hz);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    ral_lr11xx_bsp_get_rssi_calibration_table(context,freq_in_hz,&rssi_calibration_table);
    lVar1 = lr11xx_radio_set_rssi_calibration(context,&rssi_calibration_table);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_pkt_type(void *context,ral_pkt_type_t ral_pkt_type)
{
  lr11xx_status_t lVar1;
  ral_pkt_type_t ral_pkt_type_local;
  void *context_local;
  lr11xx_radio_pkt_type_t radio_pkt_type;
  
  if (ral_pkt_type == RAL_PKT_TYPE_RTTOF)
  {
    radio_pkt_type = LR11XX_RADIO_PKT_TYPE_RTTOF;
  }
  else
  {
    if (RAL_PKT_TYPE_RTTOF < ral_pkt_type)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    if (ral_pkt_type == RAL_PKT_TYPE_GFSK)
    {
      radio_pkt_type = LR11XX_RADIO_PKT_TYPE_GFSK;
    }
    else
    {
      if (ral_pkt_type != RAL_PKT_TYPE_LORA)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      radio_pkt_type = LR11XX_RADIO_PKT_TYPE_LORA;
    }
  }
  lVar1 = lr11xx_radio_set_pkt_type(context,radio_pkt_type);
  return lVar1;
}



ral_status_t ral_lr11xx_get_pkt_type(void *context,ral_pkt_type_t *pkt_type)
{
  lr11xx_status_t lVar1;
  ral_pkt_type_t *pkt_type_local;
  void *context_local;
  lr11xx_radio_pkt_type_t radio_pkt_type;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  lVar1 = lr11xx_radio_get_pkt_type(context,&radio_pkt_type);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    if (radio_pkt_type == LR11XX_RADIO_PKT_TYPE_GFSK)
    {
      *pkt_type = RAL_PKT_TYPE_GFSK;
    }
    else if (radio_pkt_type == LR11XX_RADIO_PKT_TYPE_LORA)
    {
      *pkt_type = RAL_PKT_TYPE_LORA;
    }
    else
    {
      lVar1 = 2;
    }
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_gfsk_mod_params(void *context,ral_gfsk_mod_params_t *ral_mod_params)
{
  lr11xx_status_t lVar1;
  ral_gfsk_mod_params_t *ral_mod_params_local;
  void *context_local;
  lr11xx_radio_mod_params_gfsk_t radio_mod_params;
  ral_status_t status;
  
  radio_mod_params.br_in_bps = 0;
  radio_mod_params.pulse_shape = LR11XX_RADIO_GFSK_PULSE_SHAPE_OFF;
  radio_mod_params.bw_dsb_param = 0;
  radio_mod_params._6_2_ = 0;
  radio_mod_params.fdev_in_hz = 0;
  lVar1 = ral_lr11xx_convert_gfsk_mod_params_from_ral(ral_mod_params,&radio_mod_params);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    lVar1 = lr11xx_radio_set_gfsk_mod_params(context,&radio_mod_params);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_gfsk_pkt_params(void *context,ral_gfsk_pkt_params_t *ral_pkt_params)
{
  lr11xx_status_t lVar1;
  ral_gfsk_pkt_params_t *ral_pkt_params_local;
  void *context_local;
  lr11xx_radio_pkt_params_gfsk_t radio_pkt_params;
  ral_status_t status;
  
  radio_pkt_params.preamble_len_in_bits = 0;
  radio_pkt_params.preamble_detector = LR11XX_RADIO_GFSK_PREAMBLE_DETECTOR_OFF;
  radio_pkt_params.sync_word_len_in_bits = '\0';
  radio_pkt_params.address_filtering = LR11XX_RADIO_GFSK_ADDRESS_FILTERING_DISABLE;
  radio_pkt_params.header_type = LR11XX_RADIO_GFSK_PKT_FIX_LEN;
  radio_pkt_params.pld_len_in_bytes = '\0';
  radio_pkt_params.crc_type = LR11XX_RADIO_GFSK_CRC_1_BYTE;
  radio_pkt_params.dc_free = LR11XX_RADIO_GFSK_DC_FREE_OFF;
  radio_pkt_params._9_1_ = 0;
  lVar1 = ral_lr11xx_convert_gfsk_pkt_params_from_ral(ral_pkt_params,&radio_pkt_params);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    lVar1 = lr11xx_radio_set_gfsk_pkt_params(context,&radio_pkt_params);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_lora_mod_params(void *context,ral_lora_mod_params_t *ral_mod_params)
{
  lr11xx_status_t lVar1;
  ral_lora_mod_params_t *ral_mod_params_local;
  void *context_local;
  lr11xx_radio_mod_params_lora_t radio_mod_params;
  ral_status_t status;
  
  lVar1 = ral_lr11xx_convert_lora_mod_params_from_ral(ral_mod_params,&radio_mod_params);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    lVar1 = lr11xx_radio_set_lora_mod_params(context,&radio_mod_params);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_lora_pkt_params(void *context,ral_lora_pkt_params_t *ral_pkt_params)
{
  lr11xx_status_t lVar1;
  ral_lora_pkt_params_t *ral_pkt_params_local;
  void *context_local;
  lr11xx_radio_pkt_params_lora_t radio_pkt_params;
  ral_status_t status;
  
  radio_pkt_params.preamble_len_in_symb = 0;
  radio_pkt_params.header_type = LR11XX_RADIO_LORA_PKT_EXPLICIT;
  radio_pkt_params.pld_len_in_bytes = '\0';
  radio_pkt_params.crc = LR11XX_RADIO_LORA_CRC_OFF;
  radio_pkt_params.iq = LR11XX_RADIO_LORA_IQ_STANDARD;
  lVar1 = ral_lr11xx_convert_lora_pkt_params_from_ral(ral_pkt_params,&radio_pkt_params);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    lVar1 = lr11xx_radio_set_lora_pkt_params(context,&radio_pkt_params);
  }
  return lVar1;
}



ral_status_t
ral_lr11xx_set_lora_cad_params(void *context,ral_lora_cad_params_t *ral_lora_cad_params)
{
  lr11xx_status_t lVar1;
  ral_lora_cad_params_t *ral_lora_cad_params_local;
  void *context_local;
  lr11xx_radio_cad_params_t radio_lora_cad_params;
  ral_status_t status;
  
  lVar1 = ral_lr11xx_convert_lora_cad_params_from_ral(ral_lora_cad_params,&radio_lora_cad_params);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    lVar1 = lr11xx_radio_set_cad_params(context,&radio_lora_cad_params);
  }
  return lVar1;
}



ral_status_t ral_lr11xx_set_lora_symb_nb_timeout(void *context,uint16_t nb_of_symbs)
{
  lr11xx_status_t lVar1;
  uint16_t nb_of_symbs_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_lora_sync_timeout(context,nb_of_symbs);
  return lVar1;
}



ral_status_t ral_lr11xx_set_flrc_mod_params(void *context,ral_flrc_mod_params_t *params)
{
  ral_flrc_mod_params_t *params_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr11xx_set_flrc_pkt_params(void *context,ral_flrc_pkt_params_t *params)
{
  ral_flrc_pkt_params_t *params_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t
ral_lr11xx_get_gfsk_rx_pkt_status(void *context,ral_gfsk_rx_pkt_status_t *ral_rx_pkt_status)
{
  lr11xx_status_t lVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  ral_gfsk_rx_pkt_status_t *ral_rx_pkt_status_local;
  void *context_local;
  lr11xx_radio_pkt_status_gfsk_t radio_rx_pkt_status;
  uint8_t rx_status;
  ral_status_t status;
  
  lVar1 = lr11xx_radio_get_gfsk_pkt_status(context,&radio_rx_pkt_status);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    if (radio_rx_pkt_status.is_received == false)
    {
      bVar2 = 0;
    }
    else
    {
      bVar2 = 2;
    }
    if (radio_rx_pkt_status.is_abort_err == false)
    {
      bVar3 = 0;
    }
    else
    {
      bVar3 = 4;
    }
    if (radio_rx_pkt_status.is_len_err == false)
    {
      bVar4 = 0;
    }
    else
    {
      bVar4 = 8;
    }
    if (radio_rx_pkt_status.is_crc_err == false)
    {
      bVar5 = 0;
    }
    else
    {
      bVar5 = 0x10;
    }
    if (radio_rx_pkt_status.is_addr_err == false)
    {
      bVar6 = 0;
    }
    else
    {
      bVar6 = 0x20;
    }
    ral_rx_pkt_status->rx_status =
         (ushort)(byte)(radio_rx_pkt_status.is_sent | bVar2 | bVar3 | bVar4 | bVar5 | bVar6);
    ral_rx_pkt_status->rssi_sync_in_dbm = (short)radio_rx_pkt_status.rssi_sync_in_dbm;
    ral_rx_pkt_status->rssi_avg_in_dbm = (short)radio_rx_pkt_status.rssi_avg_in_dbm;
  }
  return lVar1;
}



ral_status_t
ral_lr11xx_get_lora_rx_pkt_status(void *context,ral_lora_rx_pkt_status_t *ral_rx_pkt_status)
{
  lr11xx_status_t lVar1;
  ral_lora_rx_pkt_status_t *ral_rx_pkt_status_local;
  void *context_local;
  lr11xx_radio_pkt_status_lora_t radio_rx_pkt_status;
  ral_status_t status;
  
  lVar1 = lr11xx_radio_get_lora_pkt_status(context,&radio_rx_pkt_status);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    ral_rx_pkt_status->rssi_pkt_in_dbm = (short)radio_rx_pkt_status.rssi_pkt_in_dbm;
    ral_rx_pkt_status->snr_pkt_in_db = (short)radio_rx_pkt_status.snr_pkt_in_db;
    ral_rx_pkt_status->signal_rssi_pkt_in_dbm = (short)radio_rx_pkt_status.signal_rssi_pkt_in_dbm;
  }
  return lVar1;
}



ral_status_t
ral_lr11xx_get_flrc_rx_pkt_status(void *context,ral_flrc_rx_pkt_status_t *rx_pkt_status)
{
  ral_flrc_rx_pkt_status_t *rx_pkt_status_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr11xx_get_rssi_inst(void *context,int16_t *rssi_in_dbm)
{
  lr11xx_status_t lVar1;
  int16_t *rssi_in_dbm_local;
  void *context_local;
  int8_t local_rssi_in_dbm;
  lr11xx_status_t status;
  
  lVar1 = lr11xx_radio_get_rssi_inst(context,&local_rssi_in_dbm);
  *rssi_in_dbm = (short)local_rssi_in_dbm;
  return lVar1;
}



uint32_t ral_lr11xx_get_lora_time_on_air_in_ms
                   (ral_lora_pkt_params_t *pkt_p,ral_lora_mod_params_t *mod_p)
{
  uint32_t uVar1;
  ral_lora_mod_params_t *mod_p_local;
  ral_lora_pkt_params_t *pkt_p_local;
  lr11xx_radio_pkt_params_lora_t radio_pkt_params;
  lr11xx_radio_mod_params_lora_t radio_mod_params;
  
  ral_lr11xx_convert_lora_mod_params_from_ral(mod_p,&radio_mod_params);
  ral_lr11xx_convert_lora_pkt_params_from_ral(pkt_p,&radio_pkt_params);
  uVar1 = lr11xx_radio_get_lora_time_on_air_in_ms(&radio_pkt_params,&radio_mod_params);
  return uVar1;
}



uint32_t ral_lr11xx_get_gfsk_time_on_air_in_ms
                   (ral_gfsk_pkt_params_t *pkt_p,ral_gfsk_mod_params_t *mod_p)
{
  uint32_t uVar1;
  ral_gfsk_mod_params_t *mod_p_local;
  ral_gfsk_pkt_params_t *pkt_p_local;
  lr11xx_radio_pkt_params_gfsk_t radio_pkt_params;
  lr11xx_radio_mod_params_gfsk_t radio_mod_params;
  
  ral_lr11xx_convert_gfsk_mod_params_from_ral(mod_p,&radio_mod_params);
  ral_lr11xx_convert_gfsk_pkt_params_from_ral(pkt_p,&radio_pkt_params);
  uVar1 = lr11xx_radio_get_gfsk_time_on_air_in_ms(&radio_pkt_params,&radio_mod_params);
  return uVar1;
}



uint32_t ral_lr11xx_get_flrc_time_on_air_in_ms
                   (ral_flrc_pkt_params_t *pkt_p,ral_flrc_mod_params_t *mod_p)
{
  ral_flrc_mod_params_t *mod_p_local;
  ral_flrc_pkt_params_t *pkt_p_local;
  
  return 1;
}



ral_status_t ral_lr11xx_set_gfsk_sync_word(void *context,uint8_t *sync_word,uint8_t sync_word_len)
{
  lr11xx_status_t lVar1;
  uint8_t sync_word_len_local;
  uint8_t *sync_word_local;
  void *context_local;
  uint8_t sync_word_loc [8];
  uint8_t i;
  
  sync_word_loc[0] = '\0';
  sync_word_loc[1] = '\0';
  sync_word_loc[2] = '\0';
  sync_word_loc[3] = '\0';
  sync_word_loc[4] = '\0';
  sync_word_loc[5] = '\0';
  sync_word_loc[6] = '\0';
  sync_word_loc[7] = '\0';
  for (i = '\0'; i < sync_word_len; i += '\x01')
  {
    sync_word_loc[i] = sync_word[i];
  }
  lVar1 = lr11xx_radio_set_gfsk_sync_word(context,sync_word_loc);
  return lVar1;
}



ral_status_t ral_lr11xx_set_lora_sync_word(void *context,uint8_t sync_word)
{
  lr11xx_status_t lVar1;
  uint8_t sync_word_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_lora_sync_word(context,sync_word);
  return lVar1;
}



ral_status_t ral_lr11xx_set_flrc_sync_word(void *context,uint8_t *sync_word,uint8_t sync_word_len)
{
  uint8_t sync_word_len_local;
  uint8_t *sync_word_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr11xx_set_gfsk_crc_params(void *context,uint32_t seed,uint32_t polynomial)
{
  lr11xx_status_t lVar1;
  uint32_t polynomial_local;
  uint32_t seed_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_gfsk_crc_params(context,seed,polynomial);
  return lVar1;
}



ral_status_t ral_lr11xx_set_flrc_crc_params(void *context,uint32_t seed)
{
  uint32_t seed_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr11xx_set_gfsk_whitening_seed(void *context,uint16_t seed)
{
  lr11xx_status_t lVar1;
  uint16_t seed_local;
  void *context_local;
  
  lVar1 = lr11xx_radio_set_gfsk_whitening_seed(context,seed);
  return lVar1;
}



ral_status_t ral_lr11xx_lr_fhss_init(void *context,ral_lr_fhss_params_t *lr_fhss_params)
{
  lr11xx_status_t lVar1;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  
  lVar1 = lr11xx_lr_fhss_init(context);
  return lVar1;
}



ral_status_t
ral_lr11xx_lr_fhss_build_frame
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,ral_lr_fhss_memory_state_t state,
          uint16_t hop_sequence_id,uint8_t *payload,uint16_t payload_length)
{
  lr11xx_status_t lVar1;
  uint16_t hop_sequence_id_local;
  ral_lr_fhss_memory_state_t state_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  lr11xx_system_stat1_t stat1;
  lr11xx_lr_fhss_params_t lr11xx_params;
  lr11xx_status_t status;
  
  ral_lr11xx_convert_lr_fhss_params_from_ral(lr_fhss_params,&lr11xx_params);
  lVar1 = lr11xx_radio_set_rf_freq(context,lr_fhss_params->center_frequency_in_hz);
  if (((lVar1 == LR11XX_STATUS_OK) &&
      (lVar1 = lr11xx_lr_fhss_build_frame
                         (context,&lr11xx_params,hop_sequence_id,payload,(uint8_t)payload_length),
      lVar1 == LR11XX_STATUS_OK)) &&
     (lVar1 = lr11xx_system_get_status
                        (context,&stat1,(lr11xx_system_stat2_t *)0x0,(lr11xx_system_irq_mask_t *)0x0
                        ), lVar1 == LR11XX_STATUS_OK))
  {
    if (stat1.command_status == LR11XX_SYSTEM_CMD_STATUS_OK)
    {
      lVar1 = LR11XX_STATUS_OK;
    }
    else
    {
      lVar1 = LR11XX_STATUS_ERROR;
    }
  }
  return lVar1;
}



ral_status_t
ral_lr11xx_lr_fhss_handle_hop
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,ral_lr_fhss_memory_state_t state)
{
  ral_lr_fhss_memory_state_t state_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_lr_fhss_handle_tx_done
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,ral_lr_fhss_memory_state_t state)
{
  ral_lr_fhss_memory_state_t state_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_lr_fhss_get_time_on_air_in_ms
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,uint16_t payload_length,
          uint32_t *time_on_air)
{
  uint32_t uVar1;
  uint32_t *time_on_air_local;
  uint16_t payload_length_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  lr11xx_lr_fhss_params_t lr11xx_params;
  
  ral_lr11xx_convert_lr_fhss_params_from_ral(lr_fhss_params,&lr11xx_params);
  uVar1 = lr11xx_lr_fhss_get_time_on_air_in_ms(&lr11xx_params,payload_length);
  *time_on_air = uVar1;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_lr_fhss_get_hop_sequence_count
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,uint *hop_sequence_count)
{
  uint uVar1;
  uint *hop_sequence_count_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  lr11xx_lr_fhss_params_t lr11xx_params;
  
  ral_lr11xx_convert_lr_fhss_params_from_ral(lr_fhss_params,&lr11xx_params);
  uVar1 = lr11xx_lr_fhss_get_hop_sequence_count(&lr11xx_params);
  *hop_sequence_count = uVar1;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_lr_fhss_get_bit_delay_in_us
          (void *context,ral_lr_fhss_params_t *params,uint16_t payload_length,uint16_t *delay)
{
  uint16_t uVar1;
  uint16_t *delay_local;
  uint16_t payload_length_local;
  ral_lr_fhss_params_t *params_local;
  void *context_local;
  lr11xx_lr_fhss_params_t lr11xx_params;
  
  ral_lr11xx_convert_lr_fhss_params_from_ral(params,&lr11xx_params);
  uVar1 = lr11xx_lr_fhss_get_bit_delay_in_us(&lr11xx_params,payload_length);
  *delay = uVar1;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_get_lora_rx_pkt_cr_crc(void *context,ral_lora_cr_t *cr,_Bool *is_crc_present)
{
  _Bool *is_crc_present_local;
  ral_lora_cr_t *cr_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t
ral_lr11xx_get_tx_consumption_in_ua
          (void *context,int8_t output_pwr_in_dbm,uint32_t rf_freq_in_hz,
          uint32_t *pwr_consumption_in_ua)
{
  ral_status_t rVar1;
  uint32_t *pwr_consumption_in_ua_local;
  uint32_t rf_freq_in_hz_local;
  int8_t output_pwr_in_dbm_local;
  void *context_local;
  ral_lr11xx_bsp_tx_cfg_input_params_t tx_cfg_input_params;
  ral_lr11xx_bsp_tx_cfg_output_params_t tx_cfg_output_params;
  lr11xx_system_reg_mode_t radio_reg_mode;
  
  tx_cfg_input_params.system_output_pwr_in_dbm = output_pwr_in_dbm;
  tx_cfg_input_params.freq_in_hz = rf_freq_in_hz;
  ral_lr11xx_bsp_get_tx_cfg(context,&tx_cfg_input_params,&tx_cfg_output_params);
  ral_lr11xx_bsp_get_reg_mode(context,&radio_reg_mode);
  rVar1 = ral_lr11xx_bsp_get_instantaneous_tx_power_consumption
                    (context,&tx_cfg_output_params,radio_reg_mode,pwr_consumption_in_ua);
  return rVar1;
}



ral_status_t
ral_lr11xx_get_gfsk_rx_consumption_in_ua
          (void *context,uint32_t br_in_bps,uint32_t bw_dsb_in_hz,_Bool rx_boosted,
          uint32_t *pwr_consumption_in_ua)
{
  ral_status_t rVar1;
  _Bool rx_boosted_local;
  uint32_t bw_dsb_in_hz_local;
  uint32_t br_in_bps_local;
  void *context_local;
  lr11xx_system_reg_mode_t radio_reg_mode;
  
  ral_lr11xx_bsp_get_reg_mode(context,&radio_reg_mode);
  rVar1 = ral_lr11xx_bsp_get_instantaneous_gfsk_rx_power_consumption
                    (context,radio_reg_mode,rx_boosted,pwr_consumption_in_ua);
  return rVar1;
}



ral_status_t
ral_lr11xx_get_lora_rx_consumption_in_ua
          (void *context,ral_lora_bw_t bw,_Bool rx_boosted,uint32_t *pwr_consumption_in_ua)
{
  ral_status_t rVar1;
  uint32_t *pwr_consumption_in_ua_local;
  _Bool rx_boosted_local;
  ral_lora_bw_t bw_local;
  void *context_local;
  lr11xx_system_reg_mode_t radio_reg_mode;
  
  ral_lr11xx_bsp_get_reg_mode(context,&radio_reg_mode);
  rVar1 = ral_lr11xx_bsp_get_instantaneous_lora_rx_power_consumption
                    (context,radio_reg_mode,rx_boosted,pwr_consumption_in_ua);
  return rVar1;
}



ral_status_t ral_lr11xx_get_random_numbers(void *context,uint32_t *numbers,uint n)
{
  uint n_local;
  uint32_t *numbers_local;
  void *context_local;
  uint i;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  i = 0;
  while ((i < n && (status = lr11xx_system_get_random_number(context,numbers + i),
                   status == LR11XX_STATUS_OK)))
  {
    i += 1;
  }
  return status;
}



ral_status_t ral_lr11xx_handle_rx_done(void *context)
{
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t ral_lr11xx_handle_tx_done(void *context)
{
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_get_lora_cad_det_peak
          (void *context,ral_lora_sf_t sf,ral_lora_bw_t bw,ral_lora_cad_symbs_t nb_symbol,
          uint8_t *cad_det_peak)
{
  ral_status_t rVar1;
  uint uVar2;
  ral_lora_cad_symbs_t nb_symbol_local;
  ral_lora_bw_t bw_local;
  ral_lora_sf_t sf_local;
  void *context_local;
  
  if (bw < RAL_LORA_BW_500_KHZ)
  {
    if (bw < RAL_LORA_BW_250_KHZ)
    {
      if (bw < RAL_LORA_BW_125_KHZ)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      switch(sf)
      {
      case RAL_LORA_SF5:
        *cad_det_peak = '8';
        break;
      case RAL_LORA_SF6:
        *cad_det_peak = '4';
        break;
      case RAL_LORA_SF7:
        *cad_det_peak = '4';
        break;
      case RAL_LORA_SF8:
        *cad_det_peak = ':';
        break;
      case RAL_LORA_SF9:
        *cad_det_peak = ':';
        break;
      case RAL_LORA_SF10:
        *cad_det_peak = '>';
        break;
      case RAL_LORA_SF11:
        *cad_det_peak = 'B';
        break;
      case RAL_LORA_SF12:
        *cad_det_peak = 'D';
        break;
      default:
        return RAL_STATUS_UNKNOWN_VALUE;
      }
    }
    else
    {
      switch(sf)
      {
      case RAL_LORA_SF5:
        *cad_det_peak = '<';
        break;
      case RAL_LORA_SF6:
        *cad_det_peak = '=';
        break;
      case RAL_LORA_SF7:
        *cad_det_peak = '@';
        break;
      case RAL_LORA_SF8:
        *cad_det_peak = 'H';
        break;
      case RAL_LORA_SF9:
        *cad_det_peak = '?';
        break;
      case RAL_LORA_SF10:
        *cad_det_peak = 'G';
        break;
      case RAL_LORA_SF11:
        *cad_det_peak = 'I';
        break;
      case RAL_LORA_SF12:
        *cad_det_peak = 'K';
        break;
      default:
        return RAL_STATUS_UNKNOWN_VALUE;
      }
    }
  }
  else
  {
    switch(sf)
    {
    case RAL_LORA_SF5:
      *cad_det_peak = 'A';
      break;
    case RAL_LORA_SF6:
      *cad_det_peak = 'F';
      break;
    case RAL_LORA_SF7:
      *cad_det_peak = 'M';
      break;
    case RAL_LORA_SF8:
      *cad_det_peak = 'U';
      break;
    case RAL_LORA_SF9:
      *cad_det_peak = 'N';
      break;
    case RAL_LORA_SF10:
      *cad_det_peak = 'P';
      break;
    case RAL_LORA_SF11:
      *cad_det_peak = 'O';
      break;
    case RAL_LORA_SF12:
      *cad_det_peak = 'R';
      break;
    default:
      return RAL_STATUS_UNKNOWN_VALUE;
    }
  }
  uVar2 = (uint)nb_symbol;
  if (4 < uVar2) goto LAB_08023f24;
  if (uVar2 < 3)
  {
    if (uVar2 < 2)
    {
      if (-1 < (int)uVar2) goto LAB_08023f2a;
    }
    else if (uVar2 == 2)
    {
      *cad_det_peak = *cad_det_peak + 0xff;
      goto LAB_08023f2a;
    }
LAB_08023f24:
    rVar1 = RAL_STATUS_UNKNOWN_VALUE;
  }
  else
  {
    *cad_det_peak = *cad_det_peak + 0xfe;
LAB_08023f2a:
    ral_lr11xx_bsp_get_lora_cad_det_peak(context,sf,bw,nb_symbol,cad_det_peak);
    rVar1 = RAL_STATUS_OK;
  }
  return rVar1;
}



ral_irq_t ral_lr11xx_convert_irq_flags_to_ral(lr11xx_system_irq_mask_t lr11xx_irq_status)
{
  lr11xx_system_irq_mask_t lr11xx_irq_status_local;
  ral_irq_t ral_irq;
  
  ral_irq = 0;
  if ((lr11xx_irq_status & 4) != 0)
  {
    ral_irq = 2;
  }
  if ((lr11xx_irq_status & 8) != 0)
  {
    ral_irq |= 4;
  }
  if ((lr11xx_irq_status & 0x10) != 0)
  {
    ral_irq |= 0x10;
  }
  if ((lr11xx_irq_status & 0x400) != 0)
  {
    ral_irq |= 8;
  }
  if ((lr11xx_irq_status & 0x20) != 0)
  {
    ral_irq |= 0x20;
  }
  if ((lr11xx_irq_status & 0x40) != 0)
  {
    ral_irq |= 0x40;
  }
  if ((lr11xx_irq_status & 0x80) != 0)
  {
    ral_irq |= 0x80;
  }
  if ((lr11xx_irq_status & 0x100) != 0)
  {
    ral_irq |= 0x100;
  }
  if ((lr11xx_irq_status & 0x200) != 0)
  {
    ral_irq |= 0x200;
  }
  if ((lr11xx_irq_status & 0x800) != 0)
  {
    ral_irq |= 0x400;
  }
  if ((lr11xx_irq_status & 0x100000) != 0)
  {
    ral_irq |= 0x800;
  }
  if ((lr11xx_irq_status & 0x80000) != 0)
  {
    ral_irq |= 0x1000;
  }
  if ((lr11xx_irq_status & 0x8000) != 0)
  {
    ral_irq |= 0x10000;
  }
  if ((lr11xx_irq_status & 0x10000) != 0)
  {
    ral_irq |= 0x20000;
  }
  if ((lr11xx_irq_status & 0x20000) != 0)
  {
    ral_irq |= 0x40000;
  }
  if ((lr11xx_irq_status & 0x40000) != 0)
  {
    ral_irq |= 0x80000;
  }
  return ral_irq;
}



lr11xx_system_irq_mask_t ral_lr11xx_convert_irq_flags_from_ral(ral_irq_t ral_irq)
{
  ral_irq_t ral_irq_local;
  lr11xx_system_irq_mask_t lr11xx_irq_status;
  
  lr11xx_irq_status = 0;
  if ((ral_irq & 2) != 0)
  {
    lr11xx_irq_status = 4;
  }
  if ((ral_irq & 4) != 0)
  {
    lr11xx_irq_status |= 8;
  }
  if ((ral_irq & 0x10) != 0)
  {
    lr11xx_irq_status |= 0x10;
  }
  if ((ral_irq & 8) != 0)
  {
    lr11xx_irq_status |= 0x400;
  }
  if ((ral_irq & 0x20) != 0)
  {
    lr11xx_irq_status |= 0x20;
  }
  if ((ral_irq & 0x40) != 0)
  {
    lr11xx_irq_status |= 0x40;
  }
  if ((ral_irq & 0x80) != 0)
  {
    lr11xx_irq_status |= 0x80;
  }
  if ((ral_irq & 0x100) != 0)
  {
    lr11xx_irq_status |= 0x100;
  }
  if ((ral_irq & 0x200) != 0)
  {
    lr11xx_irq_status |= 0x200;
  }
  if ((ral_irq & 0x400) != 0)
  {
    lr11xx_irq_status |= 0x800;
  }
  if ((ral_irq & 0x800) != 0)
  {
    lr11xx_irq_status |= 0x100000;
  }
  if ((ral_irq & 0x1000) != 0)
  {
    lr11xx_irq_status |= 0x80000;
  }
  if ((ral_irq & 0x10000) != 0)
  {
    lr11xx_irq_status |= 0x8000;
  }
  if ((ral_irq & 0x20000) != 0)
  {
    lr11xx_irq_status |= 0x10000;
  }
  if ((ral_irq & 0x40000) != 0)
  {
    lr11xx_irq_status |= 0x20000;
  }
  if ((ral_irq & 0x80000) != 0)
  {
    lr11xx_irq_status |= 0x40000;
  }
  return lr11xx_irq_status;
}



ral_status_t
ral_lr11xx_convert_gfsk_mod_params_from_ral
          (ral_gfsk_mod_params_t *ral_mod_params,lr11xx_radio_mod_params_gfsk_t *radio_mod_params)
{
  lr11xx_status_t lVar1;
  lr11xx_radio_mod_params_gfsk_t *radio_mod_params_local;
  ral_gfsk_mod_params_t *ral_mod_params_local;
  lr11xx_radio_gfsk_bw_t bw_dsb_param;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  lVar1 = lr11xx_radio_get_gfsk_rx_bandwidth(ral_mod_params->bw_dsb_in_hz,&bw_dsb_param);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    radio_mod_params->br_in_bps = ral_mod_params->br_in_bps;
    radio_mod_params->fdev_in_hz = ral_mod_params->fdev_in_hz;
    radio_mod_params->bw_dsb_param = bw_dsb_param;
    switch(ral_mod_params->pulse_shape)
    {
    case RAL_GFSK_PULSE_SHAPE_OFF:
      radio_mod_params->pulse_shape = LR11XX_RADIO_GFSK_PULSE_SHAPE_OFF;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_03:
      radio_mod_params->pulse_shape = LR11XX_RADIO_GFSK_PULSE_SHAPE_BT_03;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_05:
      radio_mod_params->pulse_shape = LR11XX_RADIO_GFSK_PULSE_SHAPE_BT_05;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_07:
      radio_mod_params->pulse_shape = LR11XX_RADIO_GFSK_PULSE_SHAPE_BT_07;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_1:
      radio_mod_params->pulse_shape = LR11XX_RADIO_GFSK_PULSE_SHAPE_BT_1;
      break;
    default:
      lVar1 = 2;
    }
  }
  return lVar1;
}



ral_status_t
ral_lr11xx_convert_gfsk_pkt_params_from_ral
          (ral_gfsk_pkt_params_t *ral_pkt_params,lr11xx_radio_pkt_params_gfsk_t *radio_pkt_params)
{
  ral_gfsk_address_filtering_t rVar1;
  ral_gfsk_pkt_len_modes_t rVar2;
  ral_gfsk_dc_free_t rVar3;
  lr11xx_radio_pkt_params_gfsk_t *radio_pkt_params_local;
  ral_gfsk_pkt_params_t *ral_pkt_params_local;
  
  radio_pkt_params->preamble_len_in_bits = ral_pkt_params->preamble_len_in_bits;
  if (true)
  {
    switch(ral_pkt_params->preamble_detector)
    {
    case RAL_GFSK_PREAMBLE_DETECTOR_OFF:
      radio_pkt_params->preamble_detector = LR11XX_RADIO_GFSK_PREAMBLE_DETECTOR_OFF;
      break;
    default:
      goto LAB_08024424;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_8BITS:
      radio_pkt_params->preamble_detector = LR11XX_RADIO_GFSK_PREAMBLE_DETECTOR_MIN_8BITS;
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS:
      radio_pkt_params->preamble_detector = LR11XX_RADIO_GFSK_PREAMBLE_DETECTOR_MIN_16BITS;
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_24BITS:
      radio_pkt_params->preamble_detector = LR11XX_RADIO_GFSK_PREAMBLE_DETECTOR_MIN_24BITS;
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_32BITS:
      radio_pkt_params->preamble_detector = LR11XX_RADIO_GFSK_PREAMBLE_DETECTOR_MIN_32BITS;
    }
    radio_pkt_params->sync_word_len_in_bits = ral_pkt_params->sync_word_len_in_bits;
    rVar1 = ral_pkt_params->address_filtering;
    if (rVar1 == RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES)
    {
      radio_pkt_params->address_filtering =
           LR11XX_RADIO_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES;
    }
    else
    {
      if (RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES < rVar1)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      if (rVar1 == RAL_GFSK_ADDRESS_FILTERING_DISABLE)
      {
        radio_pkt_params->address_filtering = LR11XX_RADIO_GFSK_ADDRESS_FILTERING_DISABLE;
      }
      else
      {
        if (rVar1 != RAL_GFSK_ADDRESS_FILTERING_NODE_ADDRESS)
        {
          return RAL_STATUS_UNKNOWN_VALUE;
        }
        radio_pkt_params->address_filtering = LR11XX_RADIO_GFSK_ADDRESS_FILTERING_NODE_ADDRESS;
      }
    }
    rVar2 = ral_pkt_params->header_type;
    if (rVar2 == RAL_GFSK_PKT_VAR_LEN_SX128X_COMP)
    {
      radio_pkt_params->header_type = LR11XX_RADIO_GFSK_PKT_VAR_LEN_SX128X_COMP;
    }
    else
    {
      if (RAL_GFSK_PKT_VAR_LEN_SX128X_COMP < rVar2)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      if (rVar2 == RAL_GFSK_PKT_FIX_LEN)
      {
        radio_pkt_params->header_type = LR11XX_RADIO_GFSK_PKT_FIX_LEN;
      }
      else
      {
        if (rVar2 != RAL_GFSK_PKT_VAR_LEN)
        {
          return RAL_STATUS_UNKNOWN_VALUE;
        }
        radio_pkt_params->header_type = LR11XX_RADIO_GFSK_PKT_VAR_LEN;
      }
    }
    radio_pkt_params->pld_len_in_bytes = (uint8_t)ral_pkt_params->pld_len_in_bytes;
    switch(ral_pkt_params->crc_type)
    {
    case RAL_GFSK_CRC_OFF:
      radio_pkt_params->crc_type = LR11XX_RADIO_GFSK_CRC_OFF;
      break;
    case RAL_GFSK_CRC_1_BYTE:
      radio_pkt_params->crc_type = LR11XX_RADIO_GFSK_CRC_1_BYTE;
      break;
    case RAL_GFSK_CRC_2_BYTES:
      radio_pkt_params->crc_type = LR11XX_RADIO_GFSK_CRC_2_BYTES;
      break;
    case RAL_GFSK_CRC_1_BYTE_INV:
      radio_pkt_params->crc_type = LR11XX_RADIO_GFSK_CRC_1_BYTE_INV;
      break;
    case RAL_GFSK_CRC_2_BYTES_INV:
      radio_pkt_params->crc_type = LR11XX_RADIO_GFSK_CRC_2_BYTES_INV;
      break;
    default:
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    rVar3 = ral_pkt_params->dc_free;
    if (rVar3 == RAL_GFSK_DC_FREE_WHITENING_SX128X_COMP)
    {
      radio_pkt_params->dc_free = LR11XX_RADIO_GFSK_DC_FREE_WHITENING_SX128X_COMP;
    }
    else
    {
      if (RAL_GFSK_DC_FREE_WHITENING_SX128X_COMP < rVar3)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      if (rVar3 == RAL_GFSK_DC_FREE_OFF)
      {
        radio_pkt_params->dc_free = LR11XX_RADIO_GFSK_DC_FREE_OFF;
      }
      else
      {
        if (rVar3 != RAL_GFSK_DC_FREE_WHITENING)
        {
          return RAL_STATUS_UNKNOWN_VALUE;
        }
        radio_pkt_params->dc_free = LR11XX_RADIO_GFSK_DC_FREE_WHITENING;
      }
    }
    return RAL_STATUS_OK;
  }
LAB_08024424:
  return RAL_STATUS_UNKNOWN_VALUE;
}



ral_status_t
ral_lr11xx_convert_lora_mod_params_from_ral
          (ral_lora_mod_params_t *ral_mod_params,lr11xx_radio_mod_params_lora_t *radio_mod_params)
{
  lr11xx_radio_mod_params_lora_t *radio_mod_params_local;
  ral_lora_mod_params_t *ral_mod_params_local;
  
  radio_mod_params->sf = ral_mod_params->sf;
  switch(ral_mod_params->bw)
  {
  case RAL_LORA_BW_010_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_10;
    break;
  case RAL_LORA_BW_015_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_15;
    break;
  case RAL_LORA_BW_020_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_20;
    break;
  case RAL_LORA_BW_031_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_31;
    break;
  case RAL_LORA_BW_041_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_41;
    break;
  case RAL_LORA_BW_062_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_62;
    break;
  case RAL_LORA_BW_125_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_125;
    break;
  case RAL_LORA_BW_200_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_200;
    break;
  case RAL_LORA_BW_250_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_250;
    break;
  case RAL_LORA_BW_400_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_400;
    break;
  case RAL_LORA_BW_500_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_500;
    break;
  case RAL_LORA_BW_800_KHZ:
    radio_mod_params->bw = LR11XX_RADIO_LORA_BW_800;
    break;
  default:
    return RAL_STATUS_UNKNOWN_VALUE;
  }
  radio_mod_params->cr = ral_mod_params->cr;
  radio_mod_params->ldro = ral_mod_params->ldro;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_convert_lora_pkt_params_from_ral
          (ral_lora_pkt_params_t *ral_pkt_params,lr11xx_radio_pkt_params_lora_t *radio_pkt_params)
{
  lr11xx_radio_pkt_params_lora_t *radio_pkt_params_local;
  ral_lora_pkt_params_t *ral_pkt_params_local;
  
  radio_pkt_params->preamble_len_in_symb = ral_pkt_params->preamble_len_in_symb;
  if (ral_pkt_params->header_type == RAL_LORA_PKT_EXPLICIT)
  {
    radio_pkt_params->header_type = LR11XX_RADIO_LORA_PKT_EXPLICIT;
  }
  else
  {
    if (ral_pkt_params->header_type != RAL_LORA_PKT_IMPLICIT)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    radio_pkt_params->header_type = LR11XX_RADIO_LORA_PKT_IMPLICIT;
  }
  radio_pkt_params->pld_len_in_bytes = ral_pkt_params->pld_len_in_bytes;
  radio_pkt_params->crc = ral_pkt_params->crc_is_on == true;
  radio_pkt_params->iq = ral_pkt_params->invert_iq_is_on == true;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr11xx_convert_lora_cad_params_from_ral
          (ral_lora_cad_params_t *ral_lora_cad_params,
          lr11xx_radio_cad_params_t *radio_lora_cad_params)
{
  ral_lora_cad_exit_modes_t rVar1;
  uint32_t uVar2;
  lr11xx_radio_cad_params_t *radio_lora_cad_params_local;
  ral_lora_cad_params_t *ral_lora_cad_params_local;
  
  switch(ral_lora_cad_params->cad_symb_nb)
  {
  case RAL_LORA_CAD_01_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x01';
    break;
  case RAL_LORA_CAD_02_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x02';
    break;
  case RAL_LORA_CAD_04_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x04';
    break;
  case RAL_LORA_CAD_08_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\b';
    break;
  case RAL_LORA_CAD_16_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x10';
    break;
  default:
    return RAL_STATUS_UNKNOWN_VALUE;
  }
  radio_lora_cad_params->cad_detect_peak = ral_lora_cad_params->cad_det_peak_in_symb;
  radio_lora_cad_params->cad_detect_min = ral_lora_cad_params->cad_det_min_in_symb;
  rVar1 = ral_lora_cad_params->cad_exit_mode;
  if (rVar1 == RAL_LORA_CAD_LBT)
  {
    radio_lora_cad_params->cad_exit_mode = LR11XX_RADIO_CAD_EXIT_MODE_TX;
  }
  else
  {
    if (RAL_LORA_CAD_LBT < rVar1)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    if (rVar1 == RAL_LORA_CAD_ONLY)
    {
      radio_lora_cad_params->cad_exit_mode = LR11XX_RADIO_CAD_EXIT_MODE_STANDBYRC;
    }
    else
    {
      if (rVar1 != RAL_LORA_CAD_RX)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      radio_lora_cad_params->cad_exit_mode = LR11XX_RADIO_CAD_EXIT_MODE_RX;
    }
  }
  uVar2 = lr11xx_radio_convert_time_in_ms_to_rtc_step(ral_lora_cad_params->cad_timeout_in_ms);
  radio_lora_cad_params->cad_timeout = uVar2;
  return RAL_STATUS_OK;
}



void ral_lr11xx_convert_lr_fhss_params_from_ral
               (ral_lr_fhss_params_t *ral_lr_fhss_params,
               lr11xx_lr_fhss_params_t *radio_lr_fhss_params)
{
  int8_t iVar1;
  lr_fhss_v1_modulation_type_t lVar2;
  lr_fhss_v1_cr_t lVar3;
  lr_fhss_v1_grid_t lVar4;
  lr_fhss_v1_bw_t lVar5;
  _Bool _Var6;
  uint8_t uVar7;
  undefined2 uVar8;
  lr11xx_lr_fhss_params_t *radio_lr_fhss_params_local;
  ral_lr_fhss_params_t *ral_lr_fhss_params_local;
  
  lVar2 = (ral_lr_fhss_params->lr_fhss_params).modulation_type;
  lVar3 = (ral_lr_fhss_params->lr_fhss_params).cr;
  lVar4 = (ral_lr_fhss_params->lr_fhss_params).grid;
  lVar5 = (ral_lr_fhss_params->lr_fhss_params).bw;
  _Var6 = (ral_lr_fhss_params->lr_fhss_params).enable_hopping;
  uVar7 = (ral_lr_fhss_params->lr_fhss_params).header_count;
  uVar8 = *(undefined2 *)&(ral_lr_fhss_params->lr_fhss_params).field_0xa;
  iVar1 = ral_lr_fhss_params->device_offset;
  (radio_lr_fhss_params->lr_fhss_params).sync_word = (ral_lr_fhss_params->lr_fhss_params).sync_word;
  (radio_lr_fhss_params->lr_fhss_params).modulation_type = lVar2;
  (radio_lr_fhss_params->lr_fhss_params).cr = lVar3;
  (radio_lr_fhss_params->lr_fhss_params).grid = lVar4;
  (radio_lr_fhss_params->lr_fhss_params).bw = lVar5;
  (radio_lr_fhss_params->lr_fhss_params).enable_hopping = _Var6;
  (radio_lr_fhss_params->lr_fhss_params).header_count = uVar7;
  *(undefined2 *)&(radio_lr_fhss_params->lr_fhss_params).field_0xa = uVar8;
  radio_lr_fhss_params->device_offset = iVar1;
  return;
}



ral_status_t ral_lr11xx_rttof_set_parameters(void *context,uint8_t nb_symbols)
{
  lr11xx_status_t lVar1;
  uint8_t nb_symbols_local;
  void *context_local;
  
  lVar1 = lr11xx_rttof_set_parameters(context,nb_symbols);
  return lVar1;
}



ral_status_t ral_lr11xx_rttof_set_request_address(void *context,uint32_t request_address)
{
  lr11xx_status_t lVar1;
  uint32_t request_address_local;
  void *context_local;
  
  lVar1 = lr11xx_rttof_set_request_address(context,request_address);
  return lVar1;
}



ral_status_t ral_lr11xx_rttof_set_rx_tx_delay_indicator(void *context,uint32_t delay_indicator)
{
  lr11xx_status_t lVar1;
  uint32_t delay_indicator_local;
  void *context_local;
  
  lVar1 = lr11xx_rttof_set_rx_tx_delay_indicator(context,delay_indicator);
  return lVar1;
}



ral_status_t
ral_lr11xx_rttof_get_raw_result
          (void *context,ral_lora_bw_t rttof_bw,int32_t *raw_results,int32_t *meter_results,
          int8_t *rssi_result)
{
  lr11xx_status_t lVar1;
  int8_t iVar2;
  int32_t iVar3;
  int32_t *meter_results_local;
  int32_t *raw_results_local;
  ral_lora_bw_t rttof_bw_local;
  void *context_local;
  uint8_t buf [4];
  lr11xx_radio_mod_params_lora_t radio_mod_params;
  ral_lora_mod_params_t temp;
  uint8_t raw_results_tmp [4];
  uint8_t unused;
  ral_status_t status;
  
  raw_results_tmp[0] = '\0';
  raw_results_tmp[1] = '\0';
  raw_results_tmp[2] = '\0';
  raw_results_tmp[3] = '\0';
  lVar1 = lr11xx_rttof_get_raw_result(context,LR11XX_RTTOF_RESULT_TYPE_RAW,raw_results_tmp);
  if (lVar1 == LR11XX_STATUS_OK)
  {
    temp.sf = 0;
    temp.cr = 0;
    temp.ldro = '\0';
    temp.bw = rttof_bw;
    lVar1 = ral_lr11xx_convert_lora_mod_params_from_ral(&temp,&radio_mod_params);
    if (lVar1 == LR11XX_STATUS_OK)
    {
      iVar3 = lr11xx_rttof_distance_raw_to_meter(radio_mod_params.bw,raw_results_tmp);
      *meter_results = iVar3;
      *raw_results = (uint)raw_results_tmp & 0xff |
                     ((uint)raw_results_tmp >> 8 & 0xff) << 8 |
                     (uint)raw_results_tmp & 0xff000000 |
                     ((uint)raw_results_tmp >> 0x10 & 0xff) << 0x10;
      lVar1 = lr11xx_rttof_get_raw_result(context,LR11XX_RTTOF_RESULT_TYPE_RSSI,buf);
      if (lVar1 == LR11XX_STATUS_OK)
      {
        iVar2 = lr11xx_rttof_rssi_raw_to_value(buf);
        *rssi_result = iVar2;
      }
    }
  }
  return lVar1;
}



ral_status_t ral_lr11xx_rttof_set_address(void *context,uint32_t address,uint8_t check_length)
{
  lr11xx_status_t lVar1;
  uint8_t check_length_local;
  uint32_t address_local;
  void *context_local;
  
  lVar1 = lr11xx_rttof_set_address(context,address,check_length);
  return lVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1110mb1dis_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  psVar1 = smtc_shield_lr1110mb1dxs_common_get_pa_pwr_cfg(rf_freq_in_hz,expected_output_pwr_in_dbm);
  return psVar1;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1110mb1dis_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1110mb1dis_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1110mb1dis_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1110mb1dis_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x0_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1110mb1dis_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1110mb1dis_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1110mb1djs_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  psVar1 = smtc_shield_lr1110mb1dxs_common_get_pa_pwr_cfg(rf_freq_in_hz,expected_output_pwr_in_dbm);
  return psVar1;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1110mb1djs_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1110mb1djs_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1110mb1djs_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1110mb1djs_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x0_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1110mb1djs_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1110mb1djs_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1110mb1gis_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  psVar1 = smtc_shield_lr1110mb1gxs_common_get_pa_pwr_cfg(rf_freq_in_hz,expected_output_pwr_in_dbm);
  return psVar1;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1110mb1gis_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1110mb1gis_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1110mb1gis_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1110mb1gis_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x0_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1110mb1gis_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1110mb1gis_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1110mb1gjs_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  psVar1 = smtc_shield_lr1110mb1gxs_common_get_pa_pwr_cfg(rf_freq_in_hz,expected_output_pwr_in_dbm);
  return psVar1;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1110mb1gjs_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1110mb1gjs_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1110mb1gjs_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1110mb1gjs_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x0_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1110mb1gjs_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1110mb1gjs_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1120mb1dis_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  psVar1 = smtc_shield_lr1120mb1dxs_common_get_pa_pwr_cfg(rf_freq_in_hz,expected_output_pwr_in_dbm);
  return psVar1;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1120mb1dis_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1120mb1dis_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1120mb1dis_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1120mb1dis_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x0_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1120mb1dis_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1120mb1dis_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1120mb1djs_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  smtc_shield_lr11xx_pa_pwr_cfg_t *psVar1;
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  psVar1 = smtc_shield_lr1120mb1dxs_common_get_pa_pwr_cfg(rf_freq_in_hz,expected_output_pwr_in_dbm);
  return psVar1;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1120mb1djs_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1120mb1djs_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1120mb1djs_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1120mb1djs_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x0_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1120mb1djs_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1120mb1djs_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1121mb1dis_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  if ((rf_freq_in_hz < 150000000) || (960000000 < rf_freq_in_hz))
  {
    if ((((1999999999 < rf_freq_in_hz) && (rf_freq_in_hz < 0x7d2b7501)) ||
        ((2399999999 < rf_freq_in_hz && (rf_freq_in_hz < 0x9502f901)))) &&
       ((expected_output_pwr_in_dbm + 0x12 < 0 == SCARRY4((int)expected_output_pwr_in_dbm,0x12) &&
        (expected_output_pwr_in_dbm < '\x0e'))))
    {
      return smtc_shield_lr1121mb1dis_pa_pwr_hf_cfg_table + expected_output_pwr_in_dbm + 0x12;
    }
  }
  else if ((expected_output_pwr_in_dbm + 0x11 < 0 == SCARRY4((int)expected_output_pwr_in_dbm,0x11))
          && (expected_output_pwr_in_dbm < '\x17'))
  {
    return smtc_shield_lr1121mb1dis_pa_pwr_cfg_table + expected_output_pwr_in_dbm + 0x11;
  }
  return (smtc_shield_lr11xx_pa_pwr_cfg_t *)0x0;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1121mb1dis_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1121mb1dis_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1121mb1dis_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1121mb1dis_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x1_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1121mb1dis_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1121mb1dis_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



smtc_shield_lr11xx_pa_pwr_cfg_t *
smtc_shield_lr1121mb1gis_get_pa_pwr_cfg(uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_dbm)
{
  int8_t expected_output_pwr_in_dbm_local;
  uint32_t rf_freq_in_hz_local;
  
  if ((rf_freq_in_hz < 150000000) || (960000000 < rf_freq_in_hz))
  {
    if ((((1999999999 < rf_freq_in_hz) && (rf_freq_in_hz < 0x7d2b7501)) ||
        ((2399999999 < rf_freq_in_hz && (rf_freq_in_hz < 0x9502f901)))) &&
       ((expected_output_pwr_in_dbm + 0x12 < 0 == SCARRY4((int)expected_output_pwr_in_dbm,0x12) &&
        (expected_output_pwr_in_dbm < '\x0e'))))
    {
      return smtc_shield_lr1121mb1gis_pa_pwr_hf_cfg_table + expected_output_pwr_in_dbm + 0x12;
    }
  }
  else if ((expected_output_pwr_in_dbm + 0x11 < 0 == SCARRY4((int)expected_output_pwr_in_dbm,0x11))
          && (expected_output_pwr_in_dbm < '\x17'))
  {
    return smtc_shield_lr1121mb1gis_pa_pwr_cfg_table + expected_output_pwr_in_dbm + 0x11;
  }
  return (smtc_shield_lr11xx_pa_pwr_cfg_t *)0x0;
}



lr11xx_radio_rssi_calibration_table_t *
smtc_shield_lr1121mb1gis_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr11xx_radio_rssi_calibration_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr11xx_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_rfswitch_cfg_t * smtc_shield_lr1121mb1gis_get_rf_switch_cfg(void)
{
  lr11xx_system_rfswitch_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr11xx_common_get_rf_switch_cfg();
  return plVar1;
}



// WARNING: Unknown calling convention

lr11xx_system_reg_mode_t smtc_shield_lr1121mb1gis_get_reg_mode(void)
{
  lr11xx_system_reg_mode_t lVar1;
  
  lVar1 = smtc_shield_lr11xx_common_get_reg_mode();
  return lVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_xosc_cfg_t * smtc_shield_lr1121mb1gis_get_xosc_cfg(void)
{
  smtc_shield_lr11xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11x1_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_lfclk_cfg_t * smtc_shield_lr1121mb1gis_get_lfclk_cfg(void)
{
  smtc_shield_lr11xx_lfclk_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_lfclk_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr11xx_pinout_t * smtc_shield_lr1121mb1gis_get_pinout(void)
{
  smtc_shield_lr11xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr11xx_common_get_pinout();
  return psVar1;
}



lr20xx_status_t lr20xx_system_reset(void *context)
{
  lr20xx_hal_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_hal_reset(context);
  return lVar1;
}



lr20xx_status_t lr20xx_system_wakeup(void *context)
{
  lr20xx_hal_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_hal_wakeup(context);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_get_status
          (void *context,lr20xx_system_stat1_t *stat1,lr20xx_system_stat2_t *stat2,
          lr20xx_system_irq_mask_t *irq_status)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_irq_mask_t *irq_status_local;
  lr20xx_system_stat2_t *stat2_local;
  lr20xx_system_stat1_t *stat1_local;
  void *context_local;
  uint8_t data [6];
  lr20xx_status_t status;
  
  data[0] = '\0';
  data[1] = '\0';
  data[2] = '\0';
  data[3] = '\0';
  data[4] = '\0';
  data[5] = '\0';
  lVar1 = lr20xx_hal_direct_read(context,data,6);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lr20xx_system_convert_stat1_byte_to_enum(data[0],stat1);
    lr20xx_system_convert_stat2_byte_to_enum(data[1],stat2);
    if (irq_status != (lr20xx_system_irq_mask_t *)0x0)
    {
      *irq_status = (uint)data[5] +
                    (uint)data[4] * 0x100 +
                    ((uint)data._0_4_ >> 0x10) * 0x1000000 + ((uint)data._0_4_ >> 0x18) * 0x10000;
    }
  }
  return lVar1;
}



lr20xx_status_t lr20xx_system_get_version(void *context,lr20xx_system_version_t *version)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_version_t *version_local;
  void *context_local;
  uint8_t rbuffer [2];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x01';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,rbuffer,2);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    version->major = rbuffer[0];
    version->minor = rbuffer[1];
  }
  return lVar1;
}



lr20xx_status_t lr20xx_system_get_errors(void *context,lr20xx_system_errors_t *errors)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_errors_t *errors_local;
  void *context_local;
  uint8_t rbuffer [2];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x10';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,rbuffer,2);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    *errors = ((ushort)rbuffer >> 8) + (short)rbuffer * 0x100;
  }
  return lVar1;
}



lr20xx_status_t lr20xx_system_clear_errors(void *context)
{
  lr20xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x11';
  lVar1 = lr20xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



// WARNING: Unknown calling convention

uint8_t lr20xx_system_dio_get_count(void)
{
  return '\a';
}



_Bool lr20xx_system_dio_get_nth(uint8_t nth,lr20xx_system_dio_t *dio)
{
  byte bVar1;
  lr20xx_system_dio_t *dio_local;
  uint8_t nth_local;
  
  bVar1 = lr20xx_system_dio_get_count();
  if (nth < bVar1)
  {
    *dio = dio_list[nth];
  }
  return nth < bVar1;
}



lr20xx_status_t
lr20xx_system_set_dio_function
          (void *context,lr20xx_system_dio_t dio,lr20xx_system_dio_func_t func,
          lr20xx_system_dio_drive_t drive)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_dio_drive_t drive_local;
  lr20xx_system_dio_func_t func_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x12';
  cbuffer[3] = drive + func * '\x10';
  cbuffer[2] = dio;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_set_dio_rf_switch_cfg
          (void *context,lr20xx_system_dio_t dio,lr20xx_system_dio_rf_switch_cfg_t rf_switch_cfg)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_dio_rf_switch_cfg_t rf_switch_cfg_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x13';
  cbuffer[2] = dio;
  cbuffer[3] = rf_switch_cfg;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_set_dio_irq_cfg
          (void *context,lr20xx_system_dio_t dio,lr20xx_system_irq_mask_t irq_cfg)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_irq_mask_t irq_cfg_local;
  lr20xx_system_dio_t dio_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x15';
  cbuffer[3] = (uint8_t)(irq_cfg >> 0x18);
  cbuffer[4] = (uint8_t)(irq_cfg >> 0x10);
  cbuffer[5] = (uint8_t)(irq_cfg >> 8);
  cbuffer[6] = (uint8_t)irq_cfg;
  cbuffer[2] = dio;
  lVar1 = lr20xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_system_clear_irq_status(void *context,lr20xx_system_irq_mask_t irqs_to_clear)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_irq_mask_t irqs_to_clear_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x16';
  cbuffer[2] = (uint8_t)(irqs_to_clear >> 0x18);
  cbuffer[3] = (uint8_t)(irqs_to_clear >> 0x10);
  cbuffer[4] = (uint8_t)(irqs_to_clear >> 8);
  cbuffer[5] = (uint8_t)irqs_to_clear;
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_system_get_and_clear_irq_status(void *context,lr20xx_system_irq_mask_t *irqs)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_irq_mask_t *irqs_local;
  void *context_local;
  uint8_t rbuffer [4];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x17';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  rbuffer[2] = '\0';
  rbuffer[3] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,rbuffer,4);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    *irqs = ((uint)rbuffer >> 0x18) +
            ((uint)rbuffer >> 0x10 & 0xff) * 0x100 +
            (int)rbuffer * 0x1000000 + ((uint)rbuffer >> 8 & 0xff) * 0x10000;
  }
  return lVar1;
}



lr20xx_status_t lr20xx_system_cfg_lfclk(void *context,lr20xx_system_lfclk_cfg_t lfclock_cfg)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_lfclk_cfg_t lfclock_cfg_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x18';
  cbuffer[2] = lfclock_cfg;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_cfg_clk_output(void *context,lr20xx_system_hf_clk_scaling_t hf_clk_scaling)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_hf_clk_scaling_t hf_clk_scaling_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\x19';
  cbuffer[2] = hf_clk_scaling;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_set_tcxo_mode
          (void *context,lr20xx_system_tcxo_supply_voltage_t tune,uint32_t start_delay_in_rtc_step)
{
  lr20xx_hal_status_t lVar1;
  uint32_t start_delay_in_rtc_step_local;
  lr20xx_system_tcxo_supply_voltage_t tune_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = ' ';
  cbuffer[3] = (uint8_t)(start_delay_in_rtc_step >> 0x18);
  cbuffer[4] = (uint8_t)(start_delay_in_rtc_step >> 0x10);
  cbuffer[5] = (uint8_t)(start_delay_in_rtc_step >> 8);
  cbuffer[6] = (uint8_t)start_delay_in_rtc_step;
  cbuffer[2] = tune;
  lVar1 = lr20xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_system_set_reg_mode(void *context,lr20xx_system_reg_mode_t reg_mode)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_reg_mode_t reg_mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '!';
  cbuffer[2] = reg_mode;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_get_random_number
          (void *context,lr20xx_system_random_entropy_source_bitmask_t source,
          uint32_t *random_number)
{
  lr20xx_hal_status_t lVar1;
  uint32_t *random_number_local;
  lr20xx_system_random_entropy_source_bitmask_t source_local;
  void *context_local;
  uint8_t buffer [4];
  uint8_t cbuffer [3];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '&';
  buffer[0] = '\0';
  buffer[1] = '\0';
  buffer[2] = '\0';
  buffer[3] = '\0';
  cbuffer[2] = source;
  lVar1 = lr20xx_hal_read(context,cbuffer,3,buffer,4);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    *random_number =
         ((uint)buffer >> 0x18) +
         ((uint)buffer >> 0x10 & 0xff) * 0x100 +
         (int)buffer * 0x1000000 + ((uint)buffer >> 8 & 0xff) * 0x10000;
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_system_set_sleep_mode(void *context,lr20xx_system_sleep_cfg_t *sleep_cfg,uint32_t sleep_time)
{
  lr20xx_hal_status_t lVar1;
  char cVar2;
  uint32_t sleep_time_local;
  lr20xx_system_sleep_cfg_t *sleep_cfg_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '\'';
  if (sleep_cfg->is_ram_retention_enabled == false)
  {
    cVar2 = '\0';
  }
  else
  {
    cVar2 = '\x02';
  }
  cbuffer[2] = (sleep_cfg->is_clk_32k_enabled != false) + cVar2;
  cbuffer[3] = (uint8_t)(sleep_time >> 0x18);
  cbuffer[4] = (uint8_t)(sleep_time >> 0x10);
  cbuffer[5] = (uint8_t)(sleep_time >> 8);
  cbuffer[6] = (uint8_t)sleep_time;
  lVar1 = lr20xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_system_set_standby_mode(void *context,lr20xx_system_standby_mode_t standby_mode)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_system_standby_mode_t standby_mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '(';
  cbuffer[2] = standby_mode;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_system_set_fs_mode(void *context)
{
  lr20xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x01';
  cbuffer[1] = ')';
  lVar1 = lr20xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



void lr20xx_system_convert_stat1_byte_to_enum(uint8_t stat1_byte,lr20xx_system_stat1_t *stat1)
{
  lr20xx_system_stat1_t *stat1_local;
  uint8_t stat1_byte_local;
  
  if (stat1 != (lr20xx_system_stat1_t *)0x0)
  {
    stat1->is_interrupt_active = (stat1_byte & 1) != 0;
    stat1->command_status = stat1_byte >> 1;
  }
  return;
}



void lr20xx_system_convert_stat2_byte_to_enum(uint8_t stat2_byte,lr20xx_system_stat2_t *stat2)
{
  lr20xx_system_stat2_t *stat2_local;
  uint8_t stat2_byte_local;
  
  if (stat2 != (lr20xx_system_stat2_t *)0x0)
  {
    stat2->chip_mode = stat2_byte & (LR20XX_SYSTEM_CHIP_MODE_RX|LR20XX_SYSTEM_CHIP_MODE_FS);
    stat2->reset_status = stat2_byte >> 4;
  }
  return;
}



lr20xx_status_t
lr20xx_radio_common_calibrate_front_end
          (void *context,
          lr20xx_radio_common_raw_front_end_calibration_value_t *front_end_calibration_values,
          uint8_t n_front_end_calibration_values)
{
  lr20xx_hal_status_t lVar1;
  uint8_t n_front_end_calibration_values_local;
  lr20xx_radio_common_raw_front_end_calibration_value_t *front_end_calibration_values_local;
  void *context_local;
  uint8_t raw_front_end_calibration_values [6];
  uint8_t cbuffer [2];
  uint8_t rx_path_frequency_index;
  
  cbuffer[0] = '\x01';
  cbuffer[1] = '#';
  raw_front_end_calibration_values[0] = '\0';
  raw_front_end_calibration_values[1] = '\0';
  raw_front_end_calibration_values[2] = '\0';
  raw_front_end_calibration_values[3] = '\0';
  raw_front_end_calibration_values[4] = '\0';
  raw_front_end_calibration_values[5] = '\0';
  for (rx_path_frequency_index = '\0'; rx_path_frequency_index < n_front_end_calibration_values;
      rx_path_frequency_index += '\x01')
  {
    raw_front_end_calibration_values[(uint)rx_path_frequency_index * 2] =
         (uint8_t)(front_end_calibration_values[rx_path_frequency_index] >> 8);
    raw_front_end_calibration_values[(uint)rx_path_frequency_index * 2 + 1] =
         (uint8_t)front_end_calibration_values[rx_path_frequency_index];
  }
  lVar1 = lr20xx_hal_write(context,cbuffer,2,raw_front_end_calibration_values,
                           (ushort)n_front_end_calibration_values << 1);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_calibrate_front_end_helper
          (void *context,
          lr20xx_radio_common_front_end_calibration_value_t *front_end_calibration_structures,
          uint8_t n_front_end_calibration_structures)
{
  lr20xx_status_t lVar1;
  ushort uVar2;
  uint8_t n_front_end_calibration_structures_local;
  lr20xx_radio_common_front_end_calibration_value_t *front_end_calibration_structures_local;
  void *context_local;
  lr20xx_radio_common_raw_front_end_calibration_value_t raw_calibration_values [3];
  uint16_t freq_4mhz;
  lr20xx_radio_common_rx_path_t rx_path;
  uint32_t freq_hz;
  uint8_t front_end_calibration_value_index;
  
  raw_calibration_values[0] = 0;
  raw_calibration_values[1] = 0;
  raw_calibration_values[2] = 0;
  for (front_end_calibration_value_index = '\0';
      front_end_calibration_value_index < n_front_end_calibration_structures;
      front_end_calibration_value_index += '\x01')
  {
    if (front_end_calibration_structures[front_end_calibration_value_index].rx_path ==
        LR20XX_RADIO_COMMON_RX_PATH_HF)
    {
      uVar2 = 0x8000;
    }
    else
    {
      uVar2 = 0;
    }
    raw_calibration_values[front_end_calibration_value_index] =
         (ushort)((front_end_calibration_structures[front_end_calibration_value_index].
                   frequency_in_hertz + 3999999) / 4000000) | uVar2;
  }
  lVar1 = lr20xx_radio_common_calibrate_front_end
                    (context,raw_calibration_values,n_front_end_calibration_structures);
  return lVar1;
}



uint32_t lr20xx_radio_common_convert_time_in_ms_to_rtc_step(uint32_t time_in_ms)
{
  uint32_t time_in_ms_local;
  
  return (time_in_ms << 0xf) / 1000;
}



lr20xx_status_t lr20xx_radio_common_set_rf_freq(void *context,uint32_t freq_in_hz)
{
  lr20xx_hal_status_t lVar1;
  uint32_t freq_in_hz_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\0';
  cbuffer[2] = (uint8_t)(freq_in_hz >> 0x18);
  cbuffer[3] = (uint8_t)(freq_in_hz >> 0x10);
  cbuffer[4] = (uint8_t)(freq_in_hz >> 8);
  cbuffer[5] = (uint8_t)freq_in_hz;
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_rx_path
          (void *context,lr20xx_radio_common_rx_path_t rx_path,
          lr20xx_radio_common_rx_path_boost_mode_t boost_mode)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_rx_path_boost_mode_t boost_mode_local;
  lr20xx_radio_common_rx_path_t rx_path_local;
  void *context_local;
  uint8_t cbuffer [4];
  lr20xx_status_t write_status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x01';
  cbuffer[2] = rx_path;
  cbuffer[3] = boost_mode;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_workarounds_dcdc_configure(context);
  }
  return lVar1;
}



lr20xx_status_t lr20xx_radio_common_set_pa_cfg(void *context,lr20xx_radio_common_pa_cfg_t *pa_cfg)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_pa_cfg_t *pa_cfg_local;
  void *context_local;
  uint8_t cbuffer [5];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x02';
  cbuffer[2] = pa_cfg->pa_lf_mode + pa_cfg->pa_sel * -0x80;
  cbuffer[3] = pa_cfg->pa_lf_slices + pa_cfg->pa_lf_duty_cycle * '\x10';
  cbuffer[4] = pa_cfg->pa_hf_duty_cycle;
  lVar1 = lr20xx_hal_write(context,cbuffer,5,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_tx_params
          (void *context,int8_t power_half_dbm,lr20xx_radio_common_ramp_time_t ramp_time)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_ramp_time_t ramp_time_local;
  int8_t power_half_dbm_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x03';
  cbuffer[2] = power_half_dbm;
  cbuffer[3] = ramp_time;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_rx_tx_fallback_mode
          (void *context,lr20xx_radio_common_fallback_modes_t fallback_mode)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_fallback_modes_t fallback_mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x06';
  cbuffer[2] = fallback_mode;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_pkt_type(void *context,lr20xx_radio_common_pkt_type_t pkt_type)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_pkt_type_t pkt_type_local;
  void *context_local;
  uint8_t cbuffer [3];
  lr20xx_status_t write_status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\a';
  cbuffer[2] = pkt_type;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_workarounds_dcdc_reset(context);
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_get_pkt_type(void *context,lr20xx_radio_common_pkt_type_t *pkt_type)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_pkt_type_t *pkt_type_local;
  void *context_local;
  uint8_t pkt_type_raw;
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\b';
  pkt_type_raw = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,&pkt_type_raw,1);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    *pkt_type = pkt_type_raw;
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_rx_timeout_stop_event(void *context,_Bool is_stopped_on_preamble_detection)
{
  lr20xx_hal_status_t lVar1;
  _Bool is_stopped_on_preamble_detection_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\t';
  cbuffer[2] = is_stopped_on_preamble_detection;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_get_rssi_inst(void *context,int16_t *rssi_in_dbm,uint8_t *half_dbm_count)
{
  lr20xx_hal_status_t lVar1;
  uint8_t *half_dbm_count_local;
  int16_t *rssi_in_dbm_local;
  void *context_local;
  uint8_t rssi_raw [2];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = 0x2;
  cbuffer[1] = 0xb;
  rssi_raw[0] = '\0';
  rssi_raw[1] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,rssi_raw,2);
  if ((lVar1 == LR20XX_HAL_STATUS_OK) &&
     (*rssi_in_dbm = -((ushort)rssi_raw & 0xff), half_dbm_count != (uint8_t *)0x0))
  {
    *half_dbm_count = rssi_raw[1] & 1;
  }
  return lVar1;
}



lr20xx_status_t lr20xx_radio_common_set_rx(void *context,uint32_t timeout_in_ms)
{
  lr20xx_status_t lVar1;
  uint32_t timeout_in_rtc_step;
  uint32_t timeout_in_ms_local;
  void *context_local;
  
  timeout_in_rtc_step = lr20xx_radio_common_convert_time_in_ms_to_rtc_step(timeout_in_ms);
  lVar1 = lr20xx_radio_common_set_rx_with_timeout_in_rtc_step(context,timeout_in_rtc_step);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_rx_with_timeout_in_rtc_step(void *context,uint32_t timeout_in_rtc_step)
{
  lr20xx_hal_status_t lVar1;
  uint32_t timeout_in_rtc_step_local;
  void *context_local;
  uint8_t cbuffer [5];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\f';
  cbuffer[2] = (uint8_t)(timeout_in_rtc_step >> 0x10);
  cbuffer[3] = (uint8_t)(timeout_in_rtc_step >> 8);
  cbuffer[4] = (uint8_t)timeout_in_rtc_step;
  lVar1 = lr20xx_hal_write(context,cbuffer,5,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_common_set_tx(void *context,uint32_t timeout_in_ms)
{
  lr20xx_status_t lVar1;
  uint32_t timeout_in_rtc_step;
  uint32_t timeout_in_ms_local;
  void *context_local;
  
  timeout_in_rtc_step = lr20xx_radio_common_convert_time_in_ms_to_rtc_step(timeout_in_ms);
  lVar1 = lr20xx_radio_common_set_tx_with_timeout_in_rtc_step(context,timeout_in_rtc_step);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_tx_with_timeout_in_rtc_step(void *context,uint32_t timeout_in_rtc_step)
{
  lr20xx_hal_status_t lVar1;
  uint32_t timeout_in_rtc_step_local;
  void *context_local;
  uint8_t cbuffer [5];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\r';
  cbuffer[2] = (uint8_t)(timeout_in_rtc_step >> 0x10);
  cbuffer[3] = (uint8_t)(timeout_in_rtc_step >> 8);
  cbuffer[4] = (uint8_t)timeout_in_rtc_step;
  lVar1 = lr20xx_hal_write(context,cbuffer,5,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_tx_test_mode(void *context,lr20xx_radio_common_tx_test_mode_t mode)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_tx_test_mode_t mode_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x0e';
  cbuffer[2] = mode;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_rx_duty_cycle
          (void *context,uint32_t rx_period_in_ms,uint32_t sleep_period_in_ms,
          lr20xx_radio_common_rx_duty_cycle_mode_t mode)
{
  lr20xx_status_t lVar1;
  uint32_t rx_period_in_rtc_step;
  uint32_t sleep_period_in_rtc_step;
  lr20xx_radio_common_rx_duty_cycle_mode_t mode_local;
  uint32_t sleep_period_in_ms_local;
  uint32_t rx_period_in_ms_local;
  void *context_local;
  
  rx_period_in_rtc_step = lr20xx_radio_common_convert_time_in_ms_to_rtc_step(rx_period_in_ms);
  sleep_period_in_rtc_step = lr20xx_radio_common_convert_time_in_ms_to_rtc_step(sleep_period_in_ms);
  lVar1 = lr20xx_radio_common_set_rx_duty_cycle_with_timing_in_rtc_step
                    (context,rx_period_in_rtc_step,sleep_period_in_rtc_step,mode);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_common_set_rx_duty_cycle_with_timing_in_rtc_step
          (void *context,uint32_t rx_period_in_rtc_step,uint32_t sleep_period_in_rtc_step,
          lr20xx_radio_common_rx_duty_cycle_mode_t mode)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_common_rx_duty_cycle_mode_t mode_local;
  uint32_t sleep_period_in_rtc_step_local;
  uint32_t rx_period_in_rtc_step_local;
  void *context_local;
  uint8_t cbuffer [9];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x10';
  cbuffer[2] = (uint8_t)(rx_period_in_rtc_step >> 0x10);
  cbuffer[3] = (uint8_t)(rx_period_in_rtc_step >> 8);
  cbuffer[4] = (uint8_t)rx_period_in_rtc_step;
  cbuffer[5] = (uint8_t)(sleep_period_in_rtc_step >> 0x10);
  cbuffer[6] = (uint8_t)(sleep_period_in_rtc_step >> 8);
  cbuffer[7] = (uint8_t)sleep_period_in_rtc_step;
  cbuffer[8] = mode << 4;
  lVar1 = lr20xx_hal_write(context,cbuffer,9,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_common_get_rx_packet_length(void *context,uint16_t *pkt_len)
{
  lr20xx_hal_status_t lVar1;
  uint16_t *pkt_len_local;
  void *context_local;
  uint8_t pkt_len_loc [2];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\x12';
  pkt_len_loc[0] = '\0';
  pkt_len_loc[1] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,pkt_len_loc,2);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    *pkt_len = ((ushort)pkt_len_loc >> 8) + (short)pkt_len_loc * 0x100;
  }
  return lVar1;
}



lr20xx_status_t lr20xx_radio_fifo_read_rx(void *context,uint8_t *buffer,uint16_t length)
{
  lr20xx_hal_status_t lVar1;
  uint16_t length_local;
  uint8_t *buffer_local;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\0';
  cbuffer[1] = '\x01';
  lVar1 = lr20xx_hal_direct_read_fifo(context,cbuffer,2,buffer,length);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_fifo_write_tx(void *context,uint8_t *buffer,uint16_t length)
{
  lr20xx_hal_status_t lVar1;
  uint16_t length_local;
  uint8_t *buffer_local;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\0';
  cbuffer[1] = '\x02';
  lVar1 = lr20xx_hal_write(context,cbuffer,2,buffer,length);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_fifo_clear_rx(void *context)
{
  lr20xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = 0x1;
  cbuffer[1] = 0x1e;
  lVar1 = lr20xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_set_modulation_params(void *context,lr20xx_radio_fsk_mod_params_t *mod_params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_fsk_mod_params_t *mod_params_local;
  void *context_local;
  uint8_t cbuffer [11];
  lr20xx_status_t write_status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '@';
  cbuffer[2] = (uint8_t)(mod_params->br >> 0x18);
  cbuffer[3] = (uint8_t)(mod_params->br >> 0x10);
  cbuffer[4] = (uint8_t)(mod_params->br >> 8);
  cbuffer[5] = (uint8_t)mod_params->br;
  cbuffer[6] = mod_params->pulse_shape;
  cbuffer[7] = mod_params->bw;
  cbuffer[8] = (uint8_t)(mod_params->fdev_in_hz >> 0x10);
  cbuffer[9] = (uint8_t)(mod_params->fdev_in_hz >> 8);
  cbuffer[10] = (uint8_t)mod_params->fdev_in_hz;
  lVar1 = lr20xx_hal_write(context,cbuffer,0xb,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_workarounds_dcdc_configure(context);
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_set_packet_params(void *context,lr20xx_radio_fsk_pkt_params_t *pkt_params)
{
  lr20xx_hal_status_t lVar1;
  char cVar2;
  lr20xx_radio_fsk_pkt_params_t *pkt_params_local;
  void *context_local;
  uint8_t cbuffer [9];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'A';
  cbuffer[2] = (uint8_t)(pkt_params->pbl_length_in_bit >> 8);
  cbuffer[3] = (uint8_t)pkt_params->pbl_length_in_bit;
  cbuffer[4] = pkt_params->preamble_detector;
  if (pkt_params->long_preamble_enabled == false)
  {
    cVar2 = '\0';
  }
  else
  {
    cVar2 = ' ';
  }
  cbuffer[5] = pkt_params->header_mode +
               pkt_params->address_filtering * '\x04' +
               pkt_params->payload_length_unit * '\x10' + cVar2;
  cbuffer[6] = (uint8_t)(pkt_params->payload_length >> 8);
  cbuffer[7] = (uint8_t)pkt_params->payload_length;
  cbuffer[8] = pkt_params->whitening + pkt_params->crc * '\x10';
  lVar1 = lr20xx_hal_write(context,cbuffer,9,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_set_whitening_params
          (void *context,lr20xx_radio_fsk_whitening_compatibility_t whitening_type,
          uint16_t whitening_seed)
{
  lr20xx_hal_status_t lVar1;
  uint16_t whitening_seed_local;
  lr20xx_radio_fsk_whitening_compatibility_t whitening_type_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'B';
  cbuffer[2] = ((byte)(whitening_seed >> 8) & 0xf) + whitening_type * '\x10';
  cbuffer[3] = (uint8_t)whitening_seed;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_set_crc_params(void *context,uint32_t crc_polynomial,uint32_t crc_seed)
{
  lr20xx_hal_status_t lVar1;
  uint32_t crc_seed_local;
  uint32_t crc_polynomial_local;
  void *context_local;
  uint8_t cbuffer [10];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'C';
  cbuffer[2] = (uint8_t)(crc_polynomial >> 0x18);
  cbuffer[3] = (uint8_t)(crc_polynomial >> 0x10);
  cbuffer[4] = (uint8_t)(crc_polynomial >> 8);
  cbuffer[5] = (uint8_t)crc_polynomial;
  cbuffer[6] = (uint8_t)(crc_seed >> 0x18);
  cbuffer[7] = (uint8_t)(crc_seed >> 0x10);
  cbuffer[8] = (uint8_t)(crc_seed >> 8);
  cbuffer[9] = (uint8_t)crc_seed;
  lVar1 = lr20xx_hal_write(context,cbuffer,10,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_set_syncword
          (void *context,uint8_t *syncword,uint8_t nb_bits,
          lr20xx_radio_fsk_syncword_bit_order_t bit_order)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_fsk_syncword_bit_order_t bit_order_local;
  uint8_t nb_bits_local;
  uint8_t *syncword_local;
  void *context_local;
  uint8_t cbuffer [11];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'D';
  cbuffer[2] = *syncword;
  cbuffer[3] = syncword[1];
  cbuffer[4] = syncword[2];
  cbuffer[5] = syncword[3];
  cbuffer[6] = syncword[4];
  cbuffer[7] = syncword[5];
  cbuffer[8] = syncword[6];
  cbuffer[9] = syncword[7];
  cbuffer[10] = nb_bits + bit_order * -0x80;
  lVar1 = lr20xx_hal_write(context,cbuffer,0xb,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_set_addresses(void *context,uint8_t node_address,uint8_t broadcast_address)
{
  lr20xx_hal_status_t lVar1;
  uint8_t broadcast_address_local;
  uint8_t node_address_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'E';
  cbuffer[2] = node_address;
  cbuffer[3] = broadcast_address;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_get_packet_status(void *context,lr20xx_radio_fsk_packet_status_t *pkt_status)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_fsk_packet_status_t *pkt_status_local;
  void *context_local;
  uint8_t rbuffer [6];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'G';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  rbuffer[2] = '\0';
  rbuffer[3] = '\0';
  rbuffer[4] = '\0';
  rbuffer[5] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,rbuffer,6);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    pkt_status->packet_length_bytes = (ushort)rbuffer[1] + (ushort)rbuffer[0] * 0x100;
    pkt_status->rssi_avg_in_dbm = -(ushort)rbuffer[2];
    pkt_status->rssi_sync_in_dbm = -(ushort)rbuffer[3];
    pkt_status->is_addr_match_broadcast = (rbuffer[4] >> 5 & 1) != 0;
    pkt_status->is_addr_match_node = (rbuffer[4] >> 4 & 1) != 0;
    pkt_status->rssi_avg_half_dbm_count = rbuffer[4] >> 2 & 1;
    pkt_status->rssi_sync_half_dbm_count = rbuffer[4] & 1;
    pkt_status->link_quality_indicator = rbuffer[5];
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_fsk_get_rx_bandwidth(uint32_t bw_in_hz,lr20xx_radio_fsk_common_bw_t *bw_parameter)
{
  lr20xx_radio_fsk_common_bw_t *bw_parameter_local;
  uint32_t bw_in_hz_local;
  uint8_t i;
  
  i = '\0';
  while( true )
  {
    if (0x58 < i)
    {
      return LR20XX_STATUS_ERROR;
    }
    if (bw_in_hz <= lr20xx_radio_gfsk_bw_values[i].bw_in_hz) break;
    i += '\x01';
  }
  *bw_parameter = lr20xx_radio_gfsk_bw_values[i].param;
  return LR20XX_STATUS_OK;
}



uint32_t lr20xx_radio_fsk_get_time_on_air_numerator
                   (lr20xx_radio_fsk_pkt_params_t *pkt_p,uint8_t syncword_len_in_bit)
{
  lr20xx_radio_fsk_header_mode_t lVar1;
  lr20xx_radio_fsk_address_filtering_t lVar2;
  uint16_t uVar3;
  ushort uVar4;
  uint32_t uVar5;
  uint8_t syncword_len_in_bit_local;
  lr20xx_radio_fsk_pkt_params_t *pkt_p_local;
  uint8_t header_len_in_bits;
  
  lVar1 = pkt_p->header_mode;
  if (lVar1 == LR20XX_RADIO_FSK_HEADER_SX128X_COMPATIBLE)
  {
    header_len_in_bits = '\t';
  }
  else
  {
    if (LR20XX_RADIO_FSK_HEADER_SX128X_COMPATIBLE < lVar1)
    {
      return 0;
    }
    if (lVar1 == LR20XX_RADIO_FSK_HEADER_IMPLICIT)
    {
      header_len_in_bits = '\0';
    }
    else
    {
      if (lVar1 != LR20XX_RADIO_FSK_HEADER_8BITS)
      {
        return 0;
      }
      header_len_in_bits = '\b';
    }
  }
  uVar3 = pkt_p->pbl_length_in_bit;
  uVar4 = pkt_p->payload_length;
  lVar2 = pkt_p->address_filtering;
  uVar5 = lr20xx_radio_fsk_get_crc_len_in_bytes(pkt_p->crc);
  return (uVar5 + (uint)uVar4 + (uint)(lVar2 != LR20XX_RADIO_FSK_ADDRESS_FILTERING_DISABLED)) * 8 +
         ((uint)syncword_len_in_bit + (uint)(ushort)(header_len_in_bits + uVar3) & 0xffff);
}



uint32_t lr20xx_radio_fsk_get_time_on_air_in_ms
                   (lr20xx_radio_fsk_pkt_params_t *pkt_p,lr20xx_radio_fsk_mod_params_t *mod_p,
                   uint8_t syncword_len_in_bit)
{
  uint32_t uVar1;
  uint8_t syncword_len_in_bit_local;
  lr20xx_radio_fsk_mod_params_t *mod_p_local;
  lr20xx_radio_fsk_pkt_params_t *pkt_p_local;
  uint32_t denominator;
  uint32_t numerator;
  
  uVar1 = lr20xx_radio_fsk_get_time_on_air_numerator(pkt_p,syncword_len_in_bit);
  return ((mod_p->br + uVar1 * 1000) - 1) / mod_p->br;
}



uint32_t lr20xx_radio_fsk_get_crc_len_in_bytes(lr20xx_radio_fsk_crc_t crc_type)
{
  uint32_t uVar1;
  lr20xx_radio_fsk_crc_t crc_type_local;
  
  if (false)
  {
switchD_08025d8e_caseD_5:
    uVar1 = 0;
  }
  else
  {
    switch(crc_type)
    {
    case LR20XX_RADIO_FSK_CRC_OFF:
      uVar1 = 0;
      break;
    case LR20XX_RADIO_FSK_CRC_1_BYTE:
      uVar1 = 1;
      break;
    case LR20XX_RADIO_FSK_CRC_2_BYTES:
      uVar1 = 2;
      break;
    case LR20XX_RADIO_FSK_CRC_3_BYTES:
      uVar1 = 3;
      break;
    case LR20XX_RADIO_FSK_CRC_4_BYTES:
      uVar1 = 4;
      break;
    default:
      goto switchD_08025d8e_caseD_5;
    case LR20XX_RADIO_FSK_CRC_1_BYTE_INVERTED:
      uVar1 = 1;
      break;
    case LR20XX_RADIO_FSK_CRC_2_BYTES_INVERTED:
      uVar1 = 2;
      break;
    case LR20XX_RADIO_FSK_CRC_3_BYTES_INVERTED:
      uVar1 = 3;
      break;
    case LR20XX_RADIO_FSK_CRC_4_BYTES_INVERTED:
      uVar1 = 4;
    }
  }
  return uVar1;
}



lr20xx_status_t
lr20xx_radio_lora_set_modulation_params(void *context,lr20xx_radio_lora_mod_params_t *mod_params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_lora_mod_params_t *mod_params_local;
  void *context_local;
  uint8_t cbuffer [4];
  lr20xx_status_t write_status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = ' ';
  cbuffer[2] = mod_params->bw + mod_params->sf * '\x10';
  cbuffer[3] = mod_params->ppm + mod_params->cr * '\x10';
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_workarounds_dcdc_configure(context);
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_lora_set_packet_params(void *context,lr20xx_radio_lora_pkt_params_t *pkt_params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_lora_pkt_params_t *pkt_params_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '!';
  cbuffer[2] = (uint8_t)(pkt_params->preamble_len_in_symb >> 8);
  cbuffer[3] = (uint8_t)pkt_params->preamble_len_in_symb;
  cbuffer[4] = pkt_params->pld_len_in_bytes;
  cbuffer[5] = pkt_params->iq + pkt_params->crc * '\x02' + pkt_params->pkt_mode * '\x04';
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_lora_configure_timeout_by_number_of_symbols(void *context,uint8_t n_symbols)
{
  lr20xx_status_t lVar1;
  uint8_t n_symbols_local;
  void *context_local;
  
  lVar1 = abstract_search_symbols(context,n_symbols,SEARCH_SYMBOL_FORMAT_NUMBER);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_lora_set_syncword(void *context,uint8_t syncword)
{
  lr20xx_hal_status_t lVar1;
  uint8_t syncword_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '#';
  cbuffer[2] = syncword;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_lora_configure_cad_params(void *context,lr20xx_radio_lora_cad_params_t *cad_params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_lora_cad_params_t *cad_params_local;
  void *context_local;
  uint8_t cbuffer [9];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\'';
  cbuffer[2] = cad_params->cad_symb_nb;
  cbuffer[3] = cad_params->pnr_delta;
  cbuffer[4] = cad_params->cad_exit_mode;
  cbuffer[5] = (uint8_t)(cad_params->cad_timeout_in_pll_step >> 0x10);
  cbuffer[6] = (uint8_t)(cad_params->cad_timeout_in_pll_step >> 8);
  cbuffer[7] = (uint8_t)cad_params->cad_timeout_in_pll_step;
  cbuffer[8] = cad_params->cad_detect_peak;
  lVar1 = lr20xx_hal_write(context,cbuffer,9,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_lora_set_cad(void *context)
{
  lr20xx_hal_status_t lVar1;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '(';
  lVar1 = lr20xx_hal_write(context,cbuffer,2,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_lora_get_packet_status(void *context,lr20xx_radio_lora_packet_status_t *pkt_status)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_lora_packet_status_t *pkt_status_local;
  void *context_local;
  uint8_t rbuffer [6];
  uint8_t cbuffer [2];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '*';
  rbuffer[0] = '\0';
  rbuffer[1] = '\0';
  rbuffer[2] = '\0';
  rbuffer[3] = '\0';
  rbuffer[4] = '\0';
  rbuffer[5] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,2,rbuffer,6);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    pkt_status->crc = rbuffer[0] >> 4 & LR20XX_RADIO_LORA_CRC_ENABLED;
    pkt_status->cr =
         rbuffer[0] & (LR20XX_RADIO_LORA_CR_LI_CONVOLUTIONAL_4_6|LR20XX_RADIO_LORA_CR_LI_4_8);
    pkt_status->packet_length_bytes = rbuffer[1];
    pkt_status->snr_pkt_raw = rbuffer[2];
    pkt_status->rssi_pkt_in_dbm = -(ushort)rbuffer[3];
    pkt_status->rssi_signal_pkt_in_dbm = -(rbuffer._4_2_ & 0xff);
    pkt_status->detector = rbuffer[5] >> 2 & 0xf;
    pkt_status->rssi_pkt_half_dbm_count = rbuffer[5] >> 1 & 1;
    pkt_status->rssi_signal_pkt_half_dbm_count = rbuffer[5] & 1;
  }
  return lVar1;
}



uint32_t lr20xx_radio_lora_get_time_on_air_numerator
                   (lr20xx_radio_lora_pkt_params_t *pkt_p,lr20xx_radio_lora_mod_params_t *mod_p)
{
  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  bool bVar11;
  lr20xx_radio_lora_mod_params_t *mod_p_local;
  lr20xx_radio_lora_pkt_params_t *pkt_p_local;
  int32_t intermed;
  int32_t tx_codedbits_header;
  int32_t tx_bits_symbol_start;
  int32_t fec_rate_denominator;
  int32_t fec_rate_numerator;
  int32_t tx_bits_symbol;
  int32_t total_bytes_nb;
  _Bool long_interleaving;
  int32_t fine_synch;
  _Bool pld_is_fix;
  int32_t sf;
  int32_t pld_len_in_bytes;
  int32_t tx_infobits_payload;
  int32_t tx_infobits_header;
  int32_t symbols_nb_data;
  int32_t ceil_denominator;
  int32_t ceil_numerator;
  
  uVar5 = (uint)pkt_p->pld_len_in_bytes;
  uVar6 = (uint)mod_p->sf;
  bVar11 = pkt_p->pkt_mode != LR20XX_RADIO_LORA_PKT_IMPLICIT;
  uVar7 = (uint)(uVar6 < 7);
  bVar1 = mod_p->cr < LR20XX_RADIO_LORA_CR_LI_4_5;
  if (pkt_p->crc == LR20XX_RADIO_LORA_CRC_ENABLED)
  {
    iVar4 = 2;
  }
  else
  {
    iVar4 = 0;
  }
  iVar4 = uVar5 + iVar4;
  if (mod_p->ppm == LR20XX_RADIO_LORA_NO_PPM)
  {
    iVar8 = 0;
  }
  else
  {
    iVar8 = 2;
  }
  iVar8 = uVar6 - iVar8;
  if (bVar1)
  {
    tx_infobits_header = (uVar6 + uVar7 * 2 + -2) * 4;
    if (bVar11)
    {
      tx_infobits_header += -0x14;
    }
    tx_infobits_payload = iVar4 * 8 - tx_infobits_header;
    if (tx_infobits_payload < 0)
    {
      tx_infobits_payload = 0;
    }
    ceil_numerator = tx_infobits_payload;
    ceil_denominator = iVar8 * 4;
  }
  else
  {
    iVar9 = (uint)(mod_p->cr == LR20XX_RADIO_LORA_CR_LI_4_8) + (uint)mod_p->cr;
    if (bVar11)
    {
      tx_infobits_header = (uVar6 + uVar7 * 2 + -7) * 4 & 0xfffffff8;
      if ((tx_infobits_header + iVar4 * -8 < 0 != SBORROW4(tx_infobits_header,iVar4 * 8)) &&
         (tx_infobits_header != uVar5 * 8 &&
          (int)(tx_infobits_header + uVar5 * -8) < 0 == SBORROW4(tx_infobits_header,uVar5 * 8)))
      {
        tx_infobits_header = uVar5 << 3;
      }
      tx_infobits_payload = iVar4 * 8 - tx_infobits_header;
      if (tx_infobits_payload < 0)
      {
        tx_infobits_payload = 0;
      }
      ceil_numerator = iVar8 * 0x20 + iVar9 * tx_infobits_payload;
      ceil_denominator = iVar8 * 4;
    }
    else
    {
      iVar10 = uVar7 * 2 + (uVar6 - 2);
      iVar3 = iVar9 * iVar4 * 8;
      iVar2 = iVar3 + iVar10 * -0x1c;
      if (iVar2 == 0 || iVar2 < 0 != SBORROW4(iVar3,iVar10 * 0x1c))
      {
        ceil_numerator = iVar9 * iVar4 * 8;
        ceil_denominator = iVar10 * 4;
      }
      else
      {
        ceil_numerator = (iVar9 * iVar4 + iVar8 * 4) * 8 + iVar10 * -0x20;
        ceil_denominator = iVar8 * 4;
      }
    }
  }
  symbols_nb_data = (ceil_denominator + ceil_numerator + -1) / ceil_denominator;
  if (bVar1)
  {
    symbols_nb_data = symbols_nb_data * (mod_p->cr + 4) + 8;
  }
  return ((uVar7 * 2 + pkt_p->preamble_len_in_symb + 4 + symbols_nb_data) * 4 + 1 <<
         (uVar6 - 2 & 0xff)) - 1;
}



uint32_t lr20xx_radio_lora_get_bw_in_hz(lr20xx_radio_lora_bw_t bw)
{
  lr20xx_radio_lora_bw_t bw_local;
  uint32_t bw_in_hz;
  
  bw_in_hz = 0;
  switch(bw)
  {
  case LR20XX_RADIO_LORA_BW_7:
    bw_in_hz = 0x1e84;
    break;
  case LR20XX_RADIO_LORA_BW_15:
    bw_in_hz = 0x3d09;
    break;
  case LR20XX_RADIO_LORA_BW_31:
    bw_in_hz = 0x7a12;
    break;
  case LR20XX_RADIO_LORA_BW_62:
    bw_in_hz = 0xf424;
    break;
  case LR20XX_RADIO_LORA_BW_125:
    bw_in_hz = 0x1e848;
    break;
  case LR20XX_RADIO_LORA_BW_250:
    bw_in_hz = 250000;
    break;
  case LR20XX_RADIO_LORA_BW_500:
    bw_in_hz = 500000;
    break;
  case LR20XX_RADIO_LORA_BW_1000:
    bw_in_hz = 1000000;
    break;
  case LR20XX_RADIO_LORA_BW_10:
    bw_in_hz = 0x28b1;
    break;
  case LR20XX_RADIO_LORA_BW_20:
    bw_in_hz = 0x5161;
    break;
  case LR20XX_RADIO_LORA_BW_41:
    bw_in_hz = 0xa2c3;
    break;
  case LR20XX_RADIO_LORA_BW_83:
    bw_in_hz = 0x1458c;
    break;
  case LR20XX_RADIO_LORA_BW_101:
    bw_in_hz = 0x18cbb;
    break;
  case LR20XX_RADIO_LORA_BW_203:
    bw_in_hz = 0x318f8;
    break;
  case LR20XX_RADIO_LORA_BW_406:
    bw_in_hz = 0x631f0;
    break;
  case LR20XX_RADIO_LORA_BW_812:
    bw_in_hz = 0xc63e0;
  }
  return bw_in_hz;
}



uint32_t lr20xx_radio_lora_get_time_on_air_in_ms
                   (lr20xx_radio_lora_pkt_params_t *pkt_p,lr20xx_radio_lora_mod_params_t *mod_p)
{
  uint32_t uVar1;
  uint32_t uVar2;
  lr20xx_radio_lora_mod_params_t *mod_p_local;
  lr20xx_radio_lora_pkt_params_t *pkt_p_local;
  uint32_t denominator;
  uint32_t numerator;
  
  uVar1 = lr20xx_radio_lora_get_time_on_air_numerator(pkt_p,mod_p);
  uVar2 = lr20xx_radio_lora_get_bw_in_hz(mod_p->bw);
  return ((uVar2 + uVar1 * 1000) - 1) / uVar2;
}



lr20xx_status_t
abstract_search_symbols(void *context,uint8_t n_symbols,search_symbol_format_t format)
{
  lr20xx_hal_status_t lVar1;
  search_symbol_format_t format_local;
  uint8_t n_symbols_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '\"';
  cbuffer[2] = n_symbols;
  cbuffer[3] = format;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_lr_fhss_build_frame
          (void *context,lr20xx_radio_lr_fhss_params_t *lr_fhss_params,uint16_t hop_sequence_id,
          uint8_t *payload,uint8_t payload_length)
{
  lr20xx_hal_status_t lVar1;
  char cVar2;
  uint8_t *payload_local;
  uint16_t hop_sequence_id_local;
  lr20xx_radio_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  uint8_t cbuffer [8];
  lr20xx_status_t status;
  
  lVar1 = lr20xx_radio_lr_fhss_set_sync_word(context,(lr_fhss_params->lr_fhss_params).sync_word);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    cbuffer[0] = '\x02';
    cbuffer[1] = 'V';
    cbuffer[2] = (lr_fhss_params->lr_fhss_params).cr +
                 (lr_fhss_params->lr_fhss_params).header_count * '\x10';
    cbuffer[3] = (lr_fhss_params->lr_fhss_params).grid +
                 (lr_fhss_params->lr_fhss_params).modulation_type * '\x10';
    if ((lr_fhss_params->lr_fhss_params).enable_hopping == false)
    {
      cVar2 = '\0';
    }
    else
    {
      cVar2 = '\x10';
    }
    cbuffer[4] = (lr_fhss_params->lr_fhss_params).bw + cVar2;
    cbuffer[5] = (uint8_t)(hop_sequence_id >> 8);
    cbuffer[6] = (uint8_t)hop_sequence_id;
    cbuffer[7] = lr_fhss_params->device_offset;
    lVar1 = lr20xx_hal_write(context,cbuffer,8,payload,(ushort)payload_length);
  }
  return lVar1;
}



lr20xx_status_t lr20xx_radio_lr_fhss_set_sync_word(void *context,uint8_t *sync_word)
{
  lr20xx_hal_status_t lVar1;
  uint8_t *sync_word_local;
  void *context_local;
  uint8_t cbuffer [2];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'W';
  lVar1 = lr20xx_hal_write(context,cbuffer,2,sync_word,4);
  return lVar1;
}



lr20xx_status_t lr20xx_radio_lr_fhss_init(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_set_pkt_type(context,LR20XX_RADIO_COMMON_PKT_TYPE_LRFHSS);
  return lVar1;
}



uint32_t lr20xx_radio_lr_fhss_get_time_on_air_in_ms
                   (lr20xx_radio_lr_fhss_params_t *params,uint16_t payload_length)
{
  uint16_t uVar1;
  uint16_t payload_length_local;
  lr20xx_radio_lr_fhss_params_t *params_local;
  
  uVar1 = lr20xx_radio_lr_fhss_get_nb_bits(&params->lr_fhss_params,payload_length);
  return ((uint)uVar1 * 0x100 + 0x7c) / 0x7d;
}



uint lr20xx_radio_lr_fhss_get_hop_sequence_count(lr20xx_radio_lr_fhss_params_t *lr_fhss_params)
{
  uint uVar1;
  lr20xx_radio_lr_fhss_params_t *lr_fhss_params_local;
  
  if (((lr_fhss_params->lr_fhss_params).grid == LR_FHSS_V1_GRID_25391_HZ) ||
     (((lr_fhss_params->lr_fhss_params).grid == LR_FHSS_V1_GRID_3906_HZ &&
      ((lr_fhss_params->lr_fhss_params).bw < LR_FHSS_V1_BW_335938_HZ))))
  {
    uVar1 = 0x180;
  }
  else
  {
    uVar1 = 0x200;
  }
  return uVar1;
}



uint16_t lr20xx_radio_lr_fhss_get_nb_bits(lr_fhss_v1_params_t *params,uint16_t payload_length)
{
  uint16_t payload_length_local;
  lr_fhss_v1_params_t *params_local;
  uint16_t last_block_bits;
  uint16_t payload_bits;
  uint16_t length_bits;
  
  length_bits = (payload_length + 2) * 8 + 6;
  switch(params->cr)
  {
  case LR_FHSS_V1_CR_5_6:
    length_bits = (uint16_t)(((uint)length_bits * 6 + 4) / 5);
    break;
  case LR_FHSS_V1_CR_2_3:
    length_bits = (uint16_t)((uint)length_bits * 3 >> 1);
    break;
  case LR_FHSS_V1_CR_1_2:
    length_bits *= 2;
    break;
  case LR_FHSS_V1_CR_1_3:
    length_bits *= 3;
  }
  payload_bits = (length_bits / 0x30) * 0x32;
  if (length_bits % 0x30 != 0)
  {
    payload_bits = payload_bits + length_bits % 0x30 + 2;
  }
  return payload_bits + (ushort)params->header_count * 0x72;
}



lr20xx_status_t lr20xx_rttof_set_responder_address(void *context,uint32_t address,uint8_t length)
{
  lr20xx_hal_status_t lVar1;
  uint8_t length_local;
  uint32_t address_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'x';
  cbuffer[2] = (uint8_t)(address >> 0x18);
  cbuffer[3] = (uint8_t)(address >> 0x10);
  cbuffer[4] = (uint8_t)(address >> 8);
  cbuffer[5] = (uint8_t)address;
  cbuffer[6] = length;
  lVar1 = lr20xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_rttof_set_initiator_address(void *context,uint32_t address)
{
  lr20xx_hal_status_t lVar1;
  uint32_t address_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'y';
  cbuffer[2] = (uint8_t)(address >> 0x18);
  cbuffer[3] = (uint8_t)(address >> 0x10);
  cbuffer[4] = (uint8_t)(address >> 8);
  cbuffer[5] = (uint8_t)address;
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_rttof_get_results(void *context,lr20xx_rttof_results_t *result)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_rttof_results_t *result_local;
  void *context_local;
  uint8_t data [4];
  uint8_t cbuffer [3];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'z';
  cbuffer[2] = '\0';
  data[0] = '\0';
  data[1] = '\0';
  data[2] = '\0';
  data[3] = '\0';
  lVar1 = lr20xx_hal_read(context,cbuffer,3,data,4);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    result->val = ((uint)data >> 8 & 0xff) * 0x100 + ((uint)data & 0xff) * 0x10000 +
                  ((uint)data >> 0x10 & 0xff);
    lr20xx_rttof_fix_and_convert_rssi(context,data[3],'\0',&result->rssi,(int8_t *)0x0);
  }
  return lVar1;
}



lr20xx_status_t lr20xx_rttof_set_tx_rx_delay(void *context,uint32_t delay_in_rtc_step)
{
  lr20xx_hal_status_t lVar1;
  uint32_t delay_in_rtc_step_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '{';
  cbuffer[2] = (uint8_t)(delay_in_rtc_step >> 0x18);
  cbuffer[3] = (uint8_t)(delay_in_rtc_step >> 0x10);
  cbuffer[4] = (uint8_t)(delay_in_rtc_step >> 8);
  cbuffer[5] = (uint8_t)delay_in_rtc_step;
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t lr20xx_rttof_set_params(void *context,lr20xx_rttof_params_t *params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_rttof_params_t *params_local;
  void *context_local;
  uint8_t cbuffer [3];
  lr20xx_status_t status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = '|';
  cbuffer[2] = params->nb_symbol | params->spy_mode << 6 | params->mode << 7;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_rttof_apply_rttof_stuck_workaround(context,params->mode);
  }
  return lVar1;
}



int32_t lr20xx_rttof_distance_raw_to_meter(lr20xx_radio_lora_bw_t rttof_bw,int32_t raw_distance)
{
  uint32_t uVar1;
  int32_t raw_distance_local;
  lr20xx_radio_lora_bw_t rttof_bw_local;
  int32_t denominator;
  int32_t numerator;
  uint8_t bitcnt;
  int32_t retval;
  
  retval = raw_distance;
  if (0x7fffff < raw_distance)
  {
    retval = raw_distance + -0x1000000;
  }
  uVar1 = lr20xx_radio_lora_get_bw_in_hz(rttof_bw);
  return (retval * 0x96) / (int)((uVar1 << 0xc) / 1000000);
}



lr20xx_status_t
lr20xx_rttof_fix_and_convert_rssi
          (void *context,uint8_t rssi1_raw,uint8_t rssi2_raw,int8_t *rssi1_val,int8_t *rssi2_val)
{
  uint8_t *rssi2_raw_fixed_00;
  int8_t *rssi1_val_local;
  uint8_t rssi2_raw_local;
  uint8_t rssi1_raw_local;
  void *context_local;
  uint8_t rssi2_raw_fixed;
  uint8_t rssi1_raw_fixed;
  lr20xx_status_t workaround_status;
  
  rssi1_raw_fixed = '\0';
  rssi2_raw_fixed = '\0';
  if (rssi2_val == (int8_t *)0x0)
  {
    rssi2_raw_fixed_00 = (uint8_t *)0x0;
  }
  else
  {
    rssi2_raw_fixed_00 = &rssi2_raw_fixed;
  }
  workaround_status =
       lr20xx_workarounds_rttof_rssi_computation
                 (context,rssi1_raw,rssi2_raw,&rssi1_raw_fixed,rssi2_raw_fixed_00);
  if (workaround_status == LR20XX_STATUS_OK)
  {
    lr20xx_rttof_convert_rssi(rssi1_raw_fixed,rssi2_raw_fixed,rssi1_val,rssi2_val);
  }
  return workaround_status;
}



void lr20xx_rttof_convert_rssi
               (uint8_t rssi1_raw,uint8_t rssi2_raw,int8_t *rssi1_val,int8_t *rssi2_val)
{
  int8_t *rssi2_val_local;
  int8_t *rssi1_val_local;
  uint8_t rssi2_raw_local;
  uint8_t rssi1_raw_local;
  
  *rssi1_val = -(rssi1_raw >> 1);
  if (rssi2_val != (int8_t *)0x0)
  {
    *rssi2_val = -(rssi2_raw >> 1);
  }
  return;
}



lr20xx_status_t
lr20xx_rttof_apply_rttof_stuck_workaround(void *context,lr20xx_rttof_mode_t rttof_mode)
{
  lr20xx_status_t lVar1;
  lr20xx_rttof_mode_t rttof_mode_local;
  void *context_local;
  
  if (rttof_mode == LR20XX_RTTOF_MODE_NORMAL)
  {
    lVar1 = lr20xx_workarounds_rttof_extended_stuck_second_request_disable(context);
  }
  else if (rttof_mode == LR20XX_RTTOF_MODE_EXTENDED)
  {
    lVar1 = lr20xx_workarounds_rttof_extended_stuck_second_request_enable(context);
  }
  else
  {
    lVar1 = LR20XX_STATUS_ERROR;
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_regmem_write_regmem32(void *context,uint32_t address,uint32_t *buffer,uint8_t length)
{
  lr20xx_hal_status_t lVar1;
  uint8_t length_local;
  uint32_t *buffer_local;
  uint32_t address_local;
  void *context_local;
  uint8_t cdata [256];
  uint8_t cbuffer [5];
  
  if (length < 0x21)
  {
    lr20xx_regmem_fill_cbuffer_cdata_opcode_address_data(cbuffer,cdata,0x104,address,buffer,length);
    lVar1 = lr20xx_hal_write(context,cbuffer,5,cdata,(ushort)length << 2);
  }
  else
  {
    lVar1 = LR20XX_HAL_STATUS_ERROR;
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_regmem_write_regmem32_mask(void *context,uint32_t address,uint32_t mask,uint32_t data)
{
  lr20xx_hal_status_t lVar1;
  uint32_t data_local;
  uint32_t mask_local;
  uint32_t address_local;
  void *context_local;
  uint8_t cbuffer [13];
  
  lr20xx_regmem_fill_cbuffer_opcode_address(cbuffer,0x105,address);
  cbuffer[5] = (uint8_t)(mask >> 0x18);
  cbuffer[6] = (uint8_t)(mask >> 0x10);
  cbuffer[7] = (uint8_t)(mask >> 8);
  cbuffer[8] = (uint8_t)mask;
  cbuffer[9] = (uint8_t)(data >> 0x18);
  cbuffer[10] = (uint8_t)(data >> 0x10);
  cbuffer[0xb] = (uint8_t)(data >> 8);
  cbuffer[0xc] = (uint8_t)data;
  lVar1 = lr20xx_hal_write(context,cbuffer,0xd,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_regmem_read_regmem32(void *context,uint32_t address,uint32_t *buffer,uint8_t length)
{
  lr20xx_hal_status_t lVar1;
  uint8_t length_local;
  uint32_t *buffer_local;
  uint32_t address_local;
  void *context_local;
  uint8_t cbuffer [6];
  lr20xx_status_t status;
  
  if (length < 0x21)
  {
    lr20xx_regmem_fill_cbuffer_opcode_address_length(cbuffer,0x106,address,length);
    lVar1 = lr20xx_hal_read(context,cbuffer,6,(uint8_t *)buffer,(ushort)length << 2);
    if (lVar1 == LR20XX_HAL_STATUS_OK)
    {
      lr20xx_regmem_fill_out_buffer_from_raw_buffer(buffer,(uint8_t *)buffer,length);
    }
  }
  else
  {
    lVar1 = LR20XX_HAL_STATUS_ERROR;
  }
  return lVar1;
}



void lr20xx_regmem_fill_cbuffer_opcode_address(uint8_t *cbuffer,uint16_t opcode,uint32_t address)
{
  uint32_t address_local;
  uint16_t opcode_local;
  uint8_t *cbuffer_local;
  
  *cbuffer = (uint8_t)(opcode >> 8);
  cbuffer[1] = (uint8_t)opcode;
  cbuffer[2] = (uint8_t)(address >> 0x10);
  cbuffer[3] = (uint8_t)(address >> 8);
  cbuffer[4] = (uint8_t)address;
  return;
}



void lr20xx_regmem_fill_cbuffer_opcode_address_length
               (uint8_t *cbuffer,uint16_t opcode,uint32_t address,uint8_t length)
{
  uint32_t address_local;
  uint8_t length_local;
  uint16_t opcode_local;
  uint8_t *cbuffer_local;
  
  lr20xx_regmem_fill_cbuffer_opcode_address(cbuffer,opcode,address);
  cbuffer[5] = length;
  return;
}



void lr20xx_regmem_fill_cdata(uint8_t *cdata,uint32_t *data,uint8_t data_length)
{
  uint8_t *puVar1;
  uint8_t data_length_local;
  uint32_t *data_local;
  uint8_t *cdata_local_1;
  uint8_t *cdata_local;
  uint16_t index;
  
  for (index = 0; index < data_length; index += 1)
  {
    puVar1 = cdata + (uint)index * 4;
    *puVar1 = (uint8_t)(data[index] >> 0x18);
    puVar1[1] = (uint8_t)(data[index] >> 0x10);
    puVar1[2] = (uint8_t)(data[index] >> 8);
    puVar1[3] = (uint8_t)data[index];
  }
  return;
}



void lr20xx_regmem_fill_cbuffer_cdata_opcode_address_data
               (uint8_t *cbuffer,uint8_t *cdata,uint16_t opcode,uint32_t address,uint32_t *data,
               uint8_t data_length)
{
  uint32_t address_local;
  uint16_t opcode_local;
  uint8_t *cdata_local;
  uint8_t *cbuffer_local;
  
  lr20xx_regmem_fill_cbuffer_opcode_address(cbuffer,opcode,address);
  lr20xx_regmem_fill_cdata(cdata,data,data_length);
  return;
}



void lr20xx_regmem_fill_out_buffer_from_raw_buffer
               (uint32_t *out_buffer,uint8_t *raw_buffer,uint8_t out_buffer_length)
{
  byte *pbVar1;
  uint8_t out_buffer_length_local;
  uint8_t *raw_buffer_local_1;
  uint32_t *out_buffer_local;
  uint8_t *raw_buffer_local;
  uint8_t out_index;
  
  for (out_index = '\0'; out_index < out_buffer_length; out_index += '\x01')
  {
    pbVar1 = raw_buffer + (uint)out_index * 4;
    out_buffer[out_index] =
         (uint)*pbVar1 * 0x1000000 + (uint)pbVar1[1] * 0x10000 + (uint)pbVar1[2] * 0x100 +
         (uint)pbVar1[3];
  }
  return;
}



lr20xx_status_t
lr20xx_workarounds_ook_set_detection_threshold_level(void *context,int16_t threshold_level_db)
{
  lr20xx_status_t lVar1;
  int16_t threshold_level_db_local;
  void *context_local;
  int threshold_db;
  
  lVar1 = lr20xx_regmem_write_regmem32_mask
                    (context,0xf30e14,0x7f00000,((int)threshold_level_db + 0x4aU & 0x7f) << 0x14);
  return lVar1;
}



lr20xx_status_t
lr20xx_workarounds_rttof_rssi_computation
          (void *context,uint8_t rssi1_raw_value,uint8_t rssi2_raw_value,uint8_t *rssi1_raw_fixed,
          uint8_t *rssi2_raw_fixed)
{
  uint8_t uVar1;
  uint8_t *rssi1_raw_fixed_local;
  uint8_t rssi2_raw_value_local;
  uint8_t rssi1_raw_value_local;
  void *context_local;
  int16_t power_offset;
  uint16_t max_gain;
  lr20xx_status_t return_code;
  
  max_gain = 0;
  power_offset = 0;
  return_code = lr20xx_workarounds_rttof_rssi_computation_get_gain_power
                          (context,&max_gain,&power_offset);
  if (return_code == LR20XX_STATUS_OK)
  {
    uVar1 = lr20xx_workarounds_rttof_rssi_computation_apply_correction
                      (max_gain,power_offset,rssi1_raw_value);
    *rssi1_raw_fixed = uVar1;
    if (rssi2_raw_fixed != (uint8_t *)0x0)
    {
      uVar1 = lr20xx_workarounds_rttof_rssi_computation_apply_correction
                        (max_gain,power_offset,rssi2_raw_value);
      *rssi2_raw_fixed = uVar1;
    }
    return_code = LR20XX_STATUS_OK;
  }
  return return_code;
}



lr20xx_status_t lr20xx_workarounds_dcdc_reset(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  lr20xx_status_t return_code_1;
  lr20xx_status_t return_code;
  
  lVar1 = lr20xx_regmem_write_regmem32_mask(context,0xf20024,0xf00000,0xf00000);
  if ((lVar1 == LR20XX_STATUS_OK) &&
     (lVar1 = lr20xx_regmem_write_regmem32_mask(context,0xf20024,0xf0000,0xf0000),
     lVar1 == LR20XX_STATUS_OK))
  {
    lVar1 = lr20xx_workaround_dcdc_set_frequency(context,2800000);
  }
  return lVar1;
}



lr20xx_status_t lr20xx_workarounds_dcdc_configure(void *context)
{
  lr20xx_status_t lVar1;
  lr20xx_status_t lVar2;
  void *context_local;
  uint32_t rx_path_raw;
  uint32_t adc_ctrl_raw;
  lr20xx_status_t return_code_5;
  lr20xx_status_t return_code_4;
  lr20xx_status_t return_code_3;
  lr20xx_status_t return_code_2;
  _Bool is_rx_hf;
  lr20xx_status_t return_code_1;
  uint32_t ana_dec;
  lr20xx_status_t return_code;
  
  adc_ctrl_raw = 0;
  return_code_1 = lr20xx_regmem_read_regmem32(context,0xf40200,&adc_ctrl_raw,'\x01');
  if (return_code_1 == LR20XX_STATUS_OK)
  {
    ana_dec = adc_ctrl_raw >> 8 & 7;
    rx_path_raw = 0;
    return_code = return_code_1;
    return_code_1 = lr20xx_regmem_read_regmem32(context,0xf40430,&rx_path_raw,'\x01');
    if (return_code_1 == LR20XX_STATUS_OK)
    {
      is_rx_hf = (rx_path_raw & 3) == 1;
      if ((is_rx_hf) || ((ana_dec != 1 && (ana_dec != 2))))
      {
        return_code_4 = lr20xx_regmem_write_regmem32_mask(context,0xf20024,0xf00000,0xf00000);
        if (return_code_4 != LR20XX_STATUS_OK)
        {
          return return_code_4;
        }
        return_code_5 = lr20xx_regmem_write_regmem32_mask(context,0xf20024,0xf0000,0xf0000);
        lVar2 = return_code_5;
        lVar1 = return_code_1;
      }
      else
      {
        return_code_2 = lr20xx_regmem_write_regmem32_mask(context,0xf20024,0xf00000,0xb00000);
        if (return_code_2 != LR20XX_STATUS_OK)
        {
          return return_code_2;
        }
        return_code_3 = lr20xx_regmem_write_regmem32_mask(context,0xf20024,0xf0000,0xd0000);
        lVar2 = return_code_3;
        lVar1 = return_code_1;
      }
      return_code_1 = lVar2;
      if (return_code_1 == LR20XX_STATUS_OK)
      {
        return_code_1 = lVar1;
        if (ana_dec == 1)
        {
          return_code_1 = lr20xx_workaround_dcdc_set_frequency(context,4300000);
        }
        else
        {
          return_code_1 = lr20xx_workaround_dcdc_set_frequency(context,2800000);
        }
      }
    }
  }
  return return_code_1;
}



lr20xx_status_t lr20xx_workarounds_rttof_extended_stuck_second_request_enable(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_regmem_write_regmem32_mask(context,0xf30b50,0x7000000,0);
  return lVar1;
}



lr20xx_status_t lr20xx_workarounds_rttof_extended_stuck_second_request_disable(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_regmem_write_regmem32_mask(context,0xf30b50,0x7000000,0x1000000);
  return lVar1;
}



lr20xx_status_t
lr20xx_workarounds_rttof_rssi_computation_get_gain_power
          (void *context,uint16_t *max_gain,int16_t *power_offset)
{
  ushort uVar1;
  int16_t *power_offset_local;
  uint16_t *max_gain_local;
  void *context_local;
  uint32_t power_offset_raw;
  uint32_t max_gain_raw;
  int16_t power_offset_raw_value;
  lr20xx_status_t return_code_1;
  lr20xx_status_t return_code;
  
  max_gain_raw = 0;
  return_code = lr20xx_regmem_read_regmem32(context,0xf301a4,&max_gain_raw,'\x01');
  if (return_code == LR20XX_STATUS_OK)
  {
    *max_gain = (ushort)((max_gain_raw << 0x16) >> 0x16);
    power_offset_raw = 0;
    return_code = lr20xx_regmem_read_regmem32(context,0xf30128,&power_offset_raw,'\x01');
    if (return_code == LR20XX_STATUS_OK)
    {
      uVar1 = (ushort)(power_offset_raw >> 6) & 0x3f;
      if (0x20 < uVar1)
      {
        uVar1 -= 0x40;
      }
      *power_offset = uVar1;
      return_code = LR20XX_STATUS_OK;
    }
  }
  return return_code;
}



uint8_t lr20xx_workarounds_rttof_rssi_computation_apply_correction
                  (uint16_t max_gain,int16_t power_offset,uint8_t raw_rssi)
{
  uint8_t raw_rssi_local;
  int16_t power_offset_local;
  uint16_t max_gain_local;
  
  return (char)power_offset + (char)(max_gain >> 1) + raw_rssi * -2 + 0xd0;
}



lr20xx_status_t lr20xx_workaround_dcdc_set_frequency(void *context,uint32_t frequency)
{
  uint in_fpscr;
  float fVar1;
  uint32_t frequency_local;
  void *context_local;
  uint32_t rf_frequency;
  uint32_t freq_lf;
  lr20xx_status_t return_code_1;
  lr20xx_status_t return_code;
  
  fVar1 = (float)VectorUnsignedToFloat(frequency,(byte)(in_fpscr >> 0x15) & 3);
  freq_lf = VectorFloatToUnsigned(fVar1 * 1.048576,3);
  return_code_1 = lr20xx_regmem_write_regmem32(context,0x80004c,&freq_lf,'\x01');
  if (return_code_1 == LR20XX_STATUS_OK)
  {
    rf_frequency = 0;
    return_code = return_code_1;
    return_code_1 = lr20xx_workaround_dcdc_get_rf_frequency(context,&rf_frequency);
    if (return_code_1 == LR20XX_STATUS_OK)
    {
      return_code_1 = lr20xx_radio_common_set_rf_freq(context,rf_frequency);
    }
  }
  return return_code_1;
}



lr20xx_status_t lr20xx_workaround_dcdc_get_rf_frequency(void *context,uint32_t *frequency)
{
  uint32_t uVar1;
  uint32_t *frequency_local;
  void *context_local;
  uint32_t raw_rf_freq;
  lr20xx_status_t return_code;
  
  raw_rf_freq = 0;
  return_code = lr20xx_regmem_read_regmem32(context,0xf40144,&raw_rf_freq,'\x01');
  if (return_code == LR20XX_STATUS_OK)
  {
    uVar1 = pll_step_to_hz(raw_rf_freq);
    *frequency = uVar1;
    return_code = LR20XX_STATUS_OK;
  }
  return return_code;
}



uint32_t pll_step_to_hz(uint32_t pll_steps)
{
  uint uVar1;
  uint32_t uVar2;
  int iVar3;
  uint32_t pll_steps_local;
  uint_least64_t denominator;
  uint_least64_t numerator;
  
  iVar3 = (pll_steps >> 0x1b) - (uint)(pll_steps * 0x20 < pll_steps);
  uVar1 = pll_steps * 0x3d09;
  uVar2 = __aeabi_uldivmod(uVar1 + 0x3fff,
                           ((((iVar3 * 0x40 | pll_steps * 0x1f >> 0x1a) - iVar3) -
                            (uint)(pll_steps * 0x7c0 < pll_steps * 0x1f)) * 8 |
                           pll_steps * 0x7a1 >> 0x1d) + (uint)CARRY4(pll_steps * 0x3d08,pll_steps) +
                           (uint)(0xffffbfff < uVar1) + -1 + (uint)(uVar1 != 0xffffc000),0x4000,0);
  return uVar2;
}



lr20xx_status_t
lr20xx_radio_flrc_set_modulation_params(void *context,lr20xx_radio_flrc_mod_params_t *params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_flrc_mod_params_t *params_local;
  void *context_local;
  uint8_t cbuffer [4];
  lr20xx_status_t write_status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'H';
  cbuffer[2] = params->br_bw;
  cbuffer[3] = params->shape + params->cr * '\x10';
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_workarounds_dcdc_configure(context);
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_flrc_set_pkt_params(void *context,lr20xx_radio_flrc_pkt_params_t *params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_flrc_pkt_params_t *params_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'I';
  cbuffer[2] = params->preamble_len * '\x04' + params->sync_word_len;
  cbuffer[3] = params->tx_syncword * '@' +
               params->match_sync_word * '\b' + params->header_type * '\x04' + params->crc_type;
  cbuffer[4] = (uint8_t)(params->pld_len_in_bytes >> 8);
  cbuffer[5] = (uint8_t)params->pld_len_in_bytes;
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_flrc_set_syncword(void *context,uint8_t syncword_index,uint8_t *syncword)
{
  lr20xx_status_t lVar1;
  uint8_t *syncword_local;
  uint8_t syncword_index_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_flrc_set_syncword_base(context,syncword_index,syncword,'\x04');
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_flrc_set_syncword_base
          (void *context,uint8_t syncword_index,uint8_t *syncword,uint8_t syncword_length)
{
  lr20xx_hal_status_t lVar1;
  uint8_t *syncword_local;
  uint8_t syncword_length_local;
  uint8_t syncword_index_local;
  void *context_local;
  uint8_t cbuffer [3];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 'L';
  cbuffer[2] = syncword_index;
  lVar1 = lr20xx_hal_write(context,cbuffer,3,syncword,(ushort)syncword_length);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_modulation_params(void *context,lr20xx_radio_ook_mod_params_t *params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_ook_mod_params_t *params_local;
  void *context_local;
  uint8_t cbuffer [9];
  lr20xx_status_t write_status;
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x81;
  cbuffer[2] = (uint8_t)(params->br >> 0x18);
  cbuffer[3] = (uint8_t)(params->br >> 0x10);
  cbuffer[4] = (uint8_t)(params->br >> 8);
  cbuffer[5] = (uint8_t)params->br;
  cbuffer[6] = pulse_shape_to_byte(&params->pulse_shape);
  cbuffer[7] = params->bw;
  cbuffer[8] = params->mag_depth;
  lVar1 = lr20xx_hal_write(context,cbuffer,9,(uint8_t *)0x0,0);
  if (lVar1 == LR20XX_HAL_STATUS_OK)
  {
    lVar1 = lr20xx_workarounds_dcdc_configure(context);
  }
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_packet_params(void *context,lr20xx_radio_ook_pkt_params_t *params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_ook_pkt_params_t *params_local;
  void *context_local;
  uint8_t cbuffer [8];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x82;
  cbuffer[2] = (uint8_t)(params->pbl_length_in_bit >> 8);
  cbuffer[3] = (uint8_t)params->pbl_length_in_bit;
  cbuffer[4] = params->header_mode + params->address_filtering * '\x04';
  cbuffer[5] = (uint8_t)(params->payload_length >> 8);
  cbuffer[6] = (uint8_t)params->payload_length;
  cbuffer[7] = params->encoding + params->crc * '\x10';
  lVar1 = lr20xx_hal_write(context,cbuffer,8,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_crc_params(void *context,uint32_t crc_polynomial,uint32_t crc_seed)
{
  lr20xx_hal_status_t lVar1;
  uint32_t crc_seed_local;
  uint32_t crc_polynomial_local;
  void *context_local;
  uint8_t cbuffer [10];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x83;
  cbuffer[2] = (uint8_t)(crc_polynomial >> 0x18);
  cbuffer[3] = (uint8_t)(crc_polynomial >> 0x10);
  cbuffer[4] = (uint8_t)(crc_polynomial >> 8);
  cbuffer[5] = (uint8_t)crc_polynomial;
  cbuffer[6] = (uint8_t)(crc_seed >> 0x18);
  cbuffer[7] = (uint8_t)(crc_seed >> 0x10);
  cbuffer[8] = (uint8_t)(crc_seed >> 8);
  cbuffer[9] = (uint8_t)crc_seed;
  lVar1 = lr20xx_hal_write(context,cbuffer,10,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_syncword
          (void *context,uint8_t *syncword,uint8_t nb_bits,
          lr20xx_radio_ook_syncword_bit_order_t bit_order)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_ook_syncword_bit_order_t bit_order_local;
  uint8_t nb_bits_local;
  uint8_t *syncword_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x84;
  cbuffer[2] = *syncword;
  cbuffer[3] = syncword[1];
  cbuffer[4] = syncword[2];
  cbuffer[5] = syncword[3];
  cbuffer[6] = nb_bits + bit_order * -0x80;
  lVar1 = lr20xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_addresses(void *context,uint8_t node_address,uint8_t broadcast_address)
{
  lr20xx_hal_status_t lVar1;
  uint8_t broadcast_address_local;
  uint8_t node_address_local;
  void *context_local;
  uint8_t cbuffer [4];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x85;
  cbuffer[2] = node_address;
  cbuffer[3] = broadcast_address;
  lVar1 = lr20xx_hal_write(context,cbuffer,4,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_rx_detector(void *context,lr20xx_radio_ook_rx_detector_t *rx_detector)
{
  lr20xx_hal_status_t lVar1;
  byte bVar2;
  lr20xx_radio_ook_rx_detector_t *rx_detector_local;
  void *context_local;
  uint8_t cbuffer [7];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x88;
  cbuffer[2] = (uint8_t)(rx_detector->pattern >> 8);
  cbuffer[3] = (uint8_t)rx_detector->pattern;
  cbuffer[4] = rx_detector->pattern_length_in_bit;
  cbuffer[5] = rx_detector->pattern_repeat_nb;
  if (rx_detector->is_syncword_encoded == false)
  {
    bVar2 = 0x20;
  }
  else
  {
    bVar2 = 0;
  }
  cbuffer[6] = rx_detector->sfd_length_in_bit | rx_detector->sfd_type << 4 | bVar2;
  lVar1 = lr20xx_hal_write(context,cbuffer,7,(uint8_t *)0x0,0);
  return lVar1;
}



lr20xx_status_t
lr20xx_radio_ook_set_whitening_params(void *context,lr20xx_radio_ook_whitening_params_t *params)
{
  lr20xx_hal_status_t lVar1;
  lr20xx_radio_ook_whitening_params_t *params_local;
  void *context_local;
  uint8_t cbuffer [6];
  
  cbuffer[0] = '\x02';
  cbuffer[1] = 0x89;
  cbuffer[2] = (byte)(params->polynomial >> 8) | params->bit_index << 4;
  cbuffer[3] = (uint8_t)params->polynomial;
  cbuffer[4] = (uint8_t)(params->seed >> 8);
  cbuffer[5] = (uint8_t)params->seed;
  lVar1 = lr20xx_hal_write(context,cbuffer,6,(uint8_t *)0x0,0);
  return lVar1;
}



uint8_t pulse_shape_to_byte(lr20xx_radio_ook_pulse_shape_t *pulse_shape)
{
  lr20xx_radio_ook_pulse_shape_t *pulse_shape_local;
  
  return pulse_shape->filter * '\b' + pulse_shape->bt;
}



_Bool ral_lr20xx_handles_part(char *part_number)
{
  int iVar1;
  undefined1 uVar2;
  bool bVar3;
  char *part_number_local;
  
  iVar1 = strcmp("lr20xx",part_number);
  bVar3 = iVar1 == 0;
  if (bVar3)
  {
    iVar1 = 1;
  }
  uVar2 = (undefined1)iVar1;
  if (!bVar3)
  {
    uVar2 = 0;
  }
  return (_Bool)uVar2;
}



ral_status_t ral_lr20xx_reset(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_system_reset(context);
  return lVar1;
}



ral_status_t ral_lr20xx_wakeup(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_system_wakeup(context);
  return lVar1;
}



ral_status_t ral_lr20xx_init(void *context)
{
  _Bool _Var1;
  lr20xx_status_t lVar2;
  void *context_local;
  lr20xx_system_hf_clk_scaling_t hf_clk_scaling;
  lr20xx_system_dio_rf_switch_cfg_t rf_switch_cfg;
  lr20xx_system_dio_drive_t dio_drive;
  lr20xx_system_dio_func_t dio_function;
  lr20xx_system_dio_t dio;
  lr20xx_radio_common_front_end_calibration_value_t front_end_calibration_structures [3];
  uint16_t errors;
  lr20xx_system_lfclk_cfg_t lfclk_cfg;
  uint32_t startup_time_in_tick;
  lr20xx_system_tcxo_supply_voltage_t tcxo_supply_voltage;
  ral_xosc_cfg_t xosc_cfg;
  lr20xx_system_reg_mode_t reg_mode;
  uint32_t freq_val;
  uint8_t dio_count;
  ral_status_t status;
  uint8_t dio_nth;
  
  status = RAL_STATUS_ERROR;
  freq_val = 0x2ccccc;
  lr20xx_regmem_write_regmem32(context,0x80004c,&freq_val,'\x01');
  ral_lr20xx_bsp_get_reg_mode(context,&reg_mode);
  status = lr20xx_system_set_reg_mode(context,reg_mode);
  if (status == LR20XX_STATUS_OK)
  {
    startup_time_in_tick = 0;
    ral_lr20xx_bsp_get_xosc_cfg(context,&xosc_cfg,&tcxo_supply_voltage,&startup_time_in_tick);
    if ((xosc_cfg != RAL_XOSC_CFG_TCXO_RADIO_CTRL) ||
       (status = lr20xx_system_set_tcxo_mode(context,tcxo_supply_voltage,startup_time_in_tick),
       status == LR20XX_STATUS_OK))
    {
      ral_bsp_lr20xx_get_lfclk_cfg(context,&lfclk_cfg);
      status = lr20xx_system_cfg_lfclk(context,lfclk_cfg);
      if (status == LR20XX_STATUS_OK)
      {
        lr20xx_system_get_errors(context,&errors);
        if (errors != 0)
        {
          lr20xx_system_clear_errors(context);
        }
        dio_count = lr20xx_system_dio_get_count();
        for (dio_nth = '\0'; dio_nth < dio_count; dio_nth += '\x01')
        {
          dio_function = LR20XX_SYSTEM_DIO_FUNC_NONE;
          dio_drive = LR20XX_SYSTEM_DIO_DRIVE_NONE;
          _Var1 = lr20xx_system_dio_get_nth(dio_nth,&dio);
          if (!_Var1)
          {
            return RAL_STATUS_ERROR;
          }
          ral_lr20xx_bsp_get_dio_function(context,dio,&dio_function);
          ral_lr20xx_bsp_get_dio_sleep_drive(context,dio,&dio_drive);
          status = lr20xx_system_set_dio_function(context,dio,dio_function,dio_drive);
          if (status != LR20XX_STATUS_OK)
          {
            return status;
          }
          lVar2 = RAL_STATUS_OK;
          if (dio_function == LR20XX_SYSTEM_DIO_FUNC_RF_SWITCH)
          {
            rf_switch_cfg = '\0';
            ral_lr20xx_bsp_get_dio_rf_switch_cfg(context,dio,&rf_switch_cfg);
            lVar2 = lr20xx_system_set_dio_rf_switch_cfg(context,dio,rf_switch_cfg);
            if (lVar2 != LR20XX_STATUS_OK)
            {
              return lVar2;
            }
          }
          status = lVar2;
          if (dio_function == LR20XX_SYSTEM_DIO_FUNC_HF_CLK_OUT)
          {
            hf_clk_scaling = LR20XX_SYSTEM_HF_CLK_SCALING_32_MHZ;
            ral_lr20xx_bsp_get_dio_hf_clk_scaling_cfg(context,&hf_clk_scaling);
            status = lr20xx_system_cfg_clk_output(context,hf_clk_scaling);
            if (status != LR20XX_STATUS_OK)
            {
              return status;
            }
          }
        }
        front_end_calibration_structures[0].rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
        front_end_calibration_structures[0]._1_3_ = 0;
        front_end_calibration_structures[0].frequency_in_hertz = 0;
        front_end_calibration_structures[1].rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
        front_end_calibration_structures[1]._1_3_ = 0;
        front_end_calibration_structures[1].frequency_in_hertz = 0;
        front_end_calibration_structures[2].rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
        front_end_calibration_structures[2]._1_3_ = 0;
        front_end_calibration_structures[2].frequency_in_hertz = 0;
        ral_lr20xx_bsp_get_front_end_calibration_cfg(context,front_end_calibration_structures);
        status = lr20xx_radio_common_calibrate_front_end_helper
                           (context,front_end_calibration_structures,'\x03');
      }
    }
  }
  return status;
}



ral_status_t ral_lr20xx_set_sleep(void *context,_Bool retain_config)
{
  lr20xx_status_t lVar1;
  _Bool retain_config_local;
  void *context_local;
  lr20xx_system_sleep_cfg_t radio_sleep_cfg;
  
  radio_sleep_cfg.is_clk_32k_enabled = false;
  radio_sleep_cfg.is_ram_retention_enabled = retain_config;
  lVar1 = lr20xx_system_set_sleep_mode(context,&radio_sleep_cfg,0);
  return lVar1;
}



ral_status_t ral_lr20xx_set_standby(void *context,ral_standby_cfg_t ral_standby_cfg)
{
  lr20xx_status_t lVar1;
  ral_standby_cfg_t ral_standby_cfg_local;
  void *context_local;
  lr20xx_system_standby_mode_t radio_standby_cfg;
  
  if (ral_standby_cfg == RAL_STANDBY_CFG_RC)
  {
    radio_standby_cfg = LR20XX_SYSTEM_STANDBY_MODE_RC;
  }
  else
  {
    if (ral_standby_cfg != RAL_STANDBY_CFG_XOSC)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    radio_standby_cfg = LR20XX_SYSTEM_STANDBY_MODE_XOSC;
  }
  lVar1 = lr20xx_system_set_standby_mode(context,radio_standby_cfg);
  return lVar1;
}



ral_status_t ral_lr20xx_set_fs(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_system_set_fs_mode(context);
  return lVar1;
}



ral_status_t ral_lr20xx_set_tx(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_set_tx(context,0);
  return lVar1;
}



ral_status_t ral_lr20xx_set_rx(void *context,uint32_t timeout_in_ms)
{
  lr20xx_status_t lVar1;
  uint32_t timeout_in_ms_local;
  void *context_local;
  
  lr20xx_radio_fifo_clear_rx(context);
  if (timeout_in_ms == 0xffffffff)
  {
    lVar1 = lr20xx_radio_common_set_rx_with_timeout_in_rtc_step(context,0xffffff);
  }
  else if (timeout_in_ms < 0x7d000)
  {
    lVar1 = lr20xx_radio_common_set_rx(context,timeout_in_ms);
  }
  else
  {
    lVar1 = LR20XX_STATUS_ERROR;
  }
  return lVar1;
}



ral_status_t ral_lr20xx_cfg_rx_boosted(void *context,_Bool enable_boost_mode)
{
  _Bool enable_boost_mode_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t
ral_lr20xx_set_rx_tx_fallback_mode(void *context,ral_fallback_modes_t ral_fallback_mode)
{
  lr20xx_status_t lVar1;
  ral_fallback_modes_t ral_fallback_mode_local;
  void *context_local;
  lr20xx_radio_common_fallback_modes_t radio_fallback_mode;
  
  if (ral_fallback_mode == RAL_FALLBACK_FS)
  {
    radio_fallback_mode = LR20XX_RADIO_FALLBACK_FS;
  }
  else
  {
    if (RAL_FALLBACK_FS < ral_fallback_mode)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    if (ral_fallback_mode == RAL_FALLBACK_STDBY_RC)
    {
      radio_fallback_mode = LR20XX_RADIO_FALLBACK_STDBY_RC;
    }
    else
    {
      if (ral_fallback_mode != RAL_FALLBACK_STDBY_XOSC)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      radio_fallback_mode = LR20XX_RADIO_FALLBACK_STDBY_XOSC;
    }
  }
  lVar1 = lr20xx_radio_common_set_rx_tx_fallback_mode(context,radio_fallback_mode);
  return lVar1;
}



ral_status_t ral_lr20xx_stop_timer_on_preamble(void *context,_Bool enable)
{
  lr20xx_status_t lVar1;
  _Bool enable_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_set_rx_timeout_stop_event(context,enable);
  return lVar1;
}



ral_status_t
ral_lr20xx_set_rx_duty_cycle(void *context,uint32_t rx_time_in_ms,uint32_t sleep_time_in_ms)
{
  lr20xx_status_t lVar1;
  uint32_t sleep_time_in_ms_local;
  uint32_t rx_time_in_ms_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_set_rx_duty_cycle
                    (context,rx_time_in_ms,sleep_time_in_ms,
                     LR20XX_RADIO_COMMON_RX_DUTY_CYCLE_MODE_RX);
  return lVar1;
}



ral_status_t ral_lr20xx_set_lora_cad(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_radio_lora_set_cad(context);
  return lVar1;
}



ral_status_t ral_lr20xx_set_tx_cw(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_set_tx_test_mode
                    (context,LR20XX_RADIO_COMMON_TX_TEST_MODE_CONTINUOUS_WAVE);
  return lVar1;
}



ral_status_t ral_lr20xx_set_tx_infinite_preamble(void *context)
{
  lr20xx_status_t lVar1;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_set_tx_test_mode
                    (context,LR20XX_RADIO_COMMON_TX_TEST_MODE_INFINITE_PREAMBLE);
  return lVar1;
}



ral_status_t ral_lr20xx_cal_img(void *context,uint16_t freq1_in_mhz,uint16_t freq2_in_mhz)
{
  lr20xx_status_t lVar1;
  ulonglong uVar2;
  uint16_t freq2_in_mhz_local;
  uint16_t freq1_in_mhz_local;
  void *context_local;
  lr20xx_radio_common_front_end_calibration_value_t image_calibration_structures [2];
  
  image_calibration_structures[0].rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
  uVar2 = __aeabi_i2d((uint)freq1_in_mhz);
  uVar2 = __muldf3((uint)uVar2,(uint)(uVar2 >> 0x20),0,0x412e8480);
  image_calibration_structures[0].frequency_in_hertz =
       __aeabi_d2uiz((uint)uVar2,(uint)(uVar2 >> 0x20));
  image_calibration_structures[1].rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
  uVar2 = __aeabi_i2d((uint)freq2_in_mhz);
  uVar2 = __muldf3((uint)uVar2,(uint)(uVar2 >> 0x20),0,0x412e8480);
  image_calibration_structures[1].frequency_in_hertz =
       __aeabi_d2uiz((uint)uVar2,(uint)(uVar2 >> 0x20));
  lVar1 = lr20xx_radio_common_calibrate_front_end_helper
                    (context,image_calibration_structures,'\x02');
  return lVar1;
}



ral_status_t ral_lr20xx_set_tx_cfg(void *context,int8_t output_pwr_in_dbm,uint32_t rf_freq_in_hz)
{
  lr20xx_status_t lVar1;
  uint32_t rf_freq_in_hz_local;
  int8_t output_pwr_in_dbm_local;
  void *context_local;
  ral_lr20xx_bsp_tx_cfg_input_params_t tx_cfg_input_params;
  ral_lr20xx_bsp_tx_cfg_output_params_t tx_cfg_output_params;
  ral_status_t status;
  
  tx_cfg_input_params.system_output_pwr_in_dbm = output_pwr_in_dbm;
  tx_cfg_input_params.freq_in_hz = rf_freq_in_hz;
  ral_lr20xx_bsp_get_tx_cfg(context,&tx_cfg_input_params,&tx_cfg_output_params);
  lVar1 = lr20xx_radio_common_set_pa_cfg(context,&tx_cfg_output_params.pa_cfg);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_radio_common_set_tx_params
                      (context,tx_cfg_output_params.chip_output_half_pwr_in_dbm_configured,
                       tx_cfg_output_params.pa_ramp_time);
  }
  return lVar1;
}



ral_status_t ral_lr20xx_set_pkt_payload(void *context,uint8_t *buffer,uint16_t size)
{
  lr20xx_status_t lVar1;
  uint16_t size_local;
  uint8_t *buffer_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_fifo_write_tx(context,buffer,size);
  return lVar1;
}



ral_status_t
ral_lr20xx_get_pkt_payload
          (void *context,uint16_t max_size_in_bytes,uint8_t *buffer,uint16_t *size_in_bytes)
{
  uint16_t *size_in_bytes_local;
  uint8_t *buffer_local;
  uint16_t max_size_in_bytes_local;
  void *context_local;
  uint16_t pkt_len;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  status = lr20xx_radio_common_get_rx_packet_length(context,&pkt_len);
  if (status == LR20XX_STATUS_OK)
  {
    if (size_in_bytes != (uint16_t *)0x0)
    {
      *size_in_bytes = pkt_len;
    }
    if (max_size_in_bytes < pkt_len)
    {
      status = RAL_STATUS_ERROR;
    }
    else
    {
      status = lr20xx_radio_fifo_read_rx(context,buffer,pkt_len);
    }
  }
  return status;
}



ral_status_t ral_lr20xx_get_irq_status(void *context,ral_irq_t *irq)
{
  ral_irq_t rVar1;
  ral_irq_t *irq_local;
  void *context_local;
  lr20xx_system_stat2_t stat2;
  lr20xx_system_stat1_t stat1;
  lr20xx_system_irq_mask_t radio_irq_mask;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  status = lr20xx_system_get_status(context,&stat1,&stat2,&radio_irq_mask);
  if (status == LR20XX_STATUS_OK)
  {
    rVar1 = ral_lr20xx_convert_irq_flags_to_ral(radio_irq_mask);
    *irq = rVar1;
  }
  return status;
}



ral_status_t ral_lr20xx_clear_irq_status(void *context,ral_irq_t irq)
{
  lr20xx_status_t lVar1;
  lr20xx_system_irq_mask_t irqs_to_clear;
  ral_irq_t irq_local;
  void *context_local;
  lr20xx_system_irq_mask_t radio_irq;
  
  irqs_to_clear = ral_lr20xx_convert_irq_flags_from_ral(irq);
  lVar1 = lr20xx_system_clear_irq_status(context,irqs_to_clear);
  return lVar1;
}



ral_status_t ral_lr20xx_get_and_clear_irq_status(void *context,ral_irq_t *irq)
{
  ral_irq_t rVar1;
  ral_irq_t *irq_local;
  void *context_local;
  lr20xx_system_irq_mask_t radio_irq;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  radio_irq = 0;
  status = lr20xx_system_get_and_clear_irq_status(context,&radio_irq);
  if ((status == LR20XX_STATUS_OK) && (irq != (ral_irq_t *)0x0))
  {
    rVar1 = ral_lr20xx_convert_irq_flags_to_ral(radio_irq);
    *irq = rVar1;
  }
  return status;
}



ral_status_t ral_lr20xx_set_dio_irq_params(void *context,ral_irq_t irq)
{
  _Bool _Var1;
  ral_irq_t irq_local;
  void *context_local;
  lr20xx_system_irq_mask_t dio_irq_mask;
  lr20xx_system_dio_func_t dio_function;
  lr20xx_system_dio_t dio;
  uint8_t dio_count;
  lr20xx_system_irq_mask_t lr20xx_irq;
  uint8_t dio_nth;
  lr20xx_system_irq_mask_t all_dios_irq_mask;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  lr20xx_irq = ral_lr20xx_convert_irq_flags_from_ral(irq);
  all_dios_irq_mask = 0;
  dio_count = lr20xx_system_dio_get_count();
  dio_nth = '\0';
  while( true )
  {
    if (dio_count <= dio_nth)
    {
      if (all_dios_irq_mask != lr20xx_irq)
      {
        status = RAL_STATUS_ERROR;
      }
      return status;
    }
    dio_function = LR20XX_SYSTEM_DIO_FUNC_NONE;
    dio_irq_mask = 0;
    _Var1 = lr20xx_system_dio_get_nth(dio_nth,&dio);
    if (!_Var1) break;
    ral_lr20xx_bsp_get_dio_function(context,dio,&dio_function);
    if (dio_function == LR20XX_SYSTEM_DIO_FUNC_IRQ)
    {
      ral_lr20xx_bsp_get_dio_irq_mask(context,dio,&dio_irq_mask);
      dio_irq_mask = lr20xx_irq & dio_irq_mask;
      all_dios_irq_mask = dio_irq_mask | all_dios_irq_mask;
      status = lr20xx_system_set_dio_irq_cfg(context,dio,dio_irq_mask);
      if (status != LR20XX_STATUS_OK)
      {
        return RAL_STATUS_ERROR;
      }
    }
    dio_nth += '\x01';
  }
  return RAL_STATUS_ERROR;
}



ral_status_t ral_lr20xx_set_rf_freq(void *context,uint32_t freq_in_hz)
{
  lr20xx_status_t lVar1;
  uint32_t freq_in_hz_local;
  void *context_local;
  lr20xx_radio_common_rx_path_boost_mode_t boost_mode;
  lr20xx_radio_common_rx_path_t rx_path;
  
  lr20xx_radio_common_set_rf_freq(context,freq_in_hz);
  rx_path = LR20XX_RADIO_COMMON_RX_PATH_LF;
  boost_mode = LR20XX_RADIO_COMMON_RX_PATH_BOOST_MODE_NONE;
  ral_lr20xx_bsp_get_rx_cfg(context,freq_in_hz,&rx_path,&boost_mode);
  lVar1 = lr20xx_radio_common_set_rx_path(context,rx_path,boost_mode);
  return lVar1;
}



ral_status_t ral_lr20xx_set_pkt_type(void *context,ral_pkt_type_t ral_pkt_type)
{
  lr20xx_status_t lVar1;
  ral_pkt_type_t ral_pkt_type_local;
  void *context_local;
  lr20xx_radio_common_pkt_type_t radio_pkt_type;
  
  switch(ral_pkt_type)
  {
  case RAL_PKT_TYPE_GFSK:
    radio_pkt_type = LR20XX_RADIO_COMMON_PKT_TYPE_FSK;
    break;
  case RAL_PKT_TYPE_LORA:
    radio_pkt_type = LR20XX_RADIO_COMMON_PKT_TYPE_LORA;
    break;
  case RAL_PKT_TYPE_FLRC:
    radio_pkt_type = LR20XX_RADIO_COMMON_PKT_TYPE_FLRC;
    break;
  case RAL_PKT_TYPE_RTTOF:
    radio_pkt_type = LR20XX_RADIO_COMMON_PKT_TYPE_RTTOF;
    break;
  default:
    return RAL_STATUS_UNKNOWN_VALUE;
  }
  lVar1 = lr20xx_radio_common_set_pkt_type(context,radio_pkt_type);
  return lVar1;
}



ral_status_t ral_lr20xx_get_pkt_type(void *context,ral_pkt_type_t *pkt_type)
{
  lr20xx_status_t lVar1;
  ral_pkt_type_t *pkt_type_local;
  void *context_local;
  lr20xx_radio_common_pkt_type_t radio_pkt_type;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  lVar1 = lr20xx_radio_common_get_pkt_type(context,&radio_pkt_type);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    if (radio_pkt_type == LR20XX_RADIO_COMMON_PKT_TYPE_FLRC)
    {
      *pkt_type = RAL_PKT_TYPE_FLRC;
    }
    else
    {
      if (radio_pkt_type < LR20XX_RADIO_COMMON_PKT_TYPE_BPSK)
      {
        if (radio_pkt_type == LR20XX_RADIO_COMMON_PKT_TYPE_LORA)
        {
          *pkt_type = RAL_PKT_TYPE_LORA;
          return RAL_STATUS_OK;
        }
        if (radio_pkt_type == LR20XX_RADIO_COMMON_PKT_TYPE_FSK)
        {
          *pkt_type = RAL_PKT_TYPE_GFSK;
          return RAL_STATUS_OK;
        }
      }
      lVar1 = 2;
    }
  }
  return lVar1;
}



ral_status_t ral_lr20xx_set_gfsk_mod_params(void *context,ral_gfsk_mod_params_t *ral_mod_params)
{
  lr20xx_status_t lVar1;
  ral_gfsk_mod_params_t *ral_mod_params_local;
  void *context_local;
  lr20xx_radio_fsk_mod_params_t radio_mod_params;
  ral_status_t status;
  
  radio_mod_params.br = 0;
  radio_mod_params.pulse_shape = LR20XX_RADIO_FSK_PULSE_SHAPE_DISABLED;
  radio_mod_params.bw = LR20XX_RADIO_FSK_COMMON_RX_BW_3_076_000_HZ;
  radio_mod_params._6_2_ = 0;
  radio_mod_params.fdev_in_hz = 0;
  lVar1 = ral_lr20xx_convert_gfsk_mod_params_from_ral(ral_mod_params,&radio_mod_params);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_radio_fsk_set_modulation_params(context,&radio_mod_params);
  }
  return lVar1;
}



ral_status_t ral_lr20xx_set_gfsk_pkt_params(void *context,ral_gfsk_pkt_params_t *ral_pkt_params)
{
  lr20xx_status_t lVar1;
  ral_gfsk_pkt_params_t *ral_pkt_params_local;
  void *context_local;
  lr20xx_radio_fsk_pkt_params_t radio_pkt_params;
  ral_status_t status;
  
  radio_pkt_params.pbl_length_in_bit = 0;
  radio_pkt_params.preamble_detector = LR20XX_RADIO_FSK_PREAMBLE_DETECTOR_DISABLED;
  radio_pkt_params.long_preamble_enabled = false;
  radio_pkt_params.address_filtering = LR20XX_RADIO_FSK_ADDRESS_FILTERING_DISABLED;
  radio_pkt_params.header_mode = LR20XX_RADIO_FSK_HEADER_IMPLICIT;
  radio_pkt_params.payload_length_unit = LR20XX_RADIO_FSK_PAYLOAD_LENGTH_IN_BYTE;
  radio_pkt_params._7_1_ = 0;
  radio_pkt_params.payload_length = 0;
  radio_pkt_params.crc = LR20XX_RADIO_FSK_CRC_OFF;
  radio_pkt_params.whitening = LR20XX_RADIO_FSK_WHITENING_OFF;
  lVar1 = ral_lr20xx_convert_gfsk_pkt_params_from_ral(ral_pkt_params,&radio_pkt_params);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_radio_fsk_set_packet_params(context,&radio_pkt_params);
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_set_gfsk_pkt_address(void *context,uint8_t node_address,uint8_t braodcast_address)
{
  lr20xx_status_t lVar1;
  uint8_t braodcast_address_local;
  uint8_t node_address_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_fsk_set_addresses(context,node_address,braodcast_address);
  return lVar1;
}



ral_status_t ral_lr20xx_set_lora_mod_params(void *context,ral_lora_mod_params_t *ral_mod_params)
{
  lr20xx_status_t lVar1;
  ral_lora_mod_params_t *ral_mod_params_local;
  void *context_local;
  lr20xx_radio_lora_mod_params_t radio_mod_params;
  ral_status_t status;
  
  lVar1 = ral_lr20xx_convert_lora_mod_params_from_ral(ral_mod_params,&radio_mod_params);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_radio_lora_set_modulation_params(context,&radio_mod_params);
  }
  return lVar1;
}



ral_status_t ral_lr20xx_set_lora_pkt_params(void *context,ral_lora_pkt_params_t *ral_pkt_params)
{
  lr20xx_status_t lVar1;
  ral_lora_pkt_params_t *ral_pkt_params_local;
  void *context_local;
  lr20xx_radio_lora_pkt_params_t radio_pkt_params;
  ral_status_t status;
  
  radio_pkt_params.preamble_len_in_symb = 0;
  radio_pkt_params.pkt_mode = LR20XX_RADIO_LORA_PKT_EXPLICIT;
  radio_pkt_params.pld_len_in_bytes = '\0';
  radio_pkt_params.crc = LR20XX_RADIO_LORA_CRC_DISABLED;
  radio_pkt_params.iq = LR20XX_RADIO_LORA_IQ_STANDARD;
  lVar1 = ral_lr20xx_convert_lora_pkt_params_from_ral(ral_pkt_params,&radio_pkt_params);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_radio_lora_set_packet_params(context,&radio_pkt_params);
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_set_lora_cad_params(void *context,ral_lora_cad_params_t *ral_lora_cad_params)
{
  lr20xx_status_t lVar1;
  ral_lora_cad_params_t *ral_lora_cad_params_local;
  void *context_local;
  lr20xx_radio_lora_cad_params_t radio_lora_cad_params;
  ral_status_t status;
  
  lVar1 = ral_lr20xx_convert_lora_cad_params_from_ral(ral_lora_cad_params,&radio_lora_cad_params);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lVar1 = lr20xx_radio_lora_configure_cad_params(context,&radio_lora_cad_params);
  }
  return lVar1;
}



ral_status_t ral_lr20xx_set_lora_symb_nb_timeout(void *context,uint16_t nb_of_symbs)
{
  lr20xx_status_t lVar1;
  uint16_t nb_of_symbs_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_lora_configure_timeout_by_number_of_symbols(context,(uint8_t)nb_of_symbs);
  return lVar1;
}



ral_status_t ral_lr20xx_set_flrc_mod_params(void *context,ral_flrc_mod_params_t *params)
{
  ral_flrc_mod_params_t *params_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr20xx_set_flrc_pkt_params(void *context,ral_flrc_pkt_params_t *params)
{
  ral_flrc_pkt_params_t *params_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t
ral_lr20xx_get_gfsk_rx_pkt_status(void *context,ral_gfsk_rx_pkt_status_t *ral_rx_pkt_status)
{
  lr20xx_status_t lVar1;
  ral_gfsk_rx_pkt_status_t *ral_rx_pkt_status_local;
  void *context_local;
  lr20xx_radio_fsk_packet_status_t radio_rx_pkt_status;
  ral_status_t status;
  
  lVar1 = lr20xx_radio_fsk_get_packet_status(context,&radio_rx_pkt_status);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    ral_rx_pkt_status->rx_status = 0;
    ral_rx_pkt_status->rssi_sync_in_dbm = radio_rx_pkt_status.rssi_sync_in_dbm;
    ral_rx_pkt_status->rssi_avg_in_dbm = radio_rx_pkt_status.rssi_avg_in_dbm;
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_get_lora_rx_pkt_status(void *context,ral_lora_rx_pkt_status_t *ral_rx_pkt_status)
{
  lr20xx_status_t lVar1;
  ral_lora_rx_pkt_status_t *ral_rx_pkt_status_local;
  void *context_local;
  lr20xx_radio_lora_packet_status_t radio_rx_pkt_status;
  ral_status_t status;
  
  lVar1 = lr20xx_radio_lora_get_packet_status(context,&radio_rx_pkt_status);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    ral_rx_pkt_status->rssi_pkt_in_dbm = radio_rx_pkt_status.rssi_pkt_in_dbm;
    ral_rx_pkt_status->snr_pkt_in_db = (int16_t)(radio_rx_pkt_status.snr_pkt_raw + 2 >> 2);
    ral_rx_pkt_status->signal_rssi_pkt_in_dbm = radio_rx_pkt_status.rssi_signal_pkt_in_dbm;
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_get_flrc_rx_pkt_status(void *context,ral_flrc_rx_pkt_status_t *rx_pkt_status)
{
  ral_flrc_rx_pkt_status_t *rx_pkt_status_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr20xx_get_rssi_inst(void *context,int16_t *rssi_in_dbm)
{
  lr20xx_status_t lVar1;
  int16_t *rssi_in_dbm_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_common_get_rssi_inst(context,rssi_in_dbm,(uint8_t *)0x0);
  return lVar1;
}



uint32_t ral_lr20xx_get_lora_time_on_air_in_ms
                   (ral_lora_pkt_params_t *pkt_p,ral_lora_mod_params_t *mod_p)
{
  uint32_t uVar1;
  ral_lora_mod_params_t *mod_p_local;
  ral_lora_pkt_params_t *pkt_p_local;
  lr20xx_radio_lora_pkt_params_t radio_pkt_params;
  lr20xx_radio_lora_mod_params_t radio_mod_params;
  
  ral_lr20xx_convert_lora_mod_params_from_ral(mod_p,&radio_mod_params);
  ral_lr20xx_convert_lora_pkt_params_from_ral(pkt_p,&radio_pkt_params);
  uVar1 = lr20xx_radio_lora_get_time_on_air_in_ms(&radio_pkt_params,&radio_mod_params);
  return uVar1;
}



uint32_t ral_lr20xx_get_gfsk_time_on_air_in_ms
                   (ral_gfsk_pkt_params_t *pkt_p,ral_gfsk_mod_params_t *mod_p)
{
  uint32_t uVar1;
  ral_gfsk_mod_params_t *mod_p_local;
  ral_gfsk_pkt_params_t *pkt_p_local;
  lr20xx_radio_fsk_pkt_params_t radio_pkt_params;
  lr20xx_radio_fsk_mod_params_t radio_mod_params;
  
  ral_lr20xx_convert_gfsk_mod_params_from_ral(mod_p,&radio_mod_params);
  ral_lr20xx_convert_gfsk_pkt_params_from_ral(pkt_p,&radio_pkt_params);
  uVar1 = lr20xx_radio_fsk_get_time_on_air_in_ms
                    (&radio_pkt_params,&radio_mod_params,pkt_p->sync_word_len_in_bits);
  return uVar1;
}



uint32_t ral_lr20xx_get_flrc_time_on_air_in_ms
                   (ral_flrc_pkt_params_t *pkt_p,ral_flrc_mod_params_t *mod_p)
{
  ral_flrc_mod_params_t *mod_p_local;
  ral_flrc_pkt_params_t *pkt_p_local;
  
  return 1;
}



ral_status_t ral_lr20xx_set_gfsk_sync_word(void *context,uint8_t *sync_word,uint8_t sync_word_len)
{
  lr20xx_status_t lVar1;
  uint8_t sync_word_len_local;
  uint8_t *sync_word_local;
  void *context_local;
  uint8_t syncword [8];
  int i_1;
  int i;
  
  for (i = 0; i < (int)(uint)sync_word_len; i += 1)
  {
    syncword[7 - i] = sync_word[((uint)sync_word_len - i) + -1];
  }
  for (i_1 = 0; i_1 < (int)(8 - (uint)sync_word_len); i_1 += 1)
  {
    syncword[i_1] = '\0';
  }
  lVar1 = lr20xx_radio_fsk_set_syncword
                    (context,syncword,sync_word_len << 3,LR20XX_RADIO_FSK_SYNCWORD_MSBF);
  return lVar1;
}



ral_status_t ral_lr20xx_set_lora_sync_word(void *context,uint8_t sync_word)
{
  lr20xx_status_t lVar1;
  uint8_t sync_word_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_lora_set_syncword(context,sync_word);
  return lVar1;
}



ral_status_t ral_lr20xx_set_flrc_sync_word(void *context,uint8_t *sync_word,uint8_t sync_word_len)
{
  uint8_t sync_word_len_local;
  uint8_t *sync_word_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr20xx_set_gfsk_crc_params(void *context,uint32_t seed,uint32_t polynomial)
{
  lr20xx_status_t lVar1;
  uint32_t polynomial_local;
  uint32_t seed_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_fsk_set_crc_params(context,polynomial,seed);
  return lVar1;
}



ral_status_t ral_lr20xx_set_flrc_crc_params(void *context,uint32_t seed)
{
  uint32_t seed_local;
  void *context_local;
  
  return RAL_STATUS_UNSUPPORTED_FEATURE;
}



ral_status_t ral_lr20xx_set_gfsk_whitening_seed(void *context,uint16_t seed)
{
  lr20xx_status_t lVar1;
  uint16_t seed_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_fsk_set_whitening_params
                    (context,LR20XX_RADIO_FSK_WHITENING_COMPATIBILITY_SX126X_LR11XX,seed);
  return lVar1;
}



ral_status_t ral_lr20xx_lr_fhss_init(void *context,ral_lr_fhss_params_t *lr_fhss_params)
{
  lr20xx_status_t lVar1;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  
  lVar1 = lr20xx_radio_lr_fhss_init(context);
  return lVar1;
}



ral_status_t
ral_lr20xx_lr_fhss_build_frame
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,ral_lr_fhss_memory_state_t state,
          uint16_t hop_sequence_id,uint8_t *payload,uint16_t payload_length)
{
  lr20xx_status_t lVar1;
  uint16_t hop_sequence_id_local;
  ral_lr_fhss_memory_state_t state_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  lr20xx_system_stat1_t stat1;
  lr20xx_radio_lr_fhss_params_t lr20xx_params;
  lr20xx_status_t status;
  
  ral_lr20xx_convert_lr_fhss_params_from_ral(lr_fhss_params,&lr20xx_params);
  lVar1 = lr20xx_radio_common_set_rf_freq(context,lr_fhss_params->center_frequency_in_hz);
  if (((lVar1 == LR20XX_STATUS_OK) &&
      (lVar1 = lr20xx_radio_lr_fhss_build_frame
                         (context,&lr20xx_params,hop_sequence_id,payload,(uint8_t)payload_length),
      lVar1 == LR20XX_STATUS_OK)) &&
     (lVar1 = lr20xx_system_get_status
                        (context,&stat1,(lr20xx_system_stat2_t *)0x0,(lr20xx_system_irq_mask_t *)0x0
                        ), lVar1 == LR20XX_STATUS_OK))
  {
    if (stat1.command_status == LR20XX_SYSTEM_CMD_STATUS_OK)
    {
      lVar1 = LR20XX_STATUS_OK;
    }
    else
    {
      lVar1 = LR20XX_STATUS_ERROR;
    }
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_lr_fhss_handle_hop
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,ral_lr_fhss_memory_state_t state)
{
  ral_lr_fhss_memory_state_t state_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_lr_fhss_handle_tx_done
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,ral_lr_fhss_memory_state_t state)
{
  ral_lr_fhss_memory_state_t state_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t ral_lr20xx_get_random_numbers(void *context,uint32_t *numbers,uint n)
{
  uint n_local;
  uint32_t *numbers_local;
  void *context_local;
  uint i;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  i = 0;
  while ((i < n && (status = lr20xx_system_get_random_number(context,'\x03',numbers + i),
                   status == LR20XX_STATUS_OK)))
  {
    i += 1;
  }
  return status;
}



ral_status_t ral_lr20xx_handle_rx_done(void *context)
{
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t ral_lr20xx_handle_tx_done(void *context)
{
  void *context_local;
  
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_get_lora_rx_pkt_cr_crc(void *context,ral_lora_cr_t *cr,_Bool *is_crc_present)
{
  lr20xx_status_t lVar1;
  _Bool *is_crc_present_local;
  ral_lora_cr_t *cr_local;
  void *context_local;
  lr20xx_radio_lora_packet_status_t radio_rx_pkt_status;
  ral_status_t status;
  
  lVar1 = lr20xx_radio_lora_get_packet_status(context,&radio_rx_pkt_status);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    *cr = radio_rx_pkt_status.cr;
    *is_crc_present = radio_rx_pkt_status.crc != LR20XX_RADIO_LORA_CRC_DISABLED;
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_get_tx_consumption_in_ua
          (void *context,int8_t output_pwr_in_dbm,uint32_t rf_freq_in_hz,
          uint32_t *pwr_consumption_in_ua)
{
  ral_status_t rVar1;
  uint32_t *pwr_consumption_in_ua_local;
  uint32_t rf_freq_in_hz_local;
  int8_t output_pwr_in_dbm_local;
  void *context_local;
  ral_lr20xx_bsp_tx_cfg_input_params_t tx_cfg_input_params;
  ral_lr20xx_bsp_tx_cfg_output_params_t tx_cfg_output_params;
  lr20xx_system_reg_mode_t radio_reg_mode;
  
  tx_cfg_input_params.system_output_pwr_in_dbm = output_pwr_in_dbm;
  tx_cfg_input_params.freq_in_hz = rf_freq_in_hz;
  ral_lr20xx_bsp_get_tx_cfg(context,&tx_cfg_input_params,&tx_cfg_output_params);
  ral_lr20xx_bsp_get_reg_mode(context,&radio_reg_mode);
  rVar1 = ral_lr20xx_bsp_get_instantaneous_tx_power_consumption
                    (context,&tx_cfg_output_params,radio_reg_mode,pwr_consumption_in_ua);
  return rVar1;
}



ral_status_t
ral_lr20xx_get_gfsk_rx_consumption_in_ua
          (void *context,uint32_t br_in_bps,uint32_t bw_dsb_in_hz,_Bool rx_boosted,
          uint32_t *pwr_consumption_in_ua)
{
  ral_status_t rVar1;
  _Bool rx_boosted_local;
  uint32_t bw_dsb_in_hz_local;
  uint32_t br_in_bps_local;
  void *context_local;
  lr20xx_system_reg_mode_t radio_reg_mode;
  
  ral_lr20xx_bsp_get_reg_mode(context,&radio_reg_mode);
  rVar1 = ral_lr20xx_bsp_get_instantaneous_gfsk_rx_power_consumption
                    (context,radio_reg_mode,rx_boosted,pwr_consumption_in_ua);
  return rVar1;
}



ral_status_t
ral_lr20xx_get_lora_rx_consumption_in_ua
          (void *context,ral_lora_bw_t bw,_Bool rx_boosted,uint32_t *pwr_consumption_in_ua)
{
  ral_status_t rVar1;
  uint32_t *pwr_consumption_in_ua_local;
  _Bool rx_boosted_local;
  ral_lora_bw_t bw_local;
  void *context_local;
  lr20xx_system_reg_mode_t radio_reg_mode;
  
  ral_lr20xx_bsp_get_reg_mode(context,&radio_reg_mode);
  rVar1 = ral_lr20xx_bsp_get_instantaneous_lora_rx_power_consumption
                    (context,radio_reg_mode,bw,rx_boosted,pwr_consumption_in_ua);
  return rVar1;
}



ral_status_t
ral_lr20xx_lr_fhss_get_time_on_air_in_ms
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,uint16_t payload_length,
          uint32_t *time_on_air)
{
  uint32_t uVar1;
  uint32_t *time_on_air_local;
  uint16_t payload_length_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  lr20xx_radio_lr_fhss_params_t lr20xx_params;
  
  ral_lr20xx_convert_lr_fhss_params_from_ral(lr_fhss_params,&lr20xx_params);
  uVar1 = lr20xx_radio_lr_fhss_get_time_on_air_in_ms(&lr20xx_params,payload_length);
  *time_on_air = uVar1;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_lr_fhss_get_bit_delay_in_us
          (void *context,ral_lr_fhss_params_t *params,uint16_t payload_length,uint16_t *delay)
{
  uint16_t *delay_local;
  uint16_t payload_length_local;
  ral_lr_fhss_params_t *params_local;
  void *context_local;
  
  *delay = 0;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_lr_fhss_get_hop_sequence_count
          (void *context,ral_lr_fhss_params_t *lr_fhss_params,uint *hop_sequence_count)
{
  uint uVar1;
  uint *hop_sequence_count_local;
  ral_lr_fhss_params_t *lr_fhss_params_local;
  void *context_local;
  lr20xx_radio_lr_fhss_params_t lr20xx_params;
  
  ral_lr20xx_convert_lr_fhss_params_from_ral(lr_fhss_params,&lr20xx_params);
  uVar1 = lr20xx_radio_lr_fhss_get_hop_sequence_count(&lr20xx_params);
  *hop_sequence_count = uVar1;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_get_lora_cad_det_peak
          (void *context,ral_lora_sf_t sf,ral_lora_bw_t bw,ral_lora_cad_symbs_t nb_symbol,
          uint8_t *cad_det_peak)
{
  ral_status_t rVar1;
  ral_lora_cad_symbs_t nb_symbol_local;
  ral_lora_bw_t bw_local;
  ral_lora_sf_t sf_local;
  void *context_local;
  uint8_t sf_index;
  
  if ((sf < RAL_LORA_SF5) || (RAL_LORA_SF12 < sf))
  {
    rVar1 = RAL_STATUS_UNKNOWN_VALUE;
  }
  else if (nb_symbol < RAL_LORA_CAD_08_SYMB)
  {
    *cad_det_peak = *(uint8_t *)((uint)(byte)(sf - RAL_LORA_SF5) + (uint)nb_symbol * 8 + 0x8039464);
    ral_lr20xx_bsp_get_lora_cad_det_peak(context,sf,nb_symbol,cad_det_peak);
    rVar1 = RAL_STATUS_OK;
  }
  else
  {
    rVar1 = RAL_STATUS_UNKNOWN_VALUE;
  }
  return rVar1;
}



ral_irq_t ral_lr20xx_convert_irq_flags_to_ral(lr20xx_system_irq_mask_t lr20xx_irq_status)
{
  lr20xx_system_irq_mask_t lr20xx_irq_status_local;
  ral_irq_t ral_irq;
  
  ral_irq = 0;
  if ((lr20xx_irq_status & 0x80000) != 0)
  {
    ral_irq = 2;
  }
  if ((lr20xx_irq_status & 0x40000) != 0)
  {
    ral_irq |= 4;
  }
  if ((lr20xx_irq_status & 0x20) != 0)
  {
    ral_irq |= 0x10;
  }
  if ((lr20xx_irq_status & 0x200000) != 0)
  {
    ral_irq |= 8;
  }
  if ((lr20xx_irq_status & 0x40) != 0)
  {
    ral_irq |= 0x20;
  }
  if ((lr20xx_irq_status & 0x200) != 0)
  {
    ral_irq |= 0x40;
  }
  if ((lr20xx_irq_status & 0x400000) != 0)
  {
    ral_irq |= 0x80;
  }
  if ((lr20xx_irq_status & 0x100000) != 0)
  {
    ral_irq |= 0x100;
  }
  if ((lr20xx_irq_status & 0x80) != 0)
  {
    ral_irq |= 0x200;
  }
  if ((lr20xx_irq_status & 0x2000000) != 0)
  {
    ral_irq |= 0x400;
  }
  if ((lr20xx_irq_status & 0x20000000) != 0)
  {
    ral_irq |= 0x10000;
  }
  if ((lr20xx_irq_status & 0x10000000) != 0)
  {
    ral_irq |= 0x20000;
  }
  if ((lr20xx_irq_status & 0x40000000) != 0)
  {
    ral_irq |= 0x40000;
  }
  if ((int)lr20xx_irq_status < 0)
  {
    ral_irq |= 0x80000;
  }
  return ral_irq;
}



lr20xx_system_irq_mask_t ral_lr20xx_convert_irq_flags_from_ral(ral_irq_t ral_irq)
{
  ral_irq_t ral_irq_local;
  lr20xx_system_irq_mask_t lr20xx_irq_status;
  
  lr20xx_irq_status = 0;
  if ((ral_irq & 2) != 0)
  {
    lr20xx_irq_status = 0x80000;
  }
  if ((ral_irq & 4) != 0)
  {
    lr20xx_irq_status |= 0x40000;
  }
  if ((ral_irq & 0x10) != 0)
  {
    lr20xx_irq_status |= 0x20;
  }
  if ((ral_irq & 8) != 0)
  {
    lr20xx_irq_status |= 0x200000;
  }
  if ((ral_irq & 0x20) != 0)
  {
    lr20xx_irq_status |= 0x40;
  }
  if ((ral_irq & 0x40) != 0)
  {
    lr20xx_irq_status |= 0x200;
  }
  if ((ral_irq & 0x80) != 0)
  {
    lr20xx_irq_status |= 0x400000;
  }
  if ((ral_irq & 0x100) != 0)
  {
    lr20xx_irq_status |= 0x100000;
  }
  if ((ral_irq & 0x200) != 0)
  {
    lr20xx_irq_status |= 0x80;
  }
  if ((ral_irq & 0x400) != 0)
  {
    lr20xx_irq_status |= 0x2000000;
  }
  if ((ral_irq & 0x2000) != 0)
  {
    lr20xx_irq_status |= 1;
  }
  if ((ral_irq & 0x4000) != 0)
  {
    lr20xx_irq_status |= 2;
  }
  if ((ral_irq & 0x10000) != 0)
  {
    lr20xx_irq_status |= 0x20000000;
  }
  if ((ral_irq & 0x20000) != 0)
  {
    lr20xx_irq_status |= 0x10000000;
  }
  if ((ral_irq & 0x40000) != 0)
  {
    lr20xx_irq_status |= 0x40000000;
  }
  if ((ral_irq & 0x80000) != 0)
  {
    lr20xx_irq_status |= 0x80000000;
  }
  return lr20xx_irq_status;
}



ral_status_t
ral_lr20xx_convert_gfsk_mod_params_from_ral
          (ral_gfsk_mod_params_t *ral_mod_params,lr20xx_radio_fsk_mod_params_t *radio_mod_params)
{
  lr20xx_status_t lVar1;
  lr20xx_radio_fsk_mod_params_t *radio_mod_params_local;
  ral_gfsk_mod_params_t *ral_mod_params_local;
  lr20xx_radio_fsk_common_bw_t bw_dsb_param;
  ral_status_t status;
  
  status = RAL_STATUS_ERROR;
  lVar1 = lr20xx_radio_fsk_get_rx_bandwidth(ral_mod_params->bw_dsb_in_hz,&bw_dsb_param);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    radio_mod_params->br = ral_mod_params->br_in_bps;
    radio_mod_params->fdev_in_hz = ral_mod_params->fdev_in_hz;
    radio_mod_params->bw = bw_dsb_param;
    switch(ral_mod_params->pulse_shape)
    {
    case RAL_GFSK_PULSE_SHAPE_OFF:
      radio_mod_params->pulse_shape = LR20XX_RADIO_FSK_PULSE_SHAPE_DISABLED;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_03:
      radio_mod_params->pulse_shape = LR20XX_RADIO_FSK_PULSE_SHAPE_GAUSSIAN_BT_0_3;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_05:
      radio_mod_params->pulse_shape = LR20XX_RADIO_FSK_PULSE_SHAPE_GAUSSIAN_BT_0_5;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_07:
      radio_mod_params->pulse_shape = LR20XX_RADIO_FSK_PULSE_SHAPE_GAUSSIAN_BT_0_7;
      break;
    case RAL_GFSK_PULSE_SHAPE_BT_1:
      radio_mod_params->pulse_shape = LR20XX_RADIO_FSK_PULSE_SHAPE_GAUSSIAN_BT_1_0;
      break;
    default:
      lVar1 = 2;
    }
  }
  return lVar1;
}



ral_status_t
ral_lr20xx_convert_gfsk_pkt_params_from_ral
          (ral_gfsk_pkt_params_t *ral_pkt_params,lr20xx_radio_fsk_pkt_params_t *radio_pkt_params)
{
  ral_gfsk_address_filtering_t rVar1;
  ral_gfsk_pkt_len_modes_t rVar2;
  lr20xx_radio_fsk_pkt_params_t *radio_pkt_params_local;
  ral_gfsk_pkt_params_t *ral_pkt_params_local;
  
  radio_pkt_params->pbl_length_in_bit = ral_pkt_params->preamble_len_in_bits;
  if (true)
  {
    switch(ral_pkt_params->preamble_detector)
    {
    case RAL_GFSK_PREAMBLE_DETECTOR_OFF:
      radio_pkt_params->preamble_detector = LR20XX_RADIO_FSK_PREAMBLE_DETECTOR_DISABLED;
      break;
    default:
      goto LAB_080289a8;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_8BITS:
      radio_pkt_params->preamble_detector = LR20XX_RADIO_FSK_PREAMBLE_DETECTOR_8_BITS;
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_16BITS:
      radio_pkt_params->preamble_detector = LR20XX_RADIO_FSK_PREAMBLE_DETECTOR_16_BITS;
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_24BITS:
      radio_pkt_params->preamble_detector = LR20XX_RADIO_FSK_PREAMBLE_DETECTOR_24_BITS;
      break;
    case RAL_GFSK_PREAMBLE_DETECTOR_MIN_32BITS:
      radio_pkt_params->preamble_detector = LR20XX_RADIO_FSK_PREAMBLE_DETECTOR_32_BITS;
    }
    rVar1 = ral_pkt_params->address_filtering;
    if (rVar1 == RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES)
    {
      radio_pkt_params->address_filtering = LR20XX_RADIO_FSK_ADDRESS_FILTERING_NODE_BROADCAST;
    }
    else
    {
      if (RAL_GFSK_ADDRESS_FILTERING_NODE_AND_BROADCAST_ADDRESSES < rVar1)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      if (rVar1 == RAL_GFSK_ADDRESS_FILTERING_DISABLE)
      {
        radio_pkt_params->address_filtering = LR20XX_RADIO_FSK_ADDRESS_FILTERING_DISABLED;
      }
      else
      {
        if (rVar1 != RAL_GFSK_ADDRESS_FILTERING_NODE_ADDRESS)
        {
          return RAL_STATUS_UNKNOWN_VALUE;
        }
        radio_pkt_params->address_filtering = LR20XX_RADIO_FSK_ADDRESS_FILTERING_NODE;
      }
    }
    rVar2 = ral_pkt_params->header_type;
    if (rVar2 == RAL_GFSK_PKT_VAR_LEN_SX128X_COMP)
    {
      radio_pkt_params->header_mode = LR20XX_RADIO_FSK_HEADER_SX128X_COMPATIBLE;
    }
    else
    {
      if (RAL_GFSK_PKT_VAR_LEN_SX128X_COMP < rVar2)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      if (rVar2 == RAL_GFSK_PKT_FIX_LEN)
      {
        radio_pkt_params->header_mode = LR20XX_RADIO_FSK_HEADER_IMPLICIT;
      }
      else
      {
        if (rVar2 != RAL_GFSK_PKT_VAR_LEN)
        {
          return RAL_STATUS_UNKNOWN_VALUE;
        }
        radio_pkt_params->header_mode = LR20XX_RADIO_FSK_HEADER_8BITS;
      }
    }
    radio_pkt_params->payload_length = ral_pkt_params->pld_len_in_bytes;
    switch(ral_pkt_params->crc_type)
    {
    case RAL_GFSK_CRC_OFF:
      radio_pkt_params->crc = LR20XX_RADIO_FSK_CRC_OFF;
      break;
    case RAL_GFSK_CRC_1_BYTE:
      radio_pkt_params->crc = LR20XX_RADIO_FSK_CRC_1_BYTE;
      break;
    case RAL_GFSK_CRC_2_BYTES:
      radio_pkt_params->crc = LR20XX_RADIO_FSK_CRC_2_BYTES;
      break;
    case RAL_GFSK_CRC_1_BYTE_INV:
      radio_pkt_params->crc = LR20XX_RADIO_FSK_CRC_1_BYTE_INVERTED;
      break;
    case RAL_GFSK_CRC_2_BYTES_INV:
      radio_pkt_params->crc = LR20XX_RADIO_FSK_CRC_2_BYTES_INVERTED;
      break;
    case RAL_GFSK_CRC_3_BYTES:
      radio_pkt_params->crc = LR20XX_RADIO_FSK_CRC_3_BYTES;
      break;
    default:
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    if (ral_pkt_params->dc_free == RAL_GFSK_DC_FREE_OFF)
    {
      radio_pkt_params->whitening = LR20XX_RADIO_FSK_WHITENING_OFF;
    }
    else
    {
      if (ral_pkt_params->dc_free != RAL_GFSK_DC_FREE_WHITENING)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      radio_pkt_params->whitening = LR20XX_RADIO_FSK_WHITENING_ON;
    }
    return RAL_STATUS_OK;
  }
LAB_080289a8:
  return RAL_STATUS_UNKNOWN_VALUE;
}



ral_status_t
ral_lr20xx_convert_lora_mod_params_from_ral
          (ral_lora_mod_params_t *ral_mod_params,lr20xx_radio_lora_mod_params_t *radio_mod_params)
{
  lr20xx_radio_lora_mod_params_t *radio_mod_params_local;
  ral_lora_mod_params_t *ral_mod_params_local;
  
  radio_mod_params->sf = ral_mod_params->sf;
  switch(ral_mod_params->bw)
  {
  case RAL_LORA_BW_007_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_7;
    break;
  case RAL_LORA_BW_010_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_10;
    break;
  case RAL_LORA_BW_015_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_15;
    break;
  case RAL_LORA_BW_020_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_20;
    break;
  case RAL_LORA_BW_031_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_31;
    break;
  case RAL_LORA_BW_041_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_41;
    break;
  case RAL_LORA_BW_062_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_62;
    break;
  case RAL_LORA_BW_125_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_125;
    break;
  case RAL_LORA_BW_200_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_203;
    break;
  case RAL_LORA_BW_250_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_250;
    break;
  case RAL_LORA_BW_400_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_406;
    break;
  case RAL_LORA_BW_500_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_500;
    break;
  case RAL_LORA_BW_800_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_812;
    break;
  case RAL_LORA_BW_1000_KHZ:
    radio_mod_params->bw = LR20XX_RADIO_LORA_BW_1000;
    break;
  default:
    return RAL_STATUS_UNKNOWN_VALUE;
  }
  radio_mod_params->cr = ral_mod_params->cr;
  radio_mod_params->ppm = ral_mod_params->ldro;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_convert_lora_pkt_params_from_ral
          (ral_lora_pkt_params_t *ral_pkt_params,lr20xx_radio_lora_pkt_params_t *radio_pkt_params)
{
  lr20xx_radio_lora_pkt_params_t *radio_pkt_params_local;
  ral_lora_pkt_params_t *ral_pkt_params_local;
  
  radio_pkt_params->preamble_len_in_symb = ral_pkt_params->preamble_len_in_symb;
  if (ral_pkt_params->header_type == RAL_LORA_PKT_EXPLICIT)
  {
    radio_pkt_params->pkt_mode = LR20XX_RADIO_LORA_PKT_EXPLICIT;
  }
  else
  {
    if (ral_pkt_params->header_type != RAL_LORA_PKT_IMPLICIT)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    radio_pkt_params->pkt_mode = LR20XX_RADIO_LORA_PKT_IMPLICIT;
  }
  radio_pkt_params->pld_len_in_bytes = ral_pkt_params->pld_len_in_bytes;
  radio_pkt_params->crc = ral_pkt_params->crc_is_on == true;
  radio_pkt_params->iq = ral_pkt_params->invert_iq_is_on == true;
  return RAL_STATUS_OK;
}



ral_status_t
ral_lr20xx_convert_lora_cad_params_from_ral
          (ral_lora_cad_params_t *ral_lora_cad_params,
          lr20xx_radio_lora_cad_params_t *radio_lora_cad_params)
{
  ral_lora_cad_exit_modes_t rVar1;
  uint32_t uVar2;
  lr20xx_radio_lora_cad_params_t *radio_lora_cad_params_local;
  ral_lora_cad_params_t *ral_lora_cad_params_local;
  
  switch(ral_lora_cad_params->cad_symb_nb)
  {
  case RAL_LORA_CAD_01_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x01';
    break;
  case RAL_LORA_CAD_02_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x02';
    break;
  case RAL_LORA_CAD_04_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x04';
    break;
  case RAL_LORA_CAD_08_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\b';
    break;
  case RAL_LORA_CAD_16_SYMB:
    radio_lora_cad_params->cad_symb_nb = '\x10';
    break;
  default:
    return RAL_STATUS_UNKNOWN_VALUE;
  }
  radio_lora_cad_params->cad_detect_peak = ral_lora_cad_params->cad_det_peak_in_symb;
  rVar1 = ral_lora_cad_params->cad_exit_mode;
  if (rVar1 == RAL_LORA_CAD_LBT)
  {
    radio_lora_cad_params->cad_exit_mode = LR20XX_RADIO_LORA_CAD_EXIT_MODE_TX;
  }
  else
  {
    if (RAL_LORA_CAD_LBT < rVar1)
    {
      return RAL_STATUS_UNKNOWN_VALUE;
    }
    if (rVar1 == RAL_LORA_CAD_ONLY)
    {
      radio_lora_cad_params->cad_exit_mode = LR20XX_RADIO_LORA_CAD_EXIT_MODE_STANDBYRC;
    }
    else
    {
      if (rVar1 != RAL_LORA_CAD_RX)
      {
        return RAL_STATUS_UNKNOWN_VALUE;
      }
      radio_lora_cad_params->cad_exit_mode = LR20XX_RADIO_LORA_CAD_EXIT_MODE_RX;
    }
  }
  uVar2 = lr20xx_radio_common_convert_time_in_ms_to_rtc_step(ral_lora_cad_params->cad_timeout_in_ms)
  ;
  radio_lora_cad_params->cad_timeout_in_pll_step = uVar2;
  radio_lora_cad_params->pnr_delta = '\0';
  return RAL_STATUS_OK;
}



void ral_lr20xx_convert_lr_fhss_params_from_ral
               (ral_lr_fhss_params_t *ral_lr_fhss_params,
               lr20xx_radio_lr_fhss_params_t *radio_lr_fhss_params)
{
  int8_t iVar1;
  lr_fhss_v1_modulation_type_t lVar2;
  lr_fhss_v1_cr_t lVar3;
  lr_fhss_v1_grid_t lVar4;
  lr_fhss_v1_bw_t lVar5;
  _Bool _Var6;
  uint8_t uVar7;
  undefined2 uVar8;
  lr20xx_radio_lr_fhss_params_t *radio_lr_fhss_params_local;
  ral_lr_fhss_params_t *ral_lr_fhss_params_local;
  
  lVar2 = (ral_lr_fhss_params->lr_fhss_params).modulation_type;
  lVar3 = (ral_lr_fhss_params->lr_fhss_params).cr;
  lVar4 = (ral_lr_fhss_params->lr_fhss_params).grid;
  lVar5 = (ral_lr_fhss_params->lr_fhss_params).bw;
  _Var6 = (ral_lr_fhss_params->lr_fhss_params).enable_hopping;
  uVar7 = (ral_lr_fhss_params->lr_fhss_params).header_count;
  uVar8 = *(undefined2 *)&(ral_lr_fhss_params->lr_fhss_params).field_0xa;
  iVar1 = ral_lr_fhss_params->device_offset;
  (radio_lr_fhss_params->lr_fhss_params).sync_word = (ral_lr_fhss_params->lr_fhss_params).sync_word;
  (radio_lr_fhss_params->lr_fhss_params).modulation_type = lVar2;
  (radio_lr_fhss_params->lr_fhss_params).cr = lVar3;
  (radio_lr_fhss_params->lr_fhss_params).grid = lVar4;
  (radio_lr_fhss_params->lr_fhss_params).bw = lVar5;
  (radio_lr_fhss_params->lr_fhss_params).enable_hopping = _Var6;
  (radio_lr_fhss_params->lr_fhss_params).header_count = uVar7;
  *(undefined2 *)&(radio_lr_fhss_params->lr_fhss_params).field_0xa = uVar8;
  radio_lr_fhss_params->device_offset = iVar1;
  return;
}



ral_status_t ral_lr20xx_rttof_set_parameters(void *context,uint8_t nb_symbols)
{
  lr20xx_status_t lVar1;
  uint8_t nb_symbols_local;
  void *context_local;
  lr20xx_rttof_params_t params;
  
  params.mode = LR20XX_RTTOF_MODE_NORMAL;
  params.spy_mode = LR20XX_RTTOF_SPY_MODE_DISABLED;
  params.nb_symbol = nb_symbols;
  lVar1 = lr20xx_rttof_set_params(context,&params);
  return lVar1;
}



ral_status_t ral_lr20xx_rttof_set_address(void *context,uint32_t address,uint8_t check_length)
{
  lr20xx_status_t lVar1;
  uint8_t check_length_local;
  uint32_t address_local;
  void *context_local;
  
  lVar1 = lr20xx_rttof_set_responder_address(context,address,check_length);
  return lVar1;
}



ral_status_t ral_lr20xx_rttof_set_request_address(void *context,uint32_t request_address)
{
  lr20xx_status_t lVar1;
  uint32_t request_address_local;
  void *context_local;
  
  lVar1 = lr20xx_rttof_set_initiator_address(context,request_address);
  return lVar1;
}



ral_status_t ral_lr20xx_rttof_set_rx_tx_delay_indicator(void *context,uint32_t delay_indicator)
{
  lr20xx_status_t lVar1;
  uint32_t delay_indicator_local;
  void *context_local;
  
  lVar1 = lr20xx_rttof_set_tx_rx_delay(context,delay_indicator);
  return lVar1;
}



ral_status_t
ral_lr20xx_rttof_get_raw_result
          (void *context,ral_lora_bw_t rttof_bw,int32_t *raw_results,int32_t *meter_results,
          int8_t *rssi_result)
{
  lr20xx_status_t lVar1;
  int32_t iVar2;
  int32_t *meter_results_local;
  int32_t *raw_results_local;
  ral_lora_bw_t rttof_bw_local;
  void *context_local;
  lr20xx_radio_lora_mod_params_t radio_mod_params;
  ral_lora_mod_params_t lora_mod_params;
  lr20xx_rttof_results_t results;
  ral_status_t ral_status;
  lr20xx_status_t lr20xx_status;
  
  results.val = 0;
  results.rssi = '\0';
  results._5_3_ = 0;
  lVar1 = lr20xx_rttof_get_results(context,&results);
  if (lVar1 == LR20XX_STATUS_OK)
  {
    lora_mod_params = (ral_lora_mod_params_t)((uint)rttof_bw << 8);
    radio_mod_params.sf = 0;
    radio_mod_params.bw = LR20XX_RADIO_LORA_BW_7;
    radio_mod_params.cr = LR20XX_RADIO_LORA_NO_CR;
    radio_mod_params.ppm = LR20XX_RADIO_LORA_NO_PPM;
    lVar1 = ral_lr20xx_convert_lora_mod_params_from_ral(&lora_mod_params,&radio_mod_params);
    if (lVar1 == LR20XX_STATUS_OK)
    {
      *raw_results = results.val;
      *rssi_result = results.rssi;
      iVar2 = lr20xx_rttof_distance_raw_to_meter(radio_mod_params.bw,results.val);
      *meter_results = iVar2;
      lVar1 = LR20XX_STATUS_OK;
    }
  }
  return lVar1;
}



smtc_shield_lr20xx_pinout_t *
smtc_shield_lr20xx_common_get_pinout(smtc_shield_lr20xx_connector_interface_t connector_type)
{
  smtc_shield_lr20xx_pinout_t *psVar1;
  smtc_shield_lr20xx_connector_interface_t connector_type_local;
  
  if (connector_type == SMTC_SHIELD_LR20XX_CONNECTOR_INTERFACE_XIAO_NRF54L15_CONNECTOR)
  {
    psVar1 = &smtc_shield_lr20xx_common_xiao_nrf54l15_connector_pinout;
  }
  else if (connector_type == SMTC_SHIELD_LR20XX_CONNECTOR_INTERFACE_ARDUINO_UNO_CONNECTOR)
  {
    psVar1 = &smtc_shield_lr20xx_common_arduino_uno_connector_pinout;
  }
  else
  {
    psVar1 = (smtc_shield_lr20xx_pinout_t *)0x0;
  }
  return psVar1;
}



smtc_shield_lr20xx_pa_pwr_cfg_t *
smtc_shield_lr20xx_common_get_pa_pwr_cfg
          (uint32_t rf_freq_in_hz,int8_t expected_output_pwr_in_half_dbm)
{
  char cVar1;
  int8_t expected_output_pwr_in_half_dbm_local;
  uint32_t rf_freq_in_hz_local;
  int8_t index;
  int8_t index_1;
  
  if (rf_freq_in_hz < 1900000000)
  {
    if ((149999999 < rf_freq_in_hz) && (rf_freq_in_hz < 0x39387001))
    {
      cVar1 = expected_output_pwr_in_half_dbm + '\"';
      if ((-1 < cVar1) && (cVar1 < 'O'))
      {
        return smtc_shield_lr2021_common_pa_lf_pwr_cfg + cVar1;
      }
      return &smtc_shield_lr20xx_common_pa_lf_default_pwr_cfg;
    }
  }
  else if (((1999999999 < rf_freq_in_hz) && (rf_freq_in_hz < 0x7d2b7501)) ||
          ((2399999999 < rf_freq_in_hz && (rf_freq_in_hz < 0x9502f901))))
  {
    cVar1 = expected_output_pwr_in_half_dbm + '\"';
    if ((-1 < cVar1) && (cVar1 < ';'))
    {
      return smtc_shield_lr2021_common_pa_hf_pwr_cfg + cVar1;
    }
    return &smtc_shield_lr20xx_common_pa_hf_default_pwr_cfg;
  }
  return (smtc_shield_lr20xx_pa_pwr_cfg_t *)0x0;
}



lr20xx_radio_common_rssi_calibration_gain_table_t *
smtc_shield_lr20xx_common_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr20xx_radio_common_rssi_calibration_gain_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  if (rf_freq_in_hz < 600000000)
  {
    plVar1 = &smtc_shield_lr20xx_common_rssi_calibration_table_below_600mhz;
  }
  else if ((rf_freq_in_hz < 600000000) || (2000000000 < rf_freq_in_hz))
  {
    plVar1 = &smtc_shield_lr20xx_common_rssi_calibration_table_above_2ghz;
  }
  else
  {
    plVar1 = &smtc_shield_lr20xx_common_rssi_calibration_table_from_600mhz_to_2ghz;
  }
  return plVar1;
}



// WARNING: Unknown calling convention

lr20xx_system_dio_t * smtc_shield_lr20xx_common_get_irq_dio(void)
{
  return &smtc_shield_lr20xx_common_irq_dio;
}



// WARNING: Unknown calling convention

lr20xx_system_reg_mode_t * smtc_shield_lr20xx_common_get_reg_mode(void)
{
  return &smtc_shield_lr20xx_common_reg_mode;
}



// WARNING: Unknown calling convention

lr20xx_system_lfclk_cfg_t * smtc_shield_lr20xx_common_get_lfclk_cfg(void)
{
  return &smtc_shield_lr20xx_common_lfclk_cfg;
}



// WARNING: Unknown calling convention

smtc_shield_lr20xx_xosc_cfg_t * smtc_shield_lr20xx_common_get_xosc_cfg(void)
{
  return &smtc_shield_lr20xx_common_xosc_no_tcxo_cfg;
}



_Bool smtc_shield_lr20xx_common_rttof_recommended_rx_tx_delay_indicator
                (uint32_t rf_freq_in_hz,lr20xx_radio_lora_bw_t bw,lr20xx_radio_lora_sf_t sf,
                uint32_t *delay_indicator)
{
  _Bool _Var1;
  uint32_t *delay_indicator_local;
  lr20xx_radio_lora_sf_t sf_local;
  lr20xx_radio_lora_bw_t bw_local;
  uint32_t rf_freq_in_hz_local;
  uint8_t column_index;
  uint8_t row_index;
  
  *delay_indicator = 0;
  if (false)
  {
switchD_08028efa_caseD_8:
    _Var1 = false;
  }
  else
  {
    switch(bw)
    {
    case LR20XX_RADIO_LORA_BW_125:
      row_index = '\0';
      break;
    case LR20XX_RADIO_LORA_BW_250:
      row_index = '\x02';
      break;
    case LR20XX_RADIO_LORA_BW_500:
      row_index = '\x04';
      break;
    case LR20XX_RADIO_LORA_BW_1000:
      row_index = '\x06';
      break;
    default:
      goto switchD_08028efa_caseD_8;
    case LR20XX_RADIO_LORA_BW_203:
      row_index = '\x01';
      break;
    case LR20XX_RADIO_LORA_BW_406:
      row_index = '\x03';
      break;
    case LR20XX_RADIO_LORA_BW_812:
      row_index = '\x05';
    }
    switch(sf)
    {
    case LR20XX_RADIO_LORA_SF5:
      column_index = '\0';
      break;
    case LR20XX_RADIO_LORA_SF6:
      column_index = '\x01';
      break;
    case LR20XX_RADIO_LORA_SF7:
      column_index = '\x02';
      break;
    case LR20XX_RADIO_LORA_SF8:
      column_index = '\x03';
      break;
    case LR20XX_RADIO_LORA_SF9:
      column_index = '\x04';
      break;
    case LR20XX_RADIO_LORA_SF10:
      column_index = '\x05';
      break;
    case LR20XX_RADIO_LORA_SF11:
      column_index = '\x06';
      break;
    case LR20XX_RADIO_LORA_SF12:
      column_index = '\a';
      break;
    default:
      return false;
    }
    if (rf_freq_in_hz < 600000000)
    {
      *delay_indicator = rttof_delay_indicator_table_below_600mhz[row_index][column_index];
    }
    else if ((rf_freq_in_hz < 600000000) || (1999999999 < rf_freq_in_hz))
    {
      *delay_indicator = rttof_delay_indicator_table_above_2ghz[row_index][column_index];
    }
    else
    {
      *delay_indicator = rttof_delay_indicator_table_from_600mhz_to_2ghz[row_index][column_index];
    }
    _Var1 = true;
  }
  return _Var1;
}



lr20xx_system_dio_rf_switch_cfg_t *
smtc_shield_lr20xx_common_get_rf_switch_cfg(lr20xx_system_dio_t dio)
{
  byte bVar1;
  undefined1 uVar2;
  lr20xx_system_dio_t dio_local;
  smtc_shield_lr20xx_dio_cfg_t dio_cfg;
  uint8_t dio_num;
  
  bVar1 = dio - LR20XX_SYSTEM_DIO_5;
  if ((bVar1 < 7) &&
     (uVar2 = smtc_shield_lr20xx_common_transceiver_dio_cfg[bVar1].dio_function,
     uVar2 == LR20XX_SYSTEM_DIO_FUNC_RF_SWITCH))
  {
    return &smtc_shield_lr20xx_common_transceiver_dio_cfg[bVar1].rf_switch_cfg;
  }
  return (lr20xx_system_dio_rf_switch_cfg_t *)0x0;
}



lr20xx_system_dio_drive_t * smtc_shield_lr20xx_common_get_dio_sleep_drive(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_drive_t *plVar1;
  lr20xx_system_dio_t dio_local;
  uint8_t dio_num;
  
  if ((byte)(dio - LR20XX_SYSTEM_DIO_5) < 7)
  {
    plVar1 = &smtc_shield_lr20xx_common_transceiver_dio_cfg[(byte)(dio - LR20XX_SYSTEM_DIO_5)].
              dio_drive_sleep;
  }
  else
  {
    plVar1 = (lr20xx_system_dio_drive_t *)0x0;
  }
  return plVar1;
}



lr20xx_system_dio_func_t * smtc_shield_lr20xx_common_get_dio_function(lr20xx_system_dio_t dio)
{
  smtc_shield_lr20xx_dio_cfg_t *psVar1;
  lr20xx_system_dio_t dio_local;
  uint8_t dio_num;
  
  if ((byte)(dio - LR20XX_SYSTEM_DIO_5) < 7)
  {
    psVar1 = smtc_shield_lr20xx_common_transceiver_dio_cfg + (byte)(dio - LR20XX_SYSTEM_DIO_5);
  }
  else
  {
    psVar1 = (smtc_shield_lr20xx_dio_cfg_t *)0x0;
  }
  return &psVar1->dio_function;
}



lr20xx_system_irq_mask_t * smtc_shield_lr20xx_common_get_dio_irq_mask(lr20xx_system_dio_t dio)
{
  byte bVar1;
  undefined1 uVar2;
  lr20xx_system_dio_t dio_local;
  smtc_shield_lr20xx_dio_cfg_t dio_cfg;
  uint8_t dio_num;
  
  bVar1 = dio - LR20XX_SYSTEM_DIO_5;
  if ((bVar1 < 7) &&
     (uVar2 = smtc_shield_lr20xx_common_transceiver_dio_cfg[bVar1].dio_function,
     uVar2 == LR20XX_SYSTEM_DIO_FUNC_IRQ))
  {
    return &smtc_shield_lr20xx_common_transceiver_dio_cfg[bVar1].irq_mask;
  }
  return (lr20xx_system_irq_mask_t *)0x0;
}



lr20xx_system_dio_rf_switch_cfg_t *
smtc_shield_lr2021_arduino_legacy_get_rf_switch_cfg(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_rf_switch_cfg_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_rf_switch_cfg(dio);
  return plVar1;
}



lr20xx_system_dio_drive_t *
smtc_shield_lr2021_arduino_legacy_get_dio_sleep_drive(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_drive_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_dio_sleep_drive(dio);
  return plVar1;
}



lr20xx_system_dio_func_t *
smtc_shield_lr2021_arduino_legacy_get_dio_function(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_func_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_dio_function(dio);
  return plVar1;
}



lr20xx_system_irq_mask_t *
smtc_shield_lr2021_arduino_legacy_get_dio_irq_mask(lr20xx_system_dio_t dio)
{
  lr20xx_system_irq_mask_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_dio_irq_mask(dio);
  return plVar1;
}



// WARNING: Unknown calling convention

lr20xx_system_reg_mode_t * smtc_shield_lr2021_arduino_legacy_get_reg_mode(void)
{
  lr20xx_system_reg_mode_t *plVar1;
  
  plVar1 = smtc_shield_lr20xx_common_get_reg_mode();
  return plVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr20xx_xosc_cfg_t * smtc_shield_lr2021_arduino_legacy_get_xosc_cfg(void)
{
  smtc_shield_lr20xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr20xx_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr20xx_pinout_t * smtc_shield_lr2021_arduino_legacy_get_pinout(void)
{
  return &smtc_shield_lr20xx_arduino_legacy_pinout;
}



// WARNING: Unknown calling convention

lr20xx_system_lfclk_cfg_t * smtc_shield_lr2021_arduino_legacy_get_lfclk_cfg(void)
{
  lr20xx_system_lfclk_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr20xx_common_get_lfclk_cfg();
  return plVar1;
}



lr20xx_radio_common_rssi_calibration_gain_table_t *
smtc_shield_lr2021_arduino_legacy_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr20xx_radio_common_rssi_calibration_gain_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



lr20xx_system_dio_rf_switch_cfg_t *
smtc_shield_lr2021_evk_get_rf_switch_cfg(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_rf_switch_cfg_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_rf_switch_cfg(dio);
  return plVar1;
}



lr20xx_system_dio_drive_t * smtc_shield_lr2021_evk_get_dio_sleep_drive(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_drive_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_dio_sleep_drive(dio);
  return plVar1;
}



lr20xx_system_dio_func_t * smtc_shield_lr2021_evk_get_dio_function(lr20xx_system_dio_t dio)
{
  lr20xx_system_dio_func_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_dio_function(dio);
  return plVar1;
}



lr20xx_system_irq_mask_t * smtc_shield_lr2021_evk_get_dio_irq_mask(lr20xx_system_dio_t dio)
{
  lr20xx_system_irq_mask_t *plVar1;
  lr20xx_system_dio_t dio_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_dio_irq_mask(dio);
  return plVar1;
}



// WARNING: Unknown calling convention

lr20xx_system_reg_mode_t * smtc_shield_lr2021_evk_get_reg_mode(void)
{
  lr20xx_system_reg_mode_t *plVar1;
  
  plVar1 = smtc_shield_lr20xx_common_get_reg_mode();
  return plVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr20xx_xosc_cfg_t * smtc_shield_lr2021_evk_get_xosc_cfg(void)
{
  smtc_shield_lr20xx_xosc_cfg_t *psVar1;
  
  psVar1 = smtc_shield_lr20xx_common_get_xosc_cfg();
  return psVar1;
}



// WARNING: Unknown calling convention

smtc_shield_lr20xx_pinout_t * smtc_shield_lr2021_evk_get_pinout_arduino(void)
{
  smtc_shield_lr20xx_pinout_t *psVar1;
  
  psVar1 = smtc_shield_lr20xx_common_get_pinout
                     (SMTC_SHIELD_LR20XX_CONNECTOR_INTERFACE_ARDUINO_UNO_CONNECTOR);
  return psVar1;
}



// WARNING: Unknown calling convention

lr20xx_system_lfclk_cfg_t * smtc_shield_lr2021_evk_get_lfclk_cfg(void)
{
  lr20xx_system_lfclk_cfg_t *plVar1;
  
  plVar1 = smtc_shield_lr20xx_common_get_lfclk_cfg();
  return plVar1;
}



lr20xx_radio_common_rssi_calibration_gain_table_t *
smtc_shield_lr2021_evk_get_rssi_calibration_table(uint32_t rf_freq_in_hz)
{
  lr20xx_radio_common_rssi_calibration_gain_table_t *plVar1;
  uint32_t rf_freq_in_hz_local;
  
  plVar1 = smtc_shield_lr20xx_common_get_rssi_calibration_table(rf_freq_in_hz);
  return plVar1;
}



// WARNING: This function may have set the stack pointer

void Reset_Handler(void)
{
  undefined4 *puVar1;
  int iVar2;
  
  SystemInit();
  for (iVar2 = 0; iVar2 + 0x20000000U < 0x200008f8; iVar2 += 4)
  {
    *(undefined4 *)(iVar2 + 0x20000000) = *(undefined4 *)(&_sidata + iVar2);
  }
  for (puVar1 = &completed_8100; puVar1 < &_ebss; puVar1 = puVar1 + 1)
  {
    *puVar1 = 0;
  }
  __libc_init_array();
  main();
  do
  {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void TIM1_BRK_TIM15_IRQHandler(void)
{
  do
  {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



int _init(EVP_PKEY_CTX *ctx)
{
  return (int)ctx;
}



void _fini(void)
{
  return;
}


